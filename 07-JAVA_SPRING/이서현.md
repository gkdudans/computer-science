\## Java, Spring

### 1\. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.
>   JVM(Java Virtual Machine)은 자바 바이트코드를 실행하는 가상 머신입니다. (=자바 프로그램의 실행 환경. 플랫폼 독립성 보장.)
>   주 기능: 바이트코드 로딩 (ClassLoader), 바이트코드 검증 (Bytecode Verifier), 바이트코드 실행 (인터프리터 + JIT 컴파일), 메모리 관리 (GC 포함), 스레드, 예외 처리 등 런타임 지원,

*   그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?
>   처음에는 자바만 JVM에서 실행되었지만, 시간이 지나며 다양한 언어들이 JVM 위에서 실행되도록 설계되었습니다. 대표적으로 Kotlin, Scala, Groovy 등이 있으며, 이들은 모두 자바처럼 JVM 바이트코드로 컴파일되어 동일한 런타임 환경에서 실행됩니다.

*   반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
> JVM 언어는 일반적으로 바이트코드로 컴파일되어 JVM 위에서 실행됩니다. 네이티브 바이너리로 직접 실행되려면 GraalVM 등 별도 AOT 컴파일러가 필요합니다.

*   VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
> **1. 장점**
> - 플랫폼 독립성 확보 (WORA)
> - GC, 예외 처리 등 런타임 지원
> - JIT 최적화를 통한 실행 성능 향상
> - 보안성과 안정성 제공
> 
> **2. 단점**
> - 초기 실행 지연 및 메모리 오버헤드
> - 네이티브보다 낮은 성능
> - 시스템 자원 접근 제한
> - 실시간 처리나 저수준 프로그래밍에 부적합
> 

*   JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
> 아닙니다. 일반적으로 JVM 프로세스가 단일 사용자 프로세스이고, 애플리케이션은 그 안에서 실행되는 '쓰레드 단위의 논리적 실행'입니다. 따서 OS 관점에서는 하나의 JVM 프로세스일 뿐, 애플리케이션은 그 안의 코드입니다.

### 2\. final 키워드를 사용하면, 어떤 이점이 있나요?
> final은 불변성을 보장함으로써 코드의 안정성과 명확성을 높이고, 컴파일러나 JIT 컴파일러의 최적화를 가능하게 합니다.
> - 변수에 사용 시: 값 재할당을 방지하여 사이드 이펙트 없는 안전한 코드 작성 가능
> - 메서드에 사용 시: 오버라이딩을 방지하여 의도하지 않은 다형성 오용을 차단
> - 클래스에 사용 시: 상속 자체를 막아 설계의 고정성과 보안성 강화
> - 성능 측면: JIT 컴파일러가 final 메서드나 클래스에 대해 인라인 최적화를 적용할 수 있어 실행 속도 향상에 기여

*   그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
> final 키워드는 컴파일러와 JVM/JIT에서 다르게 취급됩니다.
> 1. 컴파일러(javac) 수준
> - final 변수는 컴파일 타임 상수로 간주되어 코드에 값이 직접 인라인됨
> - final 메서드/클래스는 오버라이딩/상속 불가 검사를 통해 코드 안정성 보장
> 2. JVM 및 JIT 컴파일러 수준
> - final 메서드는 오버라이딩 불가능하므로 인라인 최적화 가능
> - final 클래스는 타입이 고정되어 가상 메서드 호출 제거 등의 최적화 가능

### 3\. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.
> 인터페이스와 추상 클래스는 모두 '추상화'를 위한 도구지만, 추상화의 방식과 목적이 다릅니다.
> - 인터페이스는 구현과 무관하게 행위(기능)만을 추상화하며, 객체가 어떤 **능력(can-do)**을 갖고 있는지를 표현합니다. 서로 다른 계층이나 도메인에서도 공통 기능을 통합할 수 있도록 해주며, 다형성과 유연한 설계에 유리합니다.
> - 추상 클래스는 **공통된 상태(필드)와 행위(메서드)**를 묶어 부분 구현된 상위 타입을 정의할 때 사용합니다. 즉, is-a 관계가 명확한 계층 구조에서 사용되며, 구체 클래스 간의 구현 공유가 목적입니다.

*   왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?
> 클래스는 **상태(필드)**와 **구현(메서드)**을 모두 가지므로 다중 상속 시 멤버 충돌이나 **상속 경로 모호성(MRO, Method Resolution Order)** 문제가 발생할 수 있습니다(다이아몬드 상속 문제). 반면 인터페이스는 원칙적으로 구현 없이 메서드 시그니처만 정의하므로 충돌 가능성이 낮아 다중 구현이 허용됩니다. Java 8 이후 default 메서드가 도입되었지만, 충돌 발생 시 명시적으로 해결하도록 강제함으로써 여전히 다중 구현이 가능합니다.

### 4\. 리플렉션에 대해 설명해 주세요.
> 리플렉션은 런타임에 클래스의 메타데이터에 접근해 클래스의 메서드, 타입, 필드 등의 정보를 조회/조작할 수 있는 자바 API입니다. (->구체적인 클래스 타입을 알지 못해도 접근 가능)

*   의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?
> 리플렉션은 접근 제어자를 무시하고 private 멤버에 접근하는 등 보안 정책을 우회할 수 있다는 보안상 취약점이 있습니다. (클래스로더 조작 가능)

> 보안 위험 방지 방법:
> * SecurityManager 설정으로 리플렉션 접근 제한
> * 모듈 시스템(Java 9+)에서 exports 제한
> * 런타임에 필요한 최소한의 권한만 부여

*   리플렉션을 언제 활용할 수 있을까요?
> * Spring의 의존성 주입
> * JPA의 엔티티 매핑
> * JSON 직렬화/역직렬화
> * 단위 테스트에서 private 메서드 테스트
> IDE에서 Getter, Setter 자동 생성  기능

### 5\. static class와 static method를 비교해 주세요.
> static class는 중첩 클래스에서만 사용이 가능하고, 외부 클래스 인스턴스 없이 생성할 수 있습니다. 외부 클래스를 참조할 수 없습니다.
> static method는 어떤 클래스에서든 사용이 가능하고, 클래스 인스턴스 없이 호출할 수 있습니다. 인스턴스 변수에 접근할 수 없습니다.

*   static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?
> static 사용 이점: 메모리에 한 번만 로드되므로 메모리 효율성 높음, 객체 생성 없이 접근 가능해 접근 속도 빠름 -> 공통 기능 제공, 유틸리티 함수 구현에 적합
> static 사용 시 제약: 인스턴스 변수나 메서드 접근 불가, 오버라이딩 불가, 상속 시 숨김 처리 (this. super 키워드 사용 불가하며 다형성 구현 제한)

*   컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.

> 1. 컴파일러가 static 멤버를 클래스 레벨로 바인딩
> 2. 바이트코드에서 invokestatic 명령어 생성
> 3. 런타임에 클래스 로더가 Method Area에 로드 (클래스와 같이 로딩)

### 6\. Java의 Exception에 대해 설명해 주세요.
> Java는 Exception은 프로그램 실행 중 발생할 수 있는 예외 상황을 나타내는 객체입니다. Throwable 클래스를 상속받습니다.

*   예외처리를 하는 세 방법에 대해 설명해 주세요.
> (1) 예외 복구, (2) 예외 회피, (3) 예외 전환

*   CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.
> * Checked Exception: 컴파일러가 처리를 강제하여 컴파일 시점에 반드시 try catch 등으로 처리해야 하는 예외.
>   - Exception 클래스를 상속하는 예외 중 RuntimeException을 상속하지 않는 예외 (IOException, SQLException 등)
>   - try-catch 블록이나, throws 키워드를 사용하여 예외를 처리하도록 명시해야
> * Unchecked Exception: 런타임에 발생하며 처리가 선택적인 예외.
>   - RuntimeException을 상속하는 예외 (NullPointerException, IllegalArgumentException 등)
>   - 주로 개발자의 실수 혹은 논리 오류로 발생, 컴파일러가 처리가 강제하지 않으나 예외 처리 시 프로그램 안정성을 높일 수 있음

*   예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?
> 예외 발생 시 예외 객체 생성 비용에 들어 성능이 저하됩니다. (정상적인 흐름에서 예외를 사용하면 비효율적)
> * 성능 최적화 방법:
>   - 예외를 제어 흐름으로 사용하지 않기
>   - 미리 정의된 예외 객체 재사용
>   - 검증 로직으로 예외 발생 최소화
>   - fillInStackTrace() 오버라이드로 스택 트레이스 생성 생략

### 7\. Synchronized 키워드에 대해 설명해 주세요.
> Synchronized는 여러 스레드가 동시에 접근하는 것을 제어하여 스레드 안전성을 보장하는 Java의 키워드입니다. 내부적으로 모니터 락(Monitor Lock)을 통해 상호 배제를 구현합니다.

*   Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.
> 메서드에 붙으면 인스턴스/클래스 전체를 락으로 사용하고, 블록에 붙으면 지정한 객체를 락으로 사용합니다.

*   효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?
> Synchronized는 간단하지만 성능상 제약이 있습니다. 블로킹 방식이고 세밀한 제어가 어려워 상황에 따라 다른 동기화 기법도 고려해야 합니다.

*   Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.
> • ReentrantLock: 더 세밀한 제어, 타임아웃 설정 가능
> • ReadWriteLock: 읽기/쓰기 락 분리
> • Atomic 클래스: Lock-free 알고리즘 사용
> • ConcurrentCollections: 동시성 컬렉션
> • Semaphore: 리소스 개수 제한

*   Thread Local에 대해 설명해 주세요.
> ThreadLocal은 각 스레드마다 독립적인 변수 복사본을 제공하는 클래스입니다. 스레드 간 데이터 공유 없이 스레드별로 고유한 데이터를 저장할 수 있습니다. 메모리 누수 주의가 필요합니다. (remove() 호출)

### 8\. Java Stream에 대해 설명해 주세요.
> Stream은 Java 8부터 도입된 함수형 프로그래밍 스타일로 컬렉션을 처리할 수 있는 API입니다. 데이터의 흐름을 추상화하여 선언적으로 데이터를 처리할 수 있게 해줍니다.
> Stream의 특징:
> • 함수형 프로그래밍: 람다식과 메서드 참조 사용
> • 지연 평가(Lazy Evaluation): 종료 연산이 호출될 때까지 중간 연산 지연
> • 내부 반복: 컬렉션의 반복을 Stream이 담당
> • 불변성: 원본 데이터 변경하지 않음
> • 일회용: 한 번 사용하면 재사용 불가

*   Stream과 for ~ loop의 성능 차이를 비교해 주세요.
> 일반적으로 단순한 반복에서는 for loop이 더 빠릅니다. 복잡한 데이터 처리나 병렬 처리에서는 Stream이 유리할 수 있습니다.

*   Stream은 병렬처리 할 수 있나요?
> parallelStream() 메서드나 parallel() 메서드를 사용하여 병렬 처리가 가능합니다. 그러나 스레드 안전하지 않은 연산 주의해야 하고, 작은 데이터셋에서는 오히려 성능 저하될 수 있습니다.

*   Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.
> • Predicate<T>: boolean test(T t) - 조건 검사 (filter)
> • Function<T, R>: R apply(T t) - 변환 (map)
> • Consumer<T>: void accept(T t) - 소비 (forEach)
> • Supplier<T>: T get() - 공급 (generate)
> • BinaryOperator<T>: T apply(T t1, T t2) - 결합 (reduce)
> • Comparator<T>: int compare(T o1, T o2) - 비교 (sorted)

*   가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?
> 람다식에서는 effectively final 변수만 캡처할 수 있기 때문입니다. 이는 클로저의 안전성과 동시성 문제를 방지하기 위한 제약입니다.

### 9\. Java의 GC에 대해 설명해 주세요.
> > Garbage Collection(GC)은 JVM이 자동으로 사용하지 않는 메모리를 회수하는 메커니즘입니다. 프로그래머가 명시적으로 메모리를 해제할 필요가 없게 해줍니다.
> GC의 동작 원리:
> • Mark: 루트 객체로부터 참조되는 객체들을 표시
> • Sweep: 표시되지 않은 객체들을 메모리에서 제거
> • Compact: 메모리 단편화 해결을 위한 압축 (선택적)
> 메모리 영역:
> • Young Generation: Eden, Survivor0, Survivor1
> • Old Generation: 오래 살아남은 객체들
> • Permanent/Metaspace: 클래스 메타데이터 저장

*   finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?
> finalize() 메서드의 수동 호출은 예측 불가능한 동작과 성능 문제를 야기할 수 있습니다. GC의 정상적인 동작을 방해할 수도 있습니다. -> Java 9부터 finalize()가 deprecated되었습니다. finalize() 대신 try-with-resources나 명시적 close() 사용을 권장합니다.

*   어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?
> 해당 객체를 참조하는 다른 변수가 있는지 여부가 중요합니다.
> GC 대상이 되는 조건:
> • 도달 불가능(Unreachable): 루트 객체로부터 참조 경로가 없음
> • 참조 카운트 0: 해당 객체를 가리키는 참조가 모두 사라짐
> • Strong Reference 없음: WeakReference만 남은 경우

### 10\. equals()와 hashcode()에 대해 설명해 주세요.
> equals()는 두 객체가 논리적으로 동등한지 판단하는 메서드입니다. hashCode()는 객체의 해시값을 반환하는 메서드입니다. 둘 다 Object 클래스에 정의되어 있으며, Hash 기반 컬렉션에서 중요한 역할을 합니다.

*   본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?
> 해시 충돌을 최소화하고 균등한 분산을 위해 equals()에서 사용하는 필드들을 활용하여 구현하겠습니다.
> 구현 시 고려사항:
> • equals()와 일관성: equals()에서 사용하는 필드만 사용
> • 균등한 분산: 해시값이 고르게 분포되도록 설계
> • 성능: 계산 비용이 너무 크지 않도록 주의
> • 안정성: 객체 상태가 변하지 않는 한 동일한 값 반환
> 일반적인 구현 패턴:

*   그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.
> equals() 메서드는 동치관계의 특성을 만족하도록 구현해야 하며, hashCode()와의 일관성을 유지해야 합니다.
> equals() 계약 조건:
> • 반사성(Reflexive): x.equals(x)는 항상 true
> • 대칭성(Symmetric): x.equals(y)가 true이면 y.equals(x)도 true
> • 이행성(Transitive): x.equals(y)와 y.equals(z)가 true이면 x.equals(z)도 true
> • 일관성(Consistent): 객체가 변경되지 않았다면 여러 번 호출해도 같은 결과
> • null 처리: x.equals(null)은 항상 false
> 구현 시 주의사항:
> • instanceof 연산자로 타입 체크
> • 자기 자신과의 비교 먼저 확인
> • 핵심 필드들을 순서대로 비교
> • Float, Double은 compare() 메서드 사용
> • 배열 필드는 Arrays.equals() 사용

### 11\. IoC와 DI에 대해 설명해 주세요.
> IoC(Inversion of Control)는 제어의 역전을 의미하며, 객체의 생성과 생명주기 관리를 개발자가 아닌 컨테이너가 담당하는 설계 원칙입니다. DI(Dependency Injection)는 IoC를 구현하는 구체적인 방법 중 하나입니다.
> IoC(제어의 역전):
> • 전통적 방식: 객체가 직접 의존성을 생성하고 관리
> • IoC 방식: 외부 컨테이너가 객체 생성과 의존성 주입을 담당
> • 장점: 결합도 감소, 테스트 용이성, 유연성 증가
> DI(의존성 주입):
> • Constructor Injection: 생성자를 통한 주입
> • Setter Injection: Setter 메서드를 통한 주입
> • Field Injection: 필드에 직접 주입 (@Autowired)

*   후보 없이 특정 기능을 하는 클래스가 딱 한 개라면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?
> 미래의 확장성, 테스트 용이성, AOP 적용, 생명주기 관리 등을 위해 

*   Spring의 Bean 생성 주기에 대해 설명해 주세요.
> • Bean 인스턴스 생성: 기본 생성자 호출
> • 의존성 주입: 프로퍼티 설정, @Autowired 처리
> • BeanNameAware: Bean 이름 설정
> • BeanFactoryAware: BeanFactory 설정
> • ApplicationContextAware: ApplicationContext 설정
> • BeanPostProcessor.postProcessBeforeInitialization(): 초기화 전 처리
> • @PostConstruct / InitializingBean.afterPropertiesSet(): 초기화
> • BeanPostProcessor.postProcessAfterInitialization(): 초기화 후 처리
> • Bean 사용 준비 완료
> • @PreDestroy / DisposableBean.destroy(): 소멸 처리

*   프로토타입 빈은 무엇인가요?
> 프로토타입 빈은 요청할 때마다 새로운 인스턴스를 생성하는 빈입니다. 기본적인 싱글톤 빈과 달리 매번 다른 객체가 반환됩니다.

### 12\. AOP에 대해 설명해 주세요.

*   @Aspect는 어떻게 동작하나요?

### 13\. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.

*   설명만 들어보면 인터셉터만 쓰는게 나아보이는데, 아닌가요? 필터는 어떤 상황에 사용 해야 하나요?

### 14\. DispatcherServlet 의 역할에 대해 설명해 주세요.

*   여러 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?
*   수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요?

### 15\. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?

*   영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?
*   N + 1 문제에 대해 설명해 주세요.

### 16\. @Transactional 은 어떤 기능을 하나요?

*   @Transactional(readonly=true) 는 어떤 기능인가요? 이게 도움이 되나요?
*   그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?

### 17\. Java 에서 Annotation 은 어떤 기능을 하나요?

*   별 기능이 없는 것 같은데, 어떻게 Spring 에서는 Annotation 이 그렇게 많은 기능을 하는 걸까요?
*   Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?

### 18\. Tomcat이 정확히 어떤 역할을 하는 도구인가요?

*   혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?