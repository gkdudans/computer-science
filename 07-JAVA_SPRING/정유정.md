## Java, Spring

# 1. JVM

<details>
<summary>JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.</summary>

- JVM은 자바 바이트코드를 실행해주는 가상 머신으로, 자바 프로그램의 런타임 환경을 제공하는 역할을 합니다. 작성된 자바 코드는 컴파일되면 `.class`라는 바이트코드로 변환되고, 이 바이트코드를 실제 머신 코드로 변환해서 실행해주는 것이 JVM입니다.

- 이 과정을 통해 자바는 플랫폼 독립성을 가지게 되고, Write Once, Run Anywhere를 실현할 수 있습니다. (한 번만 작성하면 어디서든 실행 가능!)

![img_jyj.png](img%2Fimg_jyj.png)

</details>

<details>
<summary>그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?</summary>

- 가능합니다. JVM은 바이트코드를 실행하는 범용 실행 환경이기 때문에, Kotlin, Groovy, Scala 같은 언어들도 JVM 위에서 실행될 수 있습니다.

</details>

<details>
<summary>반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?</summary>

- 기본적으로는 JVM 언어는 JVM 바이트코드를 생성하도록 설계되어 있어서, 일반적인 네이티브 바이너리로 바로 컴파일해서 실행하는 건 어렵습니다.

- 하지만 예외적으로 GraalVM이나 Kotlin/Native와 같은 도구를 사용하면 JVM 언어도 네이티브 바이너리로 컴파일이 가능합니다. 코드를 JVM 없이 실행할 수 있도록 모든 기능을 컴파일 타임에 고정해서 미리 만들어 줍니다.

- 다만 이 경우 JVM의 GC, 런타임 최적화 같은 이점은 포기해야 합니다. JVM의 주요 이점은 "런타임 환경"에서 제공하는 것이고, GC(가비지 컬렉션)는 더 이상 사용되지 않는 메모리를 자동으로 회수하는 기능이며, JIT 컴파일 최적화도 있습니다.

</details>

<details>
<summary>VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.</summary>

- 장점은 플랫폼 독립성과 안정성, 런타임 최적화입니다. JVM만 있다면 어떤 운영체제에서도 자바 코드를 실행할 수 있고, 런타임 중 JIT 컴파일러를 통해 코드가 최적화되기도 합니다. 또한 JVM이 예외 처리나 메모리 관리(GC)를 담당하므로 개발자는 비즈니스 로직에 집중할 수 있습니다.

- 단점은 성능과 자원 사용 측면입니다. VM 위에서 동작하다 보니 네이티브 코드보다는 실행 속도가 느리고, JVM 자체도 메모리와 CPU 자원을 별도로 사용하기 때문에 무거운 환경에서는 부담이 될 수 있습니다.

</details>

<details>
<summary>JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?</summary>

- 아니요, 일반적으로는 부모-자식 프로세스 관계가 아닙니다.

- 실제 관계는 JVM이 하나의 프로세스로 실행되고, Java 애플리케이션은 JVM 내부의 스레드로 실행되는 단일 프로세스 - 스레드 관계입니다.

- 예외 상황으로는 ProcessBuilder를 사용하여 외부 프로세스를 실행하는 경우에만 JVM이 부모 프로세스가 됩니다. 장점은 스레드가 자원 공유를 통해 효율적으로 통신하고 작업 처리할 수 있다는 점입니다.

</details>

# 2. final 키워드

<details>
<summary>final 키워드를 사용하면, 어떤 이점이 있나요?</summary>

- final 키워드는 불변성을 보장하기 때문에 코드 안정성이 증가합니다. 특히 안전한 공유 객체가 되어 멀티스레드 환경에서 동기화 문제를 줄일 수 있습니다.

> ### final은 불변을 보장할까?
> 1.  final은 재할당을 막는 키워드일 뿐이다. 
> 2. 기본 타입(primitive)은 값 자체가 바뀌지 않아 사실상 불변처럼 동작한다.
> 3. 참조 타입(객체, 컬렉션)은 내부 상태 변경은 막지 못하므로 불변을 보장하지 않는다.
> ```java
> // 기본 타입 - 불변
> final int age = 25;
> age = 30; // 컴파일 에러. 값 변경 불가
> 
> // 객체 - 내부 상태 변경 가능
> final Person person = new Person("김철수");
> person.setName("김영희"); // 내부 상태는 변경됨
> 
> // 컬렉션 - 요소 추가/삭제 가능
> final List<String> names = new ArrayList<>();
> names.add("김철수"); // 리스트에 요소 추가됨
> ```

</details>

<details>
<summary>그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?</summary>

- 네, final 키워드는 컴파일 과정에서 특별하게 취급됩니다. final이 붙은 기본형 상수나 문자열 상수는 컴파일 시점에 값이 코드에 직접 삽입됩니다. 이런 것을 compile-time constant라고 부르며, JVM은 해당 클래스를 로딩하지 않고도 값을 사용할 수 있습니다.

</details>

# 3. 인터페이스와 추상 클래스

<details>
<summary>인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.</summary>

- 인터페이스와 추상 클래스 모두 다형성을 제공하지만, 목적과 구조가 다릅니다.

- 추상 클래스는 상속받을 클래스들이 공통으로 가지는 메서드와 필드가 많아 중복 멤버 통합이 필요할 때 사용합니다. extends 키워드를 사용하고 단일 상속만 가능하며, 공통 기능을 제공하여 재사용성을 향상시킵니다.

- 인터페이스는 애플리케이션의 기능을 정의해야 하지만 그 구현 방식이나 대상에 대해 추상화할 때 사용합니다. implements 키워드를 사용하고 다중 구현이 가능하며, 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장합니다.

</details>

<details>
<summary>왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?</summary>

- 클래스 단일 상속 제한 이유는 다이아몬드 문제 때문입니다. 두 개 이상의 클래스에서 상속받을 때 같은 메서드가 구현되어 있을 경우, 자식 클래스에 어떤 메서드를 상속받아야 하는지 모호해지는 문제가 발생할 수 있고, 상속 구조가 복잡해져 유지보수가 어려워집니다.

- 인터페이스 다중 구현이 가능한 이유는 메서드 구현을 강제하지만, 메서드의 구현은 자식 클래스가 담당하기 때문입니다. 메서드 충돌 시 오버라이딩을 통해 충돌을 해결할 수 있고, "동일한 실행"을 보장하기 위한 계약이므로 다중 구현이 자연스럽습니다.

</details>

# 4. 리플렉션

<details>
<summary>리플렉션에 대해 설명해 주세요.</summary>

- 리플렉션(Reflection)은 실행 시간(런타임)에 클래스, 메서드, 필드 등의 정보를 동적으로 조회하고 조작할 수 있는 기능입니다. 특히 스프링 프레임워크에서는 리플렉션을 사용해서 많은 핵심 기능들을 구현합니다. 의존성 주입 등이 대표적인 예시입니다.

</details>

<details>
<summary>의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?</summary>

- 네, 리플렉션을 사용하면 기본적으로 접근할 수 없는 private 필드나 메서드에 접근하고 이를 수정할 수 있습니다. 클래스 설계자가 의도한 방식이 아니기 때문에 보안에 취약점이 발생할 수 있습니다.

- 또한 리플렉션을 사용하여 특정 부분을 동적으로 변경해 악성 코드를 삽입하거나 실행할 수 있습니다. 이를 방지하기 위해 보안관리자를 활성화하여 리플렉션을 사용할 수 있는 코드와 사용할 수 없는 코드를 구분하거나, setAccessible(false)로 하여 꼭 필요한 경우에만 공개합니다.

</details>

<details>
<summary>리플렉션을 언제 활용할 수 있을까요?</summary>

- 리플렉션은 주로 프레임워크와 라이브러리 개발에서 많이 사용됩니다. 스프링 프레임워크의 경우 의존성 주입(DI)이나 AOP 프록시 생성 시 클래스 정보를 동적으로 분석하여 빈을 생성하고 주입하는 데 활용합니다.
    - 스프링에서 리플렉션 동작 과정을 자세히 보면, 먼저 @Component나 @Service 같은 어노테이션이 붙은 클래스를 스캔할 때 리플렉션을 사용하여 해당 클래스의 메타데이터를 읽어옵니다. 그 다음 @Autowired나 @Resource 같은 의존성 주입 시에는 리플렉션으로 필드나 생성자의 타입 정보를 분석하여 적절한 빈을 찾아서 주입합니다.
    - AOP의 경우 @Transactional 같은 어노테션이 붙은 메서드를 찾기 위해 리플렉션으로 메서드 정보를 분석하고, 프록시 객체를 생성할 때도 원본 메서드의 시그니처를 리플렉션으로 파악하여 메서드 호출을 가로채는 구조를 만듭니다.

- 또한 JUnit과 같은 테스트 프레임워크에서는 테스트 클래스의 메서드를 동적으로 찾아서 실행하거나, Mockito 같은 모킹 라이브러리에서는 프록시 객체를 생성할 때 리플렉션을 사용합니다.

</details>

# 5. static

<details>
<summary>static class와 static method를 비교해 주세요.</summary>

- static class는 주로 내부 클래스에서 사용되며, 외부 클래스의 인스턴스 없이 독립적으로 동작할 수 있도록 합니다. 외부 참조 문제를 해결하여 외부 인스턴스 참조로 인한 메모리 누수 현상을 방지하고, 클래스 정의를 위한 것입니다.

- static method는 특정 객체가 아닌 클래스 자체에서 호출할 수 있는 메서드로, 주로 유틸리티 함수나 공통 기능을 구현하는 데 사용됩니다. 특정 동작을 수행하는 것이고, 두 개 모두 인스턴스 없이 호출 가능하다는 공통점이 있습니다.

</details>

<details>
<summary>static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?</summary>

- 이점으로는 메모리 최적화가 있습니다. 객체를 생성하지 않고도 멤버에 접근할 수 있어 성능 향상의 이점이 있고, 고정된 영역만 사용하여 메모리 낭비를 방지할 수 있습니다.

- 제약으로는 메모리 누수 가능성이 있습니다. static으로 선언된 멤버는 JVM의 heap 영역이 아닌 method area에 저장되고 GC의 대상이 아니므로 메모리 누수가 발생할 수 있습니다. 또한 객체지향 원칙을 위반하고, 프로그램 종료 시까지 메모리가 할당되어 남발 시 메모리와 프로그램 성능이 저하될 수 있습니다.

</details>

<details>
<summary>컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.</summary>

- 컴파일 단계에서 .class 파일에 static 멤버가 존재하면, 객체 생성 없이도 접근 가능하도록 바이트 코드가 생성됩니다. JVM이 실행될 때는 Method Area에 static 멤버가 저장되고 런타임 시에 static 멤버는 객체 생성과 관계없이 접근이 가능합니다. 메모리 할당은 객체가 heap 영역 메모리에 올라가기 전에 호출해서 사용할 수 있습니다.

</details>

# 6. Exception

<details>
<summary>Java의 Exception에 대해 설명해 주세요.</summary>

- Exception은 프로그램 실행 중에 발생할 수 있는 오류 상황을 처리하기 위한 Java의 메커니즘입니다. 예외의 정의는 사용자의 조작이나 개발자의 코딩 실수 등으로 발생하는 오류이고, 예외 처리의 목적은 프로그램이 비정상적으로 종료되는 것을 방지하고, 오류 상황에 대한 적절한 대응을 하는 것입니다.

</details>

<details>
<summary>예외처리를 하는 세 방법에 대해 설명해 주세요.</summary>

- 첫 번째는 예외 복구입니다. 예외 상황을 파악하고 문제를 해결해서 정상 상태로 되돌려놓는 방법으로, 예외가 발생하더라도 일정 수만큼 재시도하여 예외 복구를 시도합니다.

- 두 번째는 예외 처리 회피입니다. 예외 처리를 직접 담당하지 않고 호출한 쪽으로 던져 회피하는 방법으로, 호출한 쪽에서 예외를 처리하는 것이 바람직할 때 사용합니다.

- 세 번째는 예외 전환입니다. 회피 방법과 비슷하게 메서드 밖으로 예외를 던지지만, 더 명확한 의미를 가진 예외로 변경해서 예외를 던지는 방법입니다.

</details>

<details>
<summary>CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.</summary>

- CheckedException은 개발자가 반드시 예외처리해야 하는 오류입니다. 미처리 시 컴파일 에러가 발생하고, 복구 가능성이 있는 예외로 IOException, SQLException 등이 대표적입니다.

- UncheckedException은 예외처리를 하지 않아도 컴파일 에러가 발생하지 않습니다. RuntimeException 클래스를 상속받는 예외들로, 복구 가능성이 없는 예외로 NullPointerException, ArrayIndexOutOfBoundsException 등이 대표적입니다. 예상치 못한 상황에서 발생하는 것이 아니므로 굳이 예외 처리를 강제하지 않습니다.

</details>

<details>
<summary>예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?</summary>

- 네, 예외처리가 성능에 영향을 미칠 수 있습니다. 성능 영향 요인으로는 스택 트레이스 캡처가 있습니다. JVM이 exception handler가 포함된 메서드를 찾기 위해 call stack을 검색하는 비용이 발생하고, 예외 객체 생성으로 인한 오버헤드가 있습니다.

- 부하를 줄이는 방법으로는 입력 값을 사전에 검증하여 예외 발생을 최소화하고, 예외 객체를 캐싱하여 재사용하며, 예외를 정상적인 제어 흐름으로 사용하지 않는 것입니다. 또한 커스텀 예외에서 fillInStackTrace를 오버라이드하여 스택 트레이스 생성 비용을 줄일 수 있습니다.

</details>

# 7. Synchronized

<details>
<summary>Synchronized 키워드에 대해 설명해 주세요.</summary>

- Synchronized 키워드는 자바에서 멀티스레드 환경에서 동기화를 보장하기 위해 사용하는 키워드입니다. 동작 원리는 공유자원에 여러 스레드가 동시에 접근하지 못하도록 락을 걸어 데이터 일관성을 유지하는 것입니다. 임계 영역(Critical Section)은 공유데이터가 사용되는 부분을 의미하며, 자바에서는 이 부분에 synchronized 키워드를 사용합니다.

</details>

<details>
<summary>Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.</summary>

- synchronized method는 인스턴스 단위로 lock을 걸지만, synchronized 키워드가 붙은 메소드들에 대해서만 lock을 공유합니다. synchronized 메소드를 호출하는 순간, 모든 synchronized 메소드에 lock이 걸려 다른 스레드가 어떠한 synchronized 메소드를 호출할 수 없습니다.

- static synchronized method는 인스턴스가 아닌 클래스 단위로 lock을 공유합니다. 인스턴스 단위에 거는 lock은 공유되지 않아 동기화 이슈가 발생할 수 있습니다.

- synchronized block은 synchronized 인자 값으로 this를 사용하면 block을 통해 만들어진 스레드는 lock을 공유하고, static이 추가되면 클래스 단위로 lock을 공유합니다.

</details>

<details>
<summary>효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?</summary>

- 멀티스레드 환경에서 데이터 정합성을 유지해야 하는 상황이라면 좋은 키워드입니다. 하지만 주의사항이 있습니다. 락을 획득하고 해제하는 과정에서 성능 저하가 발생하고, 경합 상태에서 병목이 심해지는 경향이 있으며, 단순한 읽기 작업에서도 불필요한 lock이 적용되면 속도 저하가 발생합니다. 또한 스레드 대기와 데드락의 위험성이 존재합니다. 결론적으로 상황에 맞게 사용해야 하며, 과도한 동기화는 성능 저하를 일으킬 수 있습니다.

</details>

<details>
<summary>Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.</summary>

- **Concurrent Collections**: 멀티스레드 환경에서 안전한 컬렉션 관리, 읽기와 쓰기 병행 작업이 많을 때 synchronized보다 효율적

- **ReentrantLock**: synchronized와 동일하게 한 번에 하나의 스레드만 접근 가능하지만, 더 세밀한 제어 가능
  - 락의 획득과 해제를 명시적으로 관리 (개발자가 직접 관리)
  - 공정성 설정, 타임아웃, 인터럽트 처리 가능
  - 락 해제(unlock())을 직접 호출해야 하기 때문에 잘못 쓰면 데드락 발생 가능

- **ReadWriteLock**: 읽기와 쓰기를 구분하여 동기화 적용
  - 다수의 스레드가 동시에 읽기 가능
  - 쓰기 작업 시에만 쓰기 락 적용
  - 읽기 작업이 많은 경우 성능 최적화 가능

- **Semaphore**: 일정 개수의 스레드만 공유 자원에 접근하도록 제어
  - 동시 접근 허용 개수 제한
  - 특정 리소스에 접근 가능한 최대 스레드 수 제한
  - 리소스 개수 기반 제어 가능 (동시성 수준 제한)

- **Atomic 클래스들** (AtomicInteger, AtomicLong 등): CAS(Compare-And-Swap) 기반으로 락 없이 원자적 연산 제공
  - 동기화 없이 안전한 연산 수행 가능
  - 내부적으로 JVM이 CPU의 CAS 명령어를 활용 → 매우 빠름, 성능 우수

- **CompletableFuture**: 비동기 프로그래밍을 통한 동시성 처리 제공

</details>

<details>
<summary>Thread Local에 대해 설명해 주세요.</summary>

- ThreadLocal은 Java에서 지원하는 Thread Safe한 기술로, 멀티 스레드 환경에서 각각의 스레드가 개별적으로 데이터를 저장하고 관리할 수 있도록 도와줍니다. 핵심 특징으로는 각 스레드가 별도의 저장공간을 할당받아 각 상태를 가질 수 있고, 멀티스레드 환경에서도 데이터 충돌 없이 안전하게 사용할 수 있습니다.

- 주의사항으로는 WAS 환경에서 Thread pool 기반으로 동작하므로 ThreadLocal 사용 후 비워주지 않으면 다른 사용자가 기존에 세팅된 ThreadLocal의 데이터를 공유할 수 있습니다. 메모리 누수 방지를 위해 Thread의 사용이 끝나는 시점에 ThreadLocal을 초기화할 필요가 있습니다. 사용처로는 Spring Security 내 context 보관 등이 있습니다.

</details>

# 8. Stream

<details>
<summary>Java Stream에 대해 설명해 주세요.</summary>

- Stream은 데이터 처리 파이프라인을 위한 API입니다. 

- 실제 개발에서 자주 사용하는 방식:
  - 컬렉션 데이터를 필터링할 때: filter()로 조건에 맞는 데이터만 추출
  - 데이터 변환할 때: map()으로 객체를 다른 형태로 변환
  - 데이터를 수집할 때: collect()로 결과를 리스트나 맵으로 모음
  - 데이터 개수나 합계를 구할 때: count(), sum() 등으로 집계

- Stream의 장점은 함수형 프로그래밍 스타일을 지원한다는 점이고, 지연 평가로 실제로 결과가 필요할 때까지 처리를 미룰 수 있습니다. 또한 원본 데이터를 건드리지 않아서 안전하게 사용할 수 있습니다.

</details>

<details>
<summary>Stream과 for ~ loop의 성능 차이를 비교해 주세요</summary>

- 일반적으로 Stream이 for loop보다 더 느립니다. 성능 차이 이유로는 for loop는 개념이 오래되어 JVM 내부에서 최적화가 잘 되어 있지만, Stream은 함수형 프로그래밍 특징인 불변성을 위해 복사를 해 메모리 증가, 오버헤드 등으로 속도가 느립니다.

- 단순한 반복 작업은 for loop가 유리하지만, 복잡한 데이터 처리나 가독성이 중요한 경우는 Stream이 유리합니다.

</details>

<details>
<summary>Stream은 병렬처리 할 수 있나요?</summary>

- 네, 병렬처리를 할 수 있습니다. 병렬처리 방법으로는 parallel() 메서드로 기존 Stream에 병렬 처리를 적용하거나, parallelStream()으로 병렬 처리가 적용된 Stream을 생성할 수 있습니다.

- 내부 동작은 Fork와 Join Framework를 사용하여 병렬 처리를 진행하고, 장점은 개발자가 직접 스레드나 스레드 풀을 생성 및 관리하지 않고 메서드로 간단하게 병렬처리를 진행할 수 있다는 점입니다. 주의사항은 모든 상황에서 병렬 처리가 유리하지는 않으며, 데이터 크기와 연산 복잡도를 고려해야 합니다.

</details>

<details>
<summary>Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.</summary>

- 총 4가지의 주요 함수형 인터페이스가 있습니다. 

- Predicate<T>는 주어진 입력을 받아 true 또는 false를 반환하는 인터페이스로 filter() 메서드에서 주로 사용합니다.

- Function<T, R>은 입력을 받아 다른 타입의 출력을 반환하는 함수형 인터페이스로 map() 메서드에서 주로 사용합니다.

- Supplier<T>는 매개변수 없이 값을 반환해주는 인터페이스로 generate() 메서드에서 주로 사용합니다.

- Consumer<T>는 입력을 받아 처리하지만 반환값이 없는 인터페이스로 forEach() 메서드에서 주로 사용합니다.

</details>

<details>
<summary>가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?</summary>

- 람다나 익명 클래스에서 외부 변수를 사용할 때 final이 필요한 이유는 변수의 수명이 다르기 때문입니다. 지역 변수는 메서드가 끝나면 사라지지만, 람다는 나중에 실행될 수 있어서 외부 변수가 중간에 바뀌면 람다가 실행될 때 예상과 다른 값을 사용할 수 있습니다.

- final을 사용하면 변수 값이 바뀌지 않음을 보장해서 안전하게 람다에서 사용할 수 있고, 코드를 읽는 사람도 이 변수는 바뀌지 않는다는 것을 쉽게 알 수 있습니다.

- Java 8 이후로는 final 없이도 사용할 수 있지만, 명시적으로 final을 붙이는 것이 좋습니다.

</details>

# 9. GC

<details>
<summary>Java의 GC에 대해 설명해 주세요.</summary>

- 가비지 컬렉션은 JVM의 Heap 영역에서 필요없게 된 메모리 객체를 모아 주기적으로 제거하는 프로세스입니다. 

- 핵심 특징으로는 자동 메모리 관리가 있습니다. C나 C++과 달리 프로그래머가 수동으로 메모리 할당과 해제를 하지 않아도 되고, 메모리 누수 방지로 개발자가 메모리 관리에 신경 쓰지 않고 개발에 집중할 수 있습니다. 또한 객체 참조 상태 기반으로 객체가 참조되고 있는 상태 여부로 제거 대상을 결정합니다.

- 다양한 GC 알고리즘을 설정을 통해 Java에 적용할 수 있고, Serial, Parallel, CMS, G1, ZGC 등이 있습니다. 다른 언어에도 내장되어 있어서 파이썬, 자바스크립트, GO 언어 등에도 GC 기능이 내장되어 있습니다.

- 단점으로는 예측 불가능성으로 메모리가 정확히 언제 해제되는지 알 수 없어 제어하기 어렵고, STW로 GC 동작 중에는 다른 동작이 멈춰 오버헤드가 발생하며, CPU 오버헤드로 GC 자체가 CPU 자원을 사용한다는 점이 있습니다.

</details>

<details>
<summary>finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?</summary>

- finalize()는 GC에 의해 객체가 제거될 때 자동으로 실행되는 메서드입니다. 

- 수동 호출 시 문제점:
  - 예측 불가한 실행: 어떤 스레드가 실행하는지 예측이 불가능
  - GC 스케줄링 방해: GC가 객체를 수집하지 않으려 하여 정상적으로 호출되지 않을 수 있음
  - 객체 부활: finalize()에서 객체를 다시 참조하게 되면 예상치 못하게 객체가 다시 살아날 수 있음
  - 동시성 문제: 여러 스레드에서 동시에 호출 시 동시성 문제가 야기될 수 있음
  - 보안 취약: finalize() 내의 예외는 JVM에 의해 잡히지 않음

- 대안: finalize() 대신 Cleaner나 AutoCloseable 인터페이스를 사용하고, try-with-resources 문법을 활용하는 것이 좋습니다.

</details>

<details>
<summary>어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?</summary>

- 상황에 따라 GC가 될 가능성이 있습니다. (“변수가 null이 되었다 = 무조건 GC 대상”은 아니고, 실제로는 해당 객체를 참조하는 다른 경로가 존재하는지 여부가 핵심)

- GC 대상이 되는 경우:
  - 객체가 null인 경우: 참조가 끊어진 객체
  - 블록 실행 종료 후: 블록 내에서 생성된 객체
  - 부모 객체가 null인 경우: 포함되는 자식 객체

- GC 대상이 되지 않는 경우:
  - null이 되었지만 다른 참조가 남아있는 경우: 다른 변수나 객체가 여전히 참조하고 있는 경우

</details>

# 10. equals와 hashCode

<details>
<summary>equals()와 hashcode()에 대해 설명해 주세요.</summary>

- equals()는 객체 간 논리적 동등성을 비교하는 메서드입니다. 기본적으로 Object 클래스의 equals() 메서드는 '==' 연산자와 동일하게 참조 비교를 수행하고, 객체 내용을 비교하려면 equals()를 오버라이딩해야 합니다.

- hashCode()는 객체의 해시 값을 반환하는 메서드로, HashMap, HashSet, HashTable 등에서 사용됩니다. 주의점은 equals()가 true를 반환하는 객체들은 반드시 hashCode()도 동일한 값을 반환해야 한다는 것입니다.

</details>

<details>
<summary>본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?</summary>

- equals()와의 일관성을 유지할 수 있도록 equals()가 true를 반환한 경우 hashCode()도 동일해야 한다는 것입니다. 객체가 변하지 않았을 때 해시 값도 변하지 않도록 고려하여 작성할 것 같습니다.

- 또한 좋은 해시 분포를 위해 다양한 값들이 균등하게 분포되도록 구현하고, 빠른 계산이 가능하도록 효율적인 알고리즘을 사용하며, null 값에 대한 안전한 처리를 해야 합니다. 해시 충돌의 경우 equals()가 달라도 hashCode() 값은 같을 수 있으므로 LinkedList 형태로 객체를 추가하는 방식을 고려해야 합니다.

</details>

<details>
<summary>그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.</summary>

- 5가지 일반 규약을 준수해야 합니다:
  - 반사성: x.equals(x)는 true
  - 대칭성: x.equals(y)가 true면 y.equals(x)도 true
  - 추이성: x.equals(y)가 true이고 y.equals(z)가 true면 x.equals(z)도 true
  - 일관성: x.equals(y)를 여러 번 호출해도 항상 같은 결과
  - null 아님: x.equals(null)은 false

- hashCode() 계약으로 반드시 hashCode()도 재정의해야 하고, instanceof 연산자로 올바른 타입인지 확인해야 합니다. fail-fast 최적화로 가능하면 getClass() 대신 instanceof를 사용하여 상속 관계를 고려해야 합니다.

</details>

# 11. IoC와 DI

<details>
<summary>IoC와 DI에 대해 설명해 주세요.</summary>

- IoC(Inversion of Control, 제어의 역전)는 개발자가 직접 관리하던 객체의 생성과 제어 흐름을 프레임워크나 컨테이너에 위임한다는 개념입니다. 객체의 생성, 초기화, 생명 주기 관리 등을 프레임워크가 처리하고, IoC 컨테이너(스프링 컨테이너)에 의해 관리됩니다.

- DI(Dependency Injection, 의존성 주입)는 빈 설정 정보를 바탕으로 컨테이너가 외부에서 객체를 생성해 필요한 클래스에 주입하는 패턴입니다. IoC의 구현 방식 중 하나입니다. DI를 사용하면 클래스 간의 의존 관계가 명확해지고, 테스트하기 쉬우며, 코드의 유연성이 높아집니다.
  - 생성자 주입: 객체 생성 시점에 의존성을 주입받아 한 번 설정되면 변경 불가
  - 수정자 주입: setter 메서드를 통해 언제든지 의존성을 변경 가능
  - 필드 주입: @Autowired를 필드에 직접 붙여서 주입받는 방식

</details>

<details>
<summary>후보 없이 특정 기능을 하는 클래스가 딱 한 개라라면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?</summary>

% 구체 클래스: 추상화되지 않은 실제 구현체

- 맞습니다. 그런 경우 구체 클래스를 직접 사용해도 된다고 생각합니다. 하지만 Spring에서 여전히 Bean을 등록해서 사용하는 것이 더 좋은 이유가 있습니다.

- 싱글톤 관리로 객체가 한 번만 생성되어 재사용되는 싱글톤 빈으로 관리되어 불필요한 객체 생성을 방지하고 성능 최적화를 할 수 있습니다. DI를 통한 결합도 감소로 타클래스 의존성을 낮출 수 있고, 객체 생명 주기 관리로 스프링이 객체의 생명 주기를 관리합니다. 부가 기능 추가로 로깅, 트랜잭션과 같은 부가 기능을 쉽게 추가할 수 있으며, 테스트 용이성으로 모킹과 테스트가 용이합니다.

</details>

<details>
<summary>Spring의 Bean 생성 주기에 대해 설명해 주세요.</summary>

- 스프링 Bean의 생명 주기는 스프링 컨테이너 생성부터 시작해서 Bean 생성, 의존성 주입, 초기화 콜백, Bean 사용, 소멸전 콜백을 거쳐 스프링 종료까지 진행됩니다.

- 초기화 콜백은 Bean이 생성되고 의존성 주입이 완료된 후에 호출되어 Bean이 사용되기 전 필요한 초기화 작업을 수행합니다.

- 소멸 전 콜백은 스프링이 종료되기 전에 호출되어 Bean이 소멸되기 전 정리 작업을 수행합니다.

</details>

<details>
<summary>프로토타입 빈은 무엇인가요?</summary>

- 프로토타입 빈은 스프링에서 빈을 등록하면 기본적으로 싱글톤으로 만들어지는데, 이를 싱글톤이 아닌 하나의 빈으로 여러 개의 객체를 만들고 싶을 때 사용하는 것입니다.

- 특징으로는 매번 새로운 인스턴스를 요청할 때마다 새로운 객체를 생성하고, 생명 주기는 스프링 컨테이너가 관리하지 않습니다.

- 사용 시 주의사항으로는 @Resource나 @Autowired 등으로 의존관계 주입 후 프로토타입 빈을 가져오려면 싱글톤 빈처럼 작동하기 때문에 ApplicationContext.getBean()을 사용해서 다른 객체를 가져와야 합니다. 생명 주기가 관리되는 스프링 빈과 달리, 프로토타입 빈은 개발자가 직접 관리해야 합니다.

</details>

# 12. AOP

<details>
<summary>AOP에 대해 설명해 주세요.</summary>

- AOP(Aspect-Oriented Programming)는 관점 지향 프로그래밍으로, 핵심 비즈니스 로직과 공통 관심사를 분리하여 모듈화하는 프로그래밍 패러다임입니다. 핵심 개념으로는 Aspect(공통 관심사를 모듈화한 객체), Pointcut(어디에 적용할지 결정하는 표현식), Advice(언제 무엇을 할지 정의), JoinPoint(메서드 실행 지점)가 있습니다.

- 실제 개발에서 자주 사용하는 예시로는 로깅, 트랜잭션 관리, 보안 검사, 성능 모니터링 등이 있습니다. 특히 @Transactional 어노테이션을 사용하면 메서드 실행 전후로 트랜잭션을 자동으로 시작하고 커밋/롤백하는 AOP가 동작합니다. 장점으로는 코드 중복 제거, 핵심 로직과 공통 로직의 분리, 유지보수성 향상이 있습니다. 단점으로는 런타임에 프록시 객체가 생성되어 성능 오버헤드가 발생할 수 있고, 디버깅이 복잡해질 수 있습니다.

</details>

<details>
<summary>@Aspect는 어떻게 동작하나요?</summary>

- @Aspect는 스프링 AOP에서 사용하는 어노테이션으로, 해당 클래스가 AOP의 Aspect 역할을 한다는 것을 명시합니다. 동작 과정을 자세히 설명하면, 스프링이 @Aspect가 붙은 클래스를 스캔하여 @Around, @Before, @After 등의 Advice 어노테이션이 붙은 메서드들을 찾습니다. 그 다음 @Pointcut으로 정의된 조건에 맞는 메서드들을 찾아서 프록시 객체를 생성합니다.

- 실제 메서드 호출 시에는 프록시가 가로채서 Advice에 정의된 로직을 먼저 실행하고, 그 다음 원본 메서드를 호출한 후, 필요에 따라 후처리 로직을 실행합니다. 예를 들어 @Transactional이 붙은 메서드를 호출하면, 프록시가 먼저 트랜잭션을 시작하고 원본 메서드를 실행한 후, 성공하면 커밋하고 실패하면 롤백하는 방식으로 동작합니다.

</details>

# 13. Interceptor와 Filter

<details>
<summary>Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.</summary>

- Interceptor와 Filter는 모두 요청과 응답을 가로채서 처리하는 기능을 제공하지만, 동작 위치와 사용 목적이 다릅니다. Filter는 서블릿 컨테이너 레벨에서 동작하며, 모든 요청에 대해 필터링을 수행합니다. 주로 인코딩, CORS, 보안 검사 등 웹 애플리케이션 전반에 적용되어야 하는 공통 기능을 처리합니다.

- Interceptor는 스프링 MVC 레벨에서 동작하며, 스프링 컨텍스트 내에서만 동작합니다. 주로 로그인 체크, 권한 검사, 로깅 등 비즈니스 로직과 관련된 공통 기능을 처리합니다. 주요 차이점으로는 Filter는 서블릿 컨테이너에 등록하고, Interceptor는 스프링 컨텍스트에 등록합니다. 또한 Filter는 모든 요청에 적용되지만, Interceptor는 특정 URL 패턴에만 적용할 수 있습니다.

</details>

<details>
<summary>설명만 들어보면 인터셉터만 쓰는게 나아보이는데, 아닌가요? 필터는 어떤 상황에 사용 해야 하나요?</summary>

- 인터셉터만 사용하는 것보다는 각각의 역할에 맞게 사용하는 것이 좋습니다. Filter를 사용해야 하는 상황은 서블릿 컨테이너 레벨에서 처리해야 하는 경우입니다. 예를 들어 인코딩 설정은 모든 요청에 대해 적용되어야 하므로 Filter를 사용해야 하고, CORS 설정도 브라우저의 preflight 요청을 포함한 모든 요청에 대해 처리해야 하므로 Filter가 적합합니다.

- 또한 보안 관련 기능 중 서블릿 컨테이너에서 처리해야 하는 것들(예: HTTPS 리다이렉트, 기본 인증 등)도 Filter를 사용해야 합니다. 결론적으로 Filter는 웹 애플리케이션의 기본적인 공통 기능을, Interceptor는 비즈니스 로직과 관련된 공통 기능을 처리하는 것이 바람직합니다.

</details>

# 14. DispatcherServlet

<details>
<summary>DispatcherServlet 의 역할에 대해 설명해 주세요.</summary>

- DispatcherServlet은 스프링 MVC의 핵심 컴포넌트로, 모든 HTTP 요청을 받아서 적절한 컨트롤러로 라우팅하는 프론트 컨트롤러 역할을 합니다. 주요 기능으로는 요청 URL을 분석하여 적절한 컨트롤러를 찾고, 요청 파라미터를 바인딩하며, 컨트롤러의 응답을 뷰로 전달하는 것입니다. 또한 예외 처리와 파일 업로드 처리도 담당합니다.

- 동작 과정을 자세히 설명하면, 클라이언트로부터 HTTP 요청을 받으면 HandlerMapping을 통해 요청을 처리할 컨트롤러를 찾고, HandlerAdapter를 통해 컨트롤러 메서드를 호출합니다. 그 다음 ViewResolver를 통해 적절한 뷰를 찾고, 최종적으로 응답을 클라이언트에게 전달합니다. 이 과정을 통해 개발자는 비즈니스 로직에만 집중할 수 있고, 공통적인 요청 처리 로직은 DispatcherServlet이 담당하게 됩니다.

</details>

<details>
<summary>여러 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?</summary>

- 네, DispatcherServlet은 멀티스레드 환경에서 동작하므로 여러 요청을 동시에 처리할 수 있습니다. 동작 원리는 서블릿 컨테이너(예: Tomcat)가 각 요청마다 별도의 스레드를 생성하여 DispatcherServlet을 호출하는 방식입니다. 각 스레드는 독립적으로 동작하므로 요청 간에 간섭이 발생하지 않습니다.

- 주의사항으로는 DispatcherServlet 자체는 스레드 안전하게 설계되어 있지만, 컨트롤러나 서비스에서 공유 상태를 사용할 때는 동기화 처리가 필요합니다. 또한 스레드 풀을 사용하여 스레드 생성 비용을 줄이고 성능을 최적화할 수 있습니다. 실제 운영 환경에서는 수백 개의 동시 요청을 처리할 수 있으며, 이는 서버의 성능과 설정에 따라 달라집니다.

</details>

<details>
<summary>수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요?</summary>

- DispatcherServlet은 HandlerMapping 인터페이스를 구현한 여러 구현체들을 통해 @Controller를 구분합니다. 주요 HandlerMapping으로는 RequestMappingHandlerMapping이 있는데, 이는 @RequestMapping 어노테이션이 붙은 메서드들을 스캔하여 URL 패턴과 HTTP 메서드를 키로 하는 맵을 생성합니다.

- 동작 과정을 자세히 설명하면, 애플리케이션 시작 시 스프링이 @Controller가 붙은 클래스들을 스캔하고, @RequestMapping이 붙은 메서드들의 정보를 수집합니다. 그 다음 URL 패턴과 HTTP 메서드를 조합하여 HandlerMapping에 저장합니다. 실제 요청이 들어오면 DispatcherServlet이 HandlerMapping에게 요청을 전달하고, HandlerMapping은 저장된 정보를 바탕으로 적절한 컨트롤러와 메서드를 찾아서 반환합니다.

- 이 과정을 통해 수많은 @Controller가 있어도 효율적으로 요청을 처리할 수 있습니다.

</details>

# 15. ORM

<details>
<summary>JPA와 같은 ORM을 사용하는 이유가 무엇인가요?</summary>

- ORM(Object-Relational Mapping)을 사용하는 주요 이유는 객체 지향 프로그래밍과 관계형 데이터베이스 간의 패러다임 불일치 문제를 해결하기 위해서입니다. 구체적인 장점으로는 생산성 향상이 있습니다. SQL 쿼리를 직접 작성하지 않고도 객체를 통해 데이터베이스를 조작할 수 있어 개발 속도가 빨라집니다. 또한 유지보수성 향상으로 데이터베이스 스키마가 변경되어도 엔티티 클래스만 수정하면 되므로 유지보수가 용이합니다.

- 객체 지향적 설계로 객체 간의 관계를 자연스럽게 표현할 수 있고, 데이터베이스에 독립적이어서 다른 데이터베이스로 쉽게 전환할 수 있습니다. 단점으로는 학습 곡선이 있고, 복잡한 쿼리의 경우 성능 최적화가 어려울 수 있으며, N+1 문제 같은 성능 이슈가 발생할 수 있습니다.

</details>

<details>
<summary>영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?</summary>

- 영속성(Persistence)은 엔티티를 데이터베이스에 저장하고 관리하는 기능으로, JPA의 핵심 개념 중 하나입니다. 주요 기능으로는 1차 캐시가 있습니다. 같은 엔티티를 여러 번 조회할 때 데이터베이스에 접근하지 않고 1차 캐시에서 가져와서 성능을 향상시킵니다. 또한 변경 감지(Dirty Checking)로 엔티티의 상태 변화를 자동으로 감지하여 UPDATE 쿼리를 자동으로 생성합니다.

- 성능 향상 측면에서는 1차 캐시를 통한 반복 조회 성능 향상과 변경 감지를 통한 불필요한 UPDATE 쿼리 방지가 있습니다. 하지만 1차 캐시는 영속성 컨텍스트 범위 내에서만 유효하고, 메모리 사용량이 증가할 수 있습니다. 실제로는 단순한 CRUD 작업에서는 성능 향상이 있지만, 복잡한 조인이나 대용량 데이터 처리에서는 네이티브 쿼리가 더 유리할 수 있습니다.

</details>

<details>
<summary>N + 1 문제에 대해 설명해 주세요.</summary>

- N+1 문제는 ORM에서 자주 발생하는 성능 문제로, 하나의 쿼리로 N개의 엔티티를 조회한 후, 각 엔티티와 연관된 데이터를 조회하기 위해 추가로 N번의 쿼리가 실행되는 현상입니다. 발생 원리는 지연 로딩(Lazy Loading)을 사용할 때 연관된 엔티티에 접근할 때마다 추가 쿼리가 실행되기 때문입니다. 예를 들어 게시글 목록을 조회한 후 각 게시글의 댓글을 조회할 때, 게시글 조회 1번 + 각 게시글의 댓글 조회 N번이 실행됩니다.

- 해결 방법으로는 즉시 로딩(Eager Loading)을 사용하거나, fetch join을 사용하여 한 번의 쿼리로 연관 데이터를 함께 조회하는 방법이 있습니다. 또한 @EntityGraph나 @BatchSize를 사용하여 배치 크기를 조정할 수도 있습니다. 주의사항으로는 즉시 로딩을 사용하면 불필요한 데이터까지 조회할 수 있고, fetch join을 사용하면 메모리 사용량이 증가할 수 있습니다.

</details>

# 16. Transactional

<details>
<summary>@Transactional 은 어떤 기능을 하나요?</summary>

- @Transactional은 스프링에서 트랜잭션을 관리하기 위한 어노테이션으로, 메서드나 클래스에 붙여서 해당 범위에서 트랜잭션을 자동으로 관리합니다. 주요 기능으로는 트랜잭션 시작, 커밋, 롤백을 자동으로 처리하는 것입니다. 메서드가 정상적으로 완료되면 자동으로 커밋되고, 예외가 발생하면 자동으로 롤백됩니다.

- 트랜잭션 전파 속성으로는 REQUIRED(기본값), REQUIRES_NEW, SUPPORTS, NOT_SUPPORTED 등이 있습니다. REQUIRED는 기존 트랜잭션이 있으면 참여하고, 없으면 새로 생성합니다. REQUIRES_NEW는 항상 새로운 트랜잭션을 생성합니다. 격리 수준 설정도 가능하여 READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE 중에서 선택할 수 있습니다. 기본값은 READ_COMMITTED입니다.

- 이 어노테이션을 통해 개발자는 복잡한 트랜잭션 관리 코드를 작성하지 않고도 안전한 트랜잭션 처리를 할 수 있습니다.

</details>

<details>
<summary>@Transactional(readonly=true) 는 어떤 기능인가요? 이게 도움이 되나요?</summary>

- @Transactional(readonly=true)는 읽기 전용 트랜잭션을 설정하는 속성으로, 데이터를 조회만 하고 수정하지 않는 메서드에 사용합니다. 주요 기능으로는 데이터베이스 최적화가 있습니다. 읽기 전용 트랜잌션으로 설정하면 데이터베이스가 해당 트랜잭션에서 데이터 변경이 발생하지 않을 것이라고 인식하여 읽기 성능을 최적화할 수 있습니다.

- 또한 Hibernate와 같은 JPA 구현체에서는 읽기 전용 엔티티로 처리하여 변경 감지(Dirty Checking)를 비활성화하고, 1차 캐시에 엔티티를 저장하지 않아 메모리 사용량을 줄일 수 있습니다. 실제 성능 향상은 데이터베이스 종류와 설정에 따라 다르지만, 일반적으로 읽기 작업이 많은 애플리케이션에서는 유의미한 성능 향상을 기대할 수 있습니다.

- 주의사항으로는 읽기 전용으로 설정했는데 데이터를 수정하려고 하면 예외가 발생할 수 있으므로, 정말로 읽기만 하는 메서드에만 사용해야 합니다.

</details>

<details>
<summary>그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?</summary>

- 읽기 작업에도 @Transactional을 사용하는 이유가 있습니다. 
- 첫 번째 이유는 데이터 일관성 보장입니다. 트랜잭션이 없으면 각각의 쿼리가 독립적으로 실행되어, 중간에 다른 트랜잭션이 데이터를 수정할 수 있습니다. 예를 들어 사용자 정보를 조회하는 중에 다른 사용자가 정보를 수정하면 일관성 없는 데이터를 볼 수 있습니다. 

- 두 번째 이유는 격리 수준 설정입니다. @Transactional의 isolation 속성을 통해 READ_COMMITTED나 REPEATABLE_READ 같은 격리 수준을 설정할 수 있어서, 동시성 문제를 방지할 수 있습니다. 세 번째 이유는 성능 최적화입니다. @Transactional(readonly=true)를 사용하면 데이터베이스가 읽기 전용 트랜잭션으로 인식하여 최적화를 수행할 수 있습니다.

- 하지만 단순한 조회 작업이라면 @Transactional 없이도 충분할 수 있으므로, 상황에 맞게 사용하는 것이 중요합니다.

</details>

# 17. Annotation

<details>
<summary>Java 에서 Annotation 은 어떤 기능을 하나요?</summary>

- Java에서 Annotation은 코드에 메타데이터를 추가하는 기능으로, 컴파일러나 런타임에 특정 정보를 제공하거나 동작을 제어하는 역할을 합니다. 주요 기능으로는 컴파일 시점 검사가 있습니다. @Override, @Deprecated, @SuppressWarnings 같은 어노테이션은 컴파일러가 코드를 검사할 때 사용되어 오버라이딩이 올바르게 되었는지, 사용이 권장되지 않는 메서드인지 등을 확인합니다.

- 런타임 시점 처리로는 @Test, @Component, @Autowired 같은 어노테이션이 런타임에 리플렉션을 통해 클래스나 메서드의 정보를 분석하고 특정 동작을 수행합니다. 코드 생성과 문서화도 가능하여 Lombok의 @Data 같은 어노테이션은 getter, setter, toString 등의 메서드를 자동으로 생성하고, JavaDoc을 통한 문서화도 지원합니다.

- 이 기능들을 통해 개발자는 반복적인 코드 작성을 줄이고, 코드의 가독성과 유지보수성을 향상시킬 수 있습니다.

</details>

<details>
<summary>별 기능이 없는 것 같은데, 어떻게 Spring 에서는 Annotation 이 그렇게 많은 기능을 하는 걸까요?</summary>

- Annotation 자체는 단순한 메타데이터일 뿐이지만, 스프링이 이를 처리하는 방식 때문에 강력한 기능을 제공할 수 있습니다. 핵심은 스프링의 리플렉션과 프록시 기반 처리입니다. @Component가 붙은 클래스를 스프링이 스캔하면, 리플렉션을 통해 해당 클래스의 정보를 분석하고 빈으로 등록합니다. @Autowired가 붙은 필드나 생성자도 리플렉션으로 타입 정보를 분석하여 적절한 빈을 주입합니다.

- AOP 처리도 마찬가지입니다. @Transactional이 붙은 메서드를 스프링이 발견하면, 프록시 객체를 생성하여 메서드 호출을 가로채고 트랜잭션을 시작/종료하는 로직을 추가합니다. 이 과정에서 스프링은 어노테이션의 속성값들을 읽어서 다양한 설정을 적용할 수 있습니다. 예를 들어 @RequestMapping의 value, method 속성을 통해 URL 패턴과 HTTP 메서드를 설정할 수 있습니다.

- 결론적으로 어노테이션은 "표시" 역할만 하고, 실제 기능은 스프링 프레임워크가 리플렉션과 프록시를 통해 구현하는 것입니다.

</details>

<details>
<summary>Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?</summary>

- @Data를 사용하지 않는 주요 이유는 과도한 기능 제공과 예상치 못한 동작 때문입니다. @Data는 @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor를 모두 포함하는데, 이 중 일부만 필요한 경우에도 불필요한 메서드들이 생성됩니다. 특히 @Setter는 모든 필드에 대해 생성되어 불변성을 보장할 수 없고, @ToString은 순환 참조가 있을 때 무한 루프를 발생시킬 수 있습니다.

- @EqualsAndHashCode도 주의가 필요한데, 모든 필드를 기준으로 equals와 hashCode를 생성하므로 엔티티의 경우 ID만을 기준으로 해야 하는데 모든 필드가 포함될 수 있습니다. 또한 @Data를 사용하면 생성되는 코드가 숨겨져 있어서 디버깅이 어려울 수 있고, 코드 리뷰 시 실제 동작을 파악하기 어려울 수 있습니다.

- 대신 필요한 어노테이션만 개별적으로 사용하는 것이 좋습니다. 예를 들어 @Getter만 필요한 경우 @Data 대신 @Getter만 사용하여 명확하고 안전한 코드를 작성할 수 있습니다.

</details>

# 18. Tomcat

<details>
<summary>Tomcat이 정확히 어떤 역할을 하는 도구인가요?</summary>

- Tomcat은 Apache Software Foundation에서 개발한 오픈소스 웹 애플리케이션 서버로, Java Servlet, JSP, WebSocket 등을 실행할 수 있는 환경을 제공합니다. 주요 역할로는 서블릿 컨테이너 기능이 있습니다. Java 웹 애플리케이션의 서블릿과 JSP를 실행하고, HTTP 요청을 받아서 적절한 서블릿으로 전달하며, 응답을 클라이언트에게 전송합니다.

- 또한 웹 서버 기능도 제공하여 정적 파일(HTML, CSS, JavaScript, 이미지 등)을 클라이언트에게 전송할 수 있습니다. HTTP 프로토콜을 처리하고, 요청 URL에 따라 적절한 리소스를 찾아서 제공합니다. JVM 위에서 동작하여 Java 애플리케이션을 실행할 수 있고, 스레드 풀을 관리하여 여러 클라이언트의 요청을 동시에 처리할 수 있습니다.

- 스프링 부트 애플리케이션을 실행할 때도 내장 톰캣을 사용하여 웹 애플리케이션을 실행할 수 있습니다.

</details>

<details>
<summary>혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?</summary>

- 네, Netty는 비동기 이벤트 기반 네트워크 애플리케이션 프레임워크로, 고성능 네트워크 서버를 구축할 때 사용합니다. Netty를 사용하는 주요 이유는 성능 때문입니다. 비동기 I/O를 사용하여 블로킹 없이 많은 수의 동시 연결을 처리할 수 있고, 이벤트 루프 모델을 사용하여 효율적인 스레드 관리가 가능합니다.

- 또한 확장성과 유연성이 뛰어납니다. 다양한 프로토콜(HTTP, WebSocket, TCP 등)을 지원하고, 핸들러 체인을 통해 요청 처리 로직을 유연하게 구성할 수 있습니다. 실제 사용 사례로는 게임 서버, 채팅 서버, 실시간 데이터 처리 서버 등이 있습니다. 특히 대용량 트래픽을 처리해야 하는 마이크로서비스 환경에서 많이 사용됩니다.

- 하지만 단점으로는 학습 곡선이 높고, 복잡한 비즈니스 로직을 구현할 때 코드가 복잡해질 수 있습니다. 따라서 단순한 CRUD 애플리케이션보다는 고성능이 요구되는 특수한 상황에서 사용하는 것이 적합합니다.

</details>