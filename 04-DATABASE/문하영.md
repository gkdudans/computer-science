# 데이터베이스

## 1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.

<details>
    <summary>Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.</summary>

- 1)슈퍼 키(Super Key)
  - 유일성 O, 최소성 X
  - 중복된 값이 존재하지 않는다.
  - 예를 들어, 유일성을 만족하는 학번을 가진 [학번 + 이름], [성별 + 학번] 등은 슈퍼키가 될 수 있다.
  - 하지만 [이름 + 성별] 은 두 가지가 모두 일치하는 사람이 존재할 수 있기 때문에 유일성 성립이 안된다.
- 2)복합 키(Composite Key)
  - 유일성 O, 최소성 O
  - 2개 이상의 속성(attribute)을 묶어서 기본키로 지정한 것이다.
- 3)후보 키(Candidate key)
  - 유일성 O, 최소성 O
  - 슈퍼키 중에서 최소성을 만족하는 키로, 기본키가 될 수 있는 후보이기 때문에 후보키라고 불린다.
  - 예를 들어, [주민등록번호], [학번] 같이 유일성을 만족하면서 최소성도 만족하면 후보키이다.
- 4)기본 키(Primary key)
  - 유일성 O, 최소성 O
  - 후보 키에서 선택된 키로, 레코드를 식별할때 기준이 되는 반드시 필요한 키이다.
  - NULL값, 중복값은 들어갈 수 없다.
- 5)대체 키(Surrogate / Alternate key)
  - 유일성 O, 최소성 O
  - 후보 키 중에 기본 키로 선택되지 않은 키이다.
- 6)외래 키(Foreign Key)
  - 테이블(relation)간의 관계를 나타낼때 사용하며, 다른 테이블의 기본키를 참조해 외래키로 사용한다.
  - 데이터 무결성을 위해 외래키를 설정한다.
  - 예를 들어, 왼쪽 테이블의 student_id 값이 변경되면 오른쪽 테이블의 student_id 도 변경되어야 한다.
</details>

<details>
    <summary>기본키는 수정이 가능한가요?</summary>

- 기본키는 논리적으로 수정 가능함 
- 단, 기본키는 한 행을 고유하게 식별하는 기준이기 때문에 이를 수정하면 관련된 외래키 관계나 다른 테이블의 데이터 무결성이 깨질 위험이 있음.
  - `ON UPDATE CASCADE`를 외래키 제약조건으로 설정하면 그 값을 참조하고 있는 테이블의 외래키 값도 함께 수정됨.
</details>

<details>
    <summary> 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?</summary>

- MySQL(InnoDB)는 반드시 한 개의 클러스터링 인덱스(clustered index)를 가져야 함. 
- **상황에 따른 InnoDB의 클러스터링 인덱스 사용**
  - PRIMARY KEY가 존재: 그 키를 클러스터형 인덱스로 사용
  - PRIMARY KEY가 없고, NOT NULL UNIQUE 인덱스가 있음: 그 중 첫 번째 인덱스를 클러스터형 인덱스로 사용
  - 위 두 경우 모두 없음: InnoDB가 숨겨진 6바이트짜리 `GEN_CLUST_INDEX`(암시적 기본 키) 를 생성
- **PK가 없는 테이블의 특징, 주의사항**
  - disk I/O 증가: GEN_CLUST_INDEX는 항상 INT 또는 BIGINT 타입의 숨겨진 열을 사용하므로, PK가 있는 테이블보다 저장 공간이 더 많이 차지할 수 있음
  - PK를 지정하지 않으면 데이터 무결성이 저하되고, PK를 지정할 때보다 성능이 저하될 수 있음
  - 사용자가 해당 암시적 기본 키를 볼 수도, 제어할 수도 없으므로 가시성 저하, 쿼리 성능 예측 어려움.
</details>

<details>
    <summary> 외래키 값은 NULL이 들어올 수 있나요?</summary>

- 가능한 이유: 외래키 제약조건(FK Constraint)에 의하면 NULL값은 '참조하지 않음'을 의미하기 때문
- 즉, 외래키 칼럼이 NOT NULL로 선언되어 있지 않다면, NULL을 허용
  - 외래키 칼럼에 NULL을 허용하는지 여부는 칼럼에 대한 정의에 따라 달라짐 
</details>

<details>
    <summary> 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?</summary>

- UNIQUE 제약조건을 설정하면 해당 컬럼에 자동으로 인덱스(index) 가 생성
  - 해당 컬럼을 이용한 검색(WHERE, JOIN, ORDER BY 등)을 훨씬 빠르게 수행할 수 있음
  - 다만 데이터 삽입/수정 시에는 인덱스 갱신이 필요하므로 쓰기 성능이 저하될 수 있음 
</details>

## 2. RDB와 NoSQL의 차이에 대해 설명해 주세요.

<details>
    <summary> RDB와 NoSQL의 차이에 대해 설명해 주세요.</summary>

- **RDB의 특징**
  - 데이터를 정해진 스키마와 테이블 기반 구로조 저장
  - 데이터 간의 관계를 외래키(Foreign Key) 로 표현
  - 대표적인 RDB: MySQL, Oracle 등
  - 정형화된 구조와 안정성 위주로 설계됨, 수직 확장, 복잡한 쿼리에 강하며 트랜잭션 ACID 보장 
- **NoSQL의 특징**
  - 정형화되지 않은(unstructured) 데이터를 관계형 모델이 아닌, 문서(document), 키-값(key-value), 그래프(graph), 컬럼(column) 등 다양한 형태로 저장
  - 대표적인 NoSQL: MongoDB (Document형), Redis, DynamoDB(Ke-Value형) 등
  - 스키마가 유연하고 수평 확장이 용이, 고가용성, 대용량 데이터와 비정형 데이터 처리에 적합함.
</details>

<details>
    <summary> NoSQL의 강점과, 약점이 무엇인가요?</summary>

- **NoSQL의 강점**
  - 수평적 확장성: 서버를 여러 대 추가하는 방식(Scale-out)으로 쉽게 확장 가능.
  - 빠른 읽기/쓰기 성능: RDB와 비교해 복잡한 연산이 적기 때문에 대용량 데이터에 비해 빠른 일긱/쓰기 처리 가능
  - 스키마의 유연성, 특정 용도에 최적화된 구조 선택 가능, 대규모 분산 저장에 유리한 고가용성
- **NoSQL의 약점**
  - 일관성 보장의 어려움: 데이터 불일치 상태가 발생하기 쉬운 구조.
  - 트랜잭션 지원이 제한적: RDB처럼 트랜잭션의 ACID를 지원하기 적음.
  - 복잡한 쿼리 처리의 어려움: 관계형 모델이 아니기 때문에 JOIN, GROUP By 등 복잡한 SQL 연산 처리는 어려움.
  - 관리 및 운영 복잡도 증가, 데이터 중복 및 관리 문제 발생 가능
</details>

<details>
    <summary> RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)</summary>

- RDB의 구조적 특징 때문
  - ACID 트랜잭션 보장: 데이터 무결성을 보장하는 핵심 기능, 데이터의 정합성을 지키기 위해 I/O와 동기화로 인한 부하 발생
  - JOIN 연산: 테이블을 읽고, 키로 조합한 후, 필요한 결과를 새로 구성해야 하는 연산으로, 데이터가 많을수록 조인으로 인한 부하가 급격히 커질 수 있음 
  - 테이블 정규화: RDB를 정규화(Normalization)할 경우 하나의 요청을 처리하기 위해 여러 테이블을 읽고 JOIN해야 함 
  - 동시성 제어를 위한 Lock: RDB는 트랜잭션 충돌을 방지하기 위해 행/테이블 단위로 Lock을 사용, 성능이 저하될 수 있음 
  - 제약 조건 검사: 삽입/수정 연산 시마다 데이터 무결성을 위한 기본키/외래키/도메인 제약조건을 검증하기 때문
  - 디스크 기반 저장 구조 사용: 버퍼 풀에 적재되지만, 디스크 기반 저장구조를 사용함 (일부 NoSQL은 메모리/분산 중심)
</details>

<details>
    <summary> NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.</summary>

- 채팅 기능(WebSocket + STOMP)을 위한 NoSQL(MongoDB)를 사용해 본 경험이 있음
  - 실시간 통신 환경에 적합한 빠른 쓰기/읽기 성능: 비정규화된 문서(Document) 구조 덕분에 메시지를 빠르게 저장하고 조회할 수 있음
  - 대용량 메시지 저장, 확장성 고려: 채팅 서버는 시간이 지날수록 데이터가 급격히 증가함, 수평적 확장을 지원하기 때문에 여러 노드로 부하 분산이 가능함.
  - 복잡한 관계가 없는 채팅 구조: 사용자-채팅방-메시지의 단순한 구조이기 때문에 JOIN 등의 복잡한 쿼리가 필요하지 않음 
</details>


## 3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.

<details>
    <summary> 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.</summary>

- 트랜잭션이란?
  - 데이터베이스에서 수행되는 하나의 논리적인 작업 단위
- **트랜잭션의 ACID 원칙**
  - 원자성 (Atomicity)
    - 트랜잭션 내 모든 작업이 모두 수행되거나 모두 수행되지 않아야 함 (All or Nothing)
  - 일관성 (Consistency)
    - 트랜잭션 수행 전후로 데이터의 무결성이 항상 유지되어야 함
  - 독립성 (Isolation)
    - 동시에 실행되는 트랜잭션들이 서로의 작업에 간섭하지 않아야 함
  - 지속성 (Durability)
    - 트랜잭션이 커밋(commit) 된 후에는, 시스템 장애가 나도 결과가 보존되어야 함
</details>

<details>
    <summary> ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?</summary>

- Write-Ahead Logging (WAL, 로그 선기록 기법): 
  - 트랜잭션이 커밋되면 그 변경 사항은 디스크에 기록되며, 시스템 장애 발생 시에도 로그를 이용해 데이터를 복구할 수 있음
  - Redo/Undo 로그: WAL 기법을 구현하기 위한 로그 종류 (WAL을 구현하는 실제 구조체)
    - Redo 로그: 커밋된 변경 사항을 복구 (Durability)
    - Undo 로그: 롤백 시 변경사항을 되돌림 (Atomicity)
  - 참고 자료
    - https://tech.kakao.com/posts/721
    - https://d2.naver.com/helloworld/407507
  - 로그를 디스크에 쓰는 과정
    - 1)트랜잭션 수행 중: 메모리의 버퍼(Buffer Pool)에서 데이터 수정, 동시에 UNDO/REDO 정보를 로그 버퍼(Log Buffer) 에 기록
    - 2)커밋 시점: 로그 버퍼의 해당 트랜잭션 로그를 디스크(Log File) 로 fsync(), 로그를 물리적으로 디스크에 기록 
    - 3)장애 발생 시: 아직 데이터 파일에는 반영되지 않았더라도 로그 파일에 기록된 REDO 로그를 이용해 다시 반영(redo)
- STEAL/FORCE 정책
  - STEAL 정책: 아직 커밋되지 않은 트랜잭션에 의해 수정된 데이터 페이지라도, 필요 시 해당 페이지를 버퍼 풀에서 디스크로 내려보내는 것(flush)을 허용
  - FORCE 정책: 트랜잭션이 커밋될 때, 해당 트랜잭션에 의해 변경된 모든 데이터 페이지를 즉시 디스크에 기록하도록 강제하는 정책
  - 대부분의 상용 DBMS는 성능상의 이유로 STEAL / NO-FORCE 정책 조합을 채택
- 체크포인트:
  - 주기적으로 로그 내용을 실제 데이터 파일에 반영
  - 이를 이용해 시스템 장애 발생 시 빠르게 복구할 수 있음. 
</details>

<details>
    <summary> 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?</summary>

- REST API 서버 개발에서 트랜잭션을 자주 사용해 봄.
  - 특히 데이터를 변경하는 요청 (POST, PUT/PATCH, DELETE) 처리 시, 여러 DB 연산을 하나의 논리적 단위로 묶기 위해 트랜잭션을 적용
  - 예) 회원 가입, 결제 처리, 게시글 추가 등.
  - 하지만 대량 데이터 업데이트나 외부 API 호출을 포함한 로직이라면 락 유지 시간이 길어져 성능 저하가 발생할 수 있으므로, 트랜잭션을 최소한으로 명확하게 유지하는 것이 좋음 
</details>

<details>
    <summary> 읽기에는 트랜잭션을 걸지 않아도 될까요?</summary>

- 기본적으로 단순 조회만 수행하는 읽기 작업은 트랜잭션이 반드시 필요하지 않을 수 있음.
- **트랜잭션이 필요하지 않은 읽기 작업**
  - 단순 조회, 캐싱되어도 문제 없는 데이터
  - 데이터의 실시간 정확성이 중요하지 않은 경우
- **트랜잭션이 필요한 읽기 작업**
  - 조회(읽기) 중 데이터의 실시간 정확성이 중요한 경우
  - 비즈니스 로직 중 읽기와 쓰기가 연속적으로 일어나는 경우 등 
</details>


## 4. 트랜잭션 격리 레벨에 대해 설명해 주세요.

<details>
    <summary> 트랜잭션 격리 레벨에 대해 설명해 주세요.</summary>

- 트랜잭션 격리 레벨
  - 여러 트랜잭션이 동시에 실행될 때, 서로의 변경 내용을 얼마나 차단할 것인가를 정의하는 기준
  - 격리 수준이 높을수록 일관성은 강해지지만 동시성(성능)은 낮아짐.
- 트랜잭션의 동시성 문제
  - Dirty Read (더티 리드): 다른 트랜잭션이 아직 커밋하지 않은 데이터를 읽는 현상
  - Non-Repeatable Read (반복 불가능한 읽기): 한 트랜잭션 내에서 같은 쿼리를 두 번 실행했을 때 결과가 달라지는 현상
  - Phantom Read (팬텀 리드): 한 트랜잭션 내에서 같은 조건으로 두 번 조회했을 때, 새로운 행이 추가되거나 사라지는 현상
- 트랜잭션의 격리 수준

  | 격리 수준 (Isolation Level)           | Dirty Read | Non-Repeatable Read | Phantom Read | 특징                               | 비고                   |
  | --------------------------------- | ---------- | ------------------- | ------------ |----------------------------------| -------------------- |
  | **READ UNCOMMITTED** (커밋되지 않은 읽기) | O  | O | O | 다른 트랜잭션의 미커밋 데이터까지 읽음            | 가장 낮은 격리 수준, 거의 사용 X |
  | **READ COMMITTED** (커밋된 읽기)       | X  | O   | O | 커밋된 데이터만 읽음                      | 대부분의 실무에서 사용         |
  | **REPEATABLE READ** (반복 가능한 읽기)   | X  |  X | O | 한 트랜잭션 내에서는 같은 행을 반복 조회해도 동일한 결과 | MySQL(InnoDB) 기본값    |
  | **SERIALIZABLE** (직렬화)            | X |  X  |  X | 트랜잭션을 순차적으로 실행한 것과 동일한 결과 보장     | 동시성↓, 완전한 격리 수준      |
    - MySQL(InnoDB)는 기본 격리 수준으로 REPEATABLE READ
    - PostgreSQL, Oracle, SQL Server는 READ COMMITTED 사용 
    - 격리 수준은 DBMS 설정이나 세션, 트랜잭션 단위로 변경할 수 있음 
- 📌 **READ COMMITTED vs REPEATABLE READ의 실제 동작 차이 (MVCC 관점)**
  - MVCC: 
    - 동시성 제어를 위해 데이터의 여러 버전을 관리하는 방식
    - DB는 데이터에 대해 변경이 일어날 때마다 새로운 버전(snapshot)을 만들어 저장, 각 트랜잭션은 자신이 시작한 시점의 버전을 ㅇ릭음
  - READ COMMITTED: 
    - 매 쿼리마다 최신 커밋 데이터를 읽음
    - 각 쿼리 실행 시점의 최신 커밋 버전의 스냅샷을 읽음, 비교적 빠르고 동시성 높음 
  - REPEATABLE READ: 트랜잭션 시작 시점의 “스냅샷” 데이터를 계속 읽음
    - 트랜잭션 시작 시점의 스냅샷(버전)을 읽음
    - 같은 트랜잭션 내에서는 항상 동일한 결과, 일관성이 강함 
</details>

<details>
    <summary> 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?</summary>

- 모든 DBMS가 4개의 레벨을 모두 구현하고 있지는 않음.
- 이유: DBMS마다 채택한 동시성 제어 방식(MVCC)과 성능 목표, 사용 목적이 다르기 때문
  - MVCC 기반 DB(PostgreSQL, Oracle) 등은 Dirty Read 자체가 구조적으로 불가능하므로, READ UNCOMMITTED를 구현할 필요 없음
  - 또한, REPEATABLE READ 대신 Snapshot Isolation (스냅샷 격리) 개념을 사용, 트랜잭션 시작 시점의 데이터를 스냅샷으로 읽는 방법 → READ COMMITTED보다 강한 자체 확장된 MVCC 스냅샷 격리
- DBMS가 구현하는 트랜잭션 격리 레벨 예시)
  - MySQL (InnoDB), SQL Server: 표준 4개의 격리 수준 모두 구현
  - PostgreSQL: 상위 3개의 격리 수준만 구현
  - Oracle: 자체 MVCC 기반 READ COMMITTED와 SERIALIZABLE만 지원
</details>

<details>
    <summary> 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.</summary>

- **Redo Log**
  - Redo 영역의 역할: 트랜잭션의 지속성(Durability) 보장, 이미 커밋된 변경사항을 장애 발생 후 재반영(복구) 하기 위한 로그
  - 동작 방식: 
    - ![img.png](./img/hy2.png)
    - Redo Log 버퍼에 무엇을 변경했는지를 기록한 뒤 순차적으로 로그 파일에 flush (WAL)
  - 이후 시스템 장애가 나더라도, 디스크에 Redo Log가 남아있으면 → DB 재시작 시 해당 로그를 읽어 변경사항을 다시 반영(redo) 
  - Redo Log 기본 요소: Log Buffer, Log File
    - Redo Log Buffer: Redo Log 작성 전에 변경정보가 먼저 저장되는 메모리 영역
    - Redo Log File: 데이터 변경 정보를 저장하는 디스크에 생성되는 파일, 이를 바탕으로 Crash Recovery 진행
- **Undo Log**
  - Undo 영역의 역할: 트랜잭션의 원자성(Atomicity) 보장, 아직 커밋되지 않은 변경사항을 되돌리기 위해 필요한 로그
  - 동작 방식: InnoDB는 데이터 변경 시, 변경 전을 Undo 로그에 먼저 기록하고 트랜잭션이 롤백되면 Undo를 이용해 이전 상태로 복원
  - MVCC 스냅샷 읽기에도 사용: 아직 커밋되지 않은 트랜잭션이 있을 때, 다른 트랜잭션이 데이터를 읽으면 Undo 영역을 참조하여 이전 버전(스냅샷)을 읽음
- 📌 InnoDB가 따르는 STEAL/NO-FORCE 정책
  - STEAL: 커밋 전에도 버퍼의 페이지가 디스크에 기록될 수 있음 (Undo 필요)
  - NO-FORCE: 커밋 시점에 바로 디스크에 쓰지 않을 수 있음 (Redo 필요)
- 📌 **MTR(Mini-Transaction)**
  - InnoDB 내부에서 페이지 단위로 수행되는 아주 작은 원자적 작업 단위(atomic operation), 물리적인 데이터 페이지를 안전하게 갱신하기 위한 최소 단위
    - 트랜잭션: SQL 수준의 논리적 작업 단위
  - MTR을 사용하는 이유:
    - InnoDB는 하나의 SQL 트랜잭션이 여러 데이터 페이지(page)를 수정할 수 있음
    - SQL 트랜잭션 단위로 Lock을 걸기에는 비효율적인 경우, MTR이라는 작은 내부 트랜잭션을 활용해 페이지 단위 원자성 보장
    - Redo Log 작업의 최소 단위, 실제 동작하는 I/O의 최소 단위 
</details>

<details>
    <summary> 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?</summary>

- 스토리지 엔진(Storage Engine)
  - 역할: DBMS 내부에서 실제 데이터 저장, 읽기, 수정, 복구하는 역할을 담당하는 모듈
  - SQL 엔진이 쿼리를 해석하면 스토리지 엔진이 인덱스 접근, 트랜잭션, 로그 관리 등 실제 문리 작업을 수행
  - InnoDB: ACID 트랜잭션, MVCC, 복구 기능, Row-level Locking 지원 등을 지원해 대표적으로 사용 
- 예시) MySQL의 구조
  - SQL Layer: 
    - SQL 해석, 최적화, 실행 결정
    - SQL Parser, Optimizer, Query Executor, Caching Security, ACL 등
  - Storage Engine Layer: 
    - 실제 데이터 저장·검색·트랜잭션 처리를 수행하는 계층
    - InnoDB, MyISAM, Memory, NDB 등 여러 엔진 중 선택할 수 있음
</details>

## 5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.

<details>
    <summary> 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.</summary>

- 인덱스: 
  - 데이터베이스에서 검색 속도를 높이기 위해 사용하는 자료구조 
  - 특정 컬럼에 대해 별도의 정렬된 구조(B-Tree, Hash 등)을 만들어 원하는 데이터를 빠르게 찾을 수 있음
- 인덱스를 사용하는 경우:
  - WHERE, JOIN, ORDER BY, GROUP BY 절에서 자주 사용되는 컬럼
  - 이터 검색 빈도가 높고, 수정·삽입·삭제가 적은 테이블일 때
- **인덱스의 종류**
  - B-Tree 인덱스
    - 가장 일반적으로 사용되는 인덱스 종류
    - 데이터베이스에서 기본적으로 제공되며, 이진 트리의 변형인 B-트리 구조를 사용하여 데이터를 저장하고 검색
    - 데이터의 정렬 순서를 유지, 범위 검색과 정렬된 결과 반환에 효율적
  - Hash 인덱스
    - 해시 함수를 사용하여 데이터를 저장하고 검색
    - 일치 검색에 효율적이지만, 범위 검색이나 정렬된 결과 반환에는 적합하지 않을 수 있음
  - 클러스터형 인덱스(Clustered Index)
    - 테이블의 데이터를 인덱스의 순서에 따라 물리적으로 정렬
    - 데이터의 논리적인 순서와 물리적인 저장 순서를 일치, 범위 검색 및 정렬된 결과 반환에 효율적
    - 하나의 테이블에는 하나의 클러스터드 인덱스만 생성 가능 
  - 비클러스터형 인덱스(Non-Clustered Index)
    - 테이블의 데이터를 인덱스의 순서에 따라 물리적으로 정렬하지 않음
    - 테이블의 열이나 열의 조합에 대한 별도의 데이터 구조를 생성하며, 데이터의 위치를 가리키는 포인터를 포함
</details>

<details>
    <summary> 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?</summary>

- 인덱스는 데이터 변경 시마다 함게 갱신되는 구조
- 쓰기(INSERT, UPDATE, DELETE) 작업이 잦은 테이블에 인덱스가 많으면 오히려 성능이 저하될 수 있음
  - 데이터 변경 시 인덱스 역시 수정해야 함: 추가/삭제/변경 시 인덱스 변경 필요
  - 쓰기 연산 오버헤드 증가: 인덱스 갱신 비용으로 인한 오버헤드
  - 디스크 I/O 증가: 인덱스는 별도의 공간을 차지함 
</details>

<details>
    <summary> 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?</summary>

- 인덱스에서 사용하지 않겠다고 선택된 값: 인덱스 갱신 비용이 발생하지 않으므로 성능 저하되지 않음
  - 인덱스에 포함된 컬럼 → 수정 시 인덱스도 함께 갱신 (쓰기 비용 증가)
  - 인덱스에 포함되지 않은 컬럼 → 단순히 데이터만 변경 (쓰기 비용 증가 없음)
</details>

<details>
    <summary> ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.</summary>

- **인덱스가 있는 경우 ORDER BY/GROUP BY 연산**:
  - 인덱스는 이미 정렬된 구조(B-Tree)를 가지고 있음
  - ORDER BY 연산 시 별도의 정렬 연산을 수행할 필요 없이 순차적으로 탐색 가능
  - GROUP BY 연산 시 정렬된 순서대로 그룹화가 가능하므로 정렬 생략 가능
- **인덱스가 없는 경우**:
  - DB는 데이터를 전부 탐색한 뒤 임시 메모리나 디스크 공간에서 직접 정렬을 수행
  - ORDER BY/GROUP BY 연산 시 테이블 전체 스캔+정렬을 수행하므로 성능 저하 발생
  - CPU 및 I/O 부하 증가, 연산 속도가 느려질 수 있음
</details>

<details>
    <summary> 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?</summary>

- 기본키(PK) == 인덱스는 아니지만, 기본키를 생성하면 자동으로 Unique Index가 생성됨
- 기본키와 인덱스의 차이
  - 기본키(PK)는 중복 불가능, NOT NULL
  - 인덱스는 중복 가능(Unique INDEX 제외), NULL값 가능 
  - 기본키는 테이블당 1개, 인덱스는 여러 개 생성 가능 
</details>

<details>
    <summary> 그렇다면 외래키는요?</summary>

- 외래키(FK)는 인덱스가 아니며, 외래키 지정 시에 인덱스가 자동으로 지정되지 않음
- 외래키로 지정된 컬럼에 인덱스를 추가하는 것을 권장
  - 부모 테이블의 변경 검사 시 효율성이 향상됨: 부모 테이블에서 데이터 삭제 시 자식 테이블의 외래키 참조 여부 확인 
  - JOIN 성능 향상: 외래키 컬럼은 JOIN 조건으로 자주 사용되기 때문
</details>

<details>
    <summary> 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?</summary>

- **클러스터형 인덱스(Clustered Index)의 경우**
  - 데이터의 물리적 저장 순서와 인덱스 순서가 동일
  - MySQL(InnoDB): 기본키(PK)를 자동으로 클러스터형 인덱스로 사용 
- **비클러스터형 인덱스(Non-Clustered Index)의 경우**
  - 인덱스는 별도의 구조(B-Tree) 로 관리, 실제 데이터는 물리적으로 별도의 위치
  - 인덱스 노드에는 데이터의 위치인 퐁인터만 저장되므로, 데이터의 물리적 저장 순서와 인덱스 순서가 동일하지 않음 
</details>

<details>
    <summary> 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?</summary>

- NoSQL(Redis, MongoDB)도 인덱스를 가지고 있음 
  - RDB의 인덱스와는 달리, 데이터 구조와 접근 패턴에 맞게 설계된 다양한 형태의 인덱스를 사용 
- 예) MongoDB (Document)
  - B-Tree 기반의 인덱스 사용, RDB와 유사
  - 하나의 쿼리에 하나의 인덱스만 사용 가능, 두 개 이상의 index 가 필요하다면 복합 index를 사용
  - 복합 인덱스, 텍스트 인덱스 등 다양한 형태 지원
- 예) Redis (key-value)
  - 메모리 내 자료구조 기반의 검색 수행
  - 키(key) 자체가 인덱스 역할을 하기도 함
  - 특정 키(@Id) 외에 다른 필드에 대한 인덱스인 보조 인덱스, 정렬된 세트(Sorted Set) 등 사용 
</details>

<details>
    <summary> (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?</summary>

- 인덱스를 타지 않음
  - 복합 인덱스 (A, B)는 왼쪽부터 순차적으로 사용하는 왼쪽 법칙(`Leftmost Prefix Rule`)을 따르기 때문
  - A 조건이 있어야 B 인덱스까지 활용 가능
  - 복합 인덱스는 데이터를 정렬할 때, 인덱스에 포함된 컬럼 순서대로 트리 구조를 이루기 때문 
    - B-Tree 인덱스는 첫 번째 컬럼을 기준으로 정렬, 첫 번째 컬럼이 같은 값들은 두 번째 컬럼을 기준으로 정렬
    - 따라서 첫 번째 컬럼 없이 두 번째나 세 번째 컬럼만으로는 효율적인 검색이 불가능
</details>

## 6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.

<details>
    <summary> RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.</summary>

- `클러스터링 (Clustering)`
  - 데이터베이스 서버들을 서로 연결해 하나의 논리적 서버처럼 사용해 고가용성과 부하 분산을 실현하는 구조
  - **RDBMS에서의 클러스터링**
    - 주로 Active-Active 또는 Active-Passive 방식으로 노드 간 요청을 분산 처리
      - Active-Active: DB 서버를 동시에 동작 가능
      - Active-Passive(Standby): 실제 가동하는 것만 Active, 나머지는 대기(Standby) 상태
    - Shared-Nothing 구조 또는 Shared-Disk 구조를 사용
        - Shared-Nothing(샤딩): 자원 분리, 서버와 저장소를 세트로 묶어 사용해 병목을 방지하고 성능 형성 가능, 정합성 문제 발생 
        - Shared-Disk: 여러 대의 서버가 1대의 저장소를 사용하는 구성, 서버 개수가 증가할수록 정보 공유를 위한 오버헤드 발생
    - SQL 레벨에서 트랜잭션 일관성을 유지하며, 모든 노드가 동일한 스키마를 공유
    - 예) MySQL InnoDB Cluster, PostgreSQL Patroni, Oracle RAC 등
  - **NoSQL에서의 클러스터링**
    - 분산 클러스터 구조를 기본적으로 채택: NoSQL은 수평 확장성(Scalability) 과 고가용성(High Availability) 을 목표로 설계됨
    - 데이터 샤딩(Sharding)을 기반으로 데이터 분산 저장, 각 노드는 특정 데이터 범위(Shared Key)에 대한 책임
      - 샤딩(Sharding): 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장
    - 예) MongoDB Sharded Cluster, Redis Cluster 등
- `레플리케이션 (Replication)`
  - 데이터의 변경 사항을 다른 서버(Replica)에 동일하게 복제하여 데이터 일관성과 가용성을 보장하는 기술
  - 읽기 부하 분산(read scalability) 및 장애 복구(failover) 목적에서 사용
  - **RDBMS에서의 레플리케이션**
    - 일반적으로 Master–Slave (Primary–Replica) 구조로 동작
      - Master (Primary): 모든 쓰기(INSERT/UPDATE/DELETE) 작업 수행
      - Slave (Replica): Master의 변경 로그를 전달받아 읽기(SELECT) 요청 처리
    - 복제 매커니즘
      - 트랜잭션 로그 기반 동작(binlog, WAL 등) 
      - MySQL: Binary Log(binlog) 를 기반으로 Slave가 Relay Log로 받아 재적용 
      - PostgreSQL: Write-Ahead Log (WAL) 복제를 통해 트랜잭션 로그를 전달 
      - Oracle: Data Guard 등 전용 동기화 엔진을 사용해 고가용성 구성
  - **NoSQL에서의 레플리케이션**
    - 레플리케이션 매커니즘
      - Document, Key 단위로 복제 
      - MongoDB: Replica Set 구조 사용, 하나의 Primary 노드와 다수의 Secondary 노드 구성, 비동기 복제
      - Redis: Master–Replica 구조로 데이터 복제, 데이터 슬롯(Hash Slot)을 기준으로 노드 간 복제
</details>

<details>
    <summary> 이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?</summary>

- 2단계 커밋(2PC, Two-Phase Commit) 프로토콜
  - 1단계(Prepare): Coordinator가 각 노드에 트랜잭션 수행 가능 여부를 질의
  - 2단계(Commit): 모든 노드가 ‘OK’를 응답하면 커밋, 하나라도 실패하면 전체 롤백
  - 일관성 보장 가능, 가용성과 확장성이 낮음
- 사가 패턴(Saga Pattern) 사용
  - 마이크로서비스 아키텍처(MSA)나 비동기 메시지 기반 시스템에서 자주 사용하는 패턴
  - 여러 서비스(또는 DB 트랜잭션)에 걸친 작업을 2PC 없이 일관성 있게 처리하기 위한 분산 트랜잭션 관리 방식
  - 작동 원리: 각 서비스는 자신의 DB 내에서만 트랜잭션을 수행 → 모든 서비스가 순서대로 작업을 수행, 중간에 실패하면 이전 단계들의 변경을 보상 트랜잭션(Undo Logic) 으로 복구
  - 최종적 일관성(Eventual Consistency) 보장, 개별 서비스 장애에 유연
</details>

<details>
    <summary> 마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?</summary>

- Master-Slave 구조
    - Master: 쓰기(Write), 업데이트, 삭제를 담당
    - Slave(Replica): 읽기(Read) 전용, Master의 데이터를 복제 (비동기 복제 일반적)
    - 복제가 실시간이 아니라면 데이터 불일치가 발생할 수 있고, 이러한 현상을 복제 지연이라고 함.
- 데이터 동기화 전까지 데이터 정합성을 지키는 방법
    - 비동기 복제방식 (Async Replication)
        - Master가 commit 후 Slave로 binlog 전송 (Slave 응답 기다리지 않음)
        - 속도가 빠름, 복제 지연이 발생할 수 있음
        - Master 장애 시 Slave가 아직 못 받은 로그 유실 가능
    - 반동기 복제방식 (Semi-Sync Replication)
        - Master가 commit 시, 적어도 한 Slave의 ACK 수신 후 완료
        - Master 장애 시 ACK 받은 Slave가 최신 상태를 가지므로 데이터 손실 최소화
        - 성능은 비동기보다 느리지만, 데이터 정합성 측면에서 안정적
        - MySQL 5.5부터 공식 지원 (rpl_semi_sync_master_enabled 옵션)
    - 세션/캐시 기반의 Read-After-Write 처리:
        - 사용자가 데이터를 쓴 세션(혹은 요청 흐름)에서는 일정 시간 동안 Master로부터만 조회하도록 처리
</details>

<details>
    <summary> 다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.</summary>

- Deadlock 현상:
    - 두 개 이상의 트랜잭션이 서로가 보유한 자원의 락(lock)을 기다리며 무한 대기 상태에 빠지는 현상
    - 예) T1은 자원 A를 잠그고 자원 B를 기다리고, T2는 자원 B를 잠그고 자원 A를 기다리는 경우 발생
- DeadLock이 발생하는 조건
    - 상호 배제(Multual Exclusion) : 자원은 한 번에 하나의 프로세스만 사용할 수 있음
    - 점유와 대기(Hold and Wait) : 최소한 하나의 프로세스가 하나의 자원을 점유하고 있으며, 추가적인 자원을 요청하면서 대기
    - 비선점(No Preemption) : 자원이 선점될 수 없다. 즉, 프로세스가 자원을 자발적으로 놓지 않는 한, 다른 프로세스가 그 자원을 강제로 가져갈 수 없음
    - 순환 대기(Circular Wait) : 두 개 이상의 프로세스가 원형으로 자원을 대기
- Deadlock 해결 전략:
    - 트랜잭션의 순서화: 트랜잭션을 실행하는 순서를 일관되게 유지, 교착 상태의 가능성을 줄임
    - 락의 범위 최소화: 트랜잭션에서 필요한 자원에 대해서만 락을 설정
    - 락 타임아웃 설정: 트랜잭션이 락을 대기하는 시간을 제한하여 시스템이 무한히 대기하는 상황을 방지
    - 짧은 트랜잭션 유지: 커밋(commit)을 빠르게 수행하여 다른 트랜잭션이 Lock을 기다리는 시간을 단축
    - 트랜잭션 격리 수준 조정: 너무 높은 격리 수준은 불필요한 락 범위를 증가시켜 Deadlock 위험 증가
</details>

<details>
    <summary> 샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?</summary>

- 샤딩(Sharding):
    - 하나의 데이터베이스를 여러 개의 작은 데이터베이스(Shard)로 나누어 분산 저장하는 방식
    - 데이터를 수평 분할(Horizontal Partitioning) 하여 각 샤드가 전체 데이터의 일부만 담당하도록 구성
- 레플리케이션(Replication)과 샤딩 방식의 차이
- 
  | 구분     | 샤딩 (Sharding)           | 레플리케이션 (Replication)                    |
  | ------ | ----------------------- | --------------------------------------- |
  | 목적     | **데이터 분산** (부하 분산, 확장성) | **데이터 복제** (고가용성, 백업)                   |
  | 데이터 구조 | 샤드마다 서로 다른 데이터 저장       | 모든 노드가 동일한 데이터 보유                       |
  | 트래픽 분산 | 수평 확장 (쓰기/읽기 분산 가능)     | 주로 읽기 부하 분산(Read Scaling)               |
  | 장애 대응  | 특정 샤드 장애 시 해당 범위만 영향    | Master 장애 시 Replica로 Failover 가능        |
  | 예시     | MongoDB Sharded Cluster | MySQL Master–Slave, MongoDB Replica Set |

</details>


## 7. 정규화가 무엇인가요?

<details>
  <summary> 정규화가 무엇인가요?</summary>

- 정규화란: 
  - 데이터베이스에서 데이터 중복을 최소화하고 데이터 무결성을 높이기 위해 테이블을 분해하는 과정
- 정규화의 목적
  - 데이터의 중복을 없애면서 불필요한 데이터 최소화
  - 무결성을 지키고, 이상 현상을 방지
  - 데이터베이스 구조 확장을 용이하게 하기 위해서
- 정규화의 장단점
  - 장점: 데이터베이스 변경 시 발생하는 이상현상을 해결할 수 있고, 구조 확장 시 정규화된 데이터베이스는 구조 변경하지 않거나 일부만 변경 가능
  - 단점: 릴레이션 분해로 인한 JOIN 연산이 많아져 질의에 대한 응답시간이 느려질 수 있음
</details>

<details>
  <summary> 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.</summary>

**데이터베이스 이상현상**
- `삽입 이상`
  - 불필요한 데이터를 추가해야만 삽입이 가능한 상황
- `갱신 이상`
  - 전체의 데이터 중 일부만 변경하여 데이터가 불일치하는 상황
- `삭제 이상`
  - 삭제로 인해 반드시 필요한 데이터까지 삭제되는 상황
</details>

<details>
  <summary> 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.</summary>

**데이터베이스 정규화**
- `제 1정규화(1NF)`
  - 테이블 컬럼이 하나의 값을 갖도록 테이블을 분리 (모든 도메인이 원자값만 포함)
- `제 2정규화(2NF)`
    - 모든 컬럼이 완전 함수적 종속을 만족하도록 분리
    - 완전 함수적 종속: 부분 함수적 종속을 제거
        - 함수적 종속: 어떤 속성 X가 Y를 결정할 때, X → Y 라고 표현.
        - 부분 함수적 종속: X의 일부 속성만으로도 Y를 결정할 수 있는 경우 (기본키의 부분집합 키가 결정자인 경우)
- `제 3정규화(3NF)`
    - 이행적 종속을 제거하기 위해 테이블을 분리
        - 이행적 종속: A → B, B → C면 A → C가 성립
- `BCNF`
    - 값을 정하는 모든 결정자가 후보키 집합에 속하도록 테이블을 분리
</details>

<details>
  <summary> 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.</summary>

- 정규화의 단점: 릴레이션 간의 JOIN 연산이 늘어나 질의 성능이 저하될 수 있음
- 반정규화(역정규화):
  - 데이터베이스 성능 향상을 위해 정규화된 모델을 의도적으로 위배하여 데이터 중복, 통합, 분리를 수행하는 기법
  - 주로 JOIN 연산을 줄여 데이터 조회 속도 및 성능을 향상시키기 위해 사용 
  - 읽기 작업이 많은 경우, 대량 데이터를 자주 처리해 성능 이슈가 발생하는 경우 등 사용 
</details>

## 8. View가 무엇이고, 언제 사용할 수 있나요?

<details>
  <summary> View가 무엇이고, 언제 사용할 수 있나요?</summary>

- View(뷰):
  - 데이터베이스에서 하나 이상의 테이블을 기반으로 만들어진 가상 테이블
  - 실제 데이터를 저장하지 않고, SELECT 쿼리 결과를 마치 테이블처럼 보여주는 객체
- View의 특징
  - 가상 테이블로, 물리적으로 구현되어 있지 않은 테이블
  - 복잡한 쿼리를 단순화해 재사용 가능, 관리가 용이함 
  - 여러 테이블을 조합한 결과를 하나의 테이블처럼 다룰 수 있음
  - 특정 컬럼만 노출 가능하므로 데이터를 안전하게 보호할 수 있음, 보안 강화 
  - 하나의 뷰를 삭제하면 그 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제됨
- View의 장단점
  - 장점
    - 논리적 데이터 독립성을 제공
    - 사용자의 데이터 관리 편리성 제공 
  - 단점
    - 독립적인 인덱스를 가질 수 없음
    - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약 존재 
</details>

<details>
  <summary> 그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?</summary>

- 일부 제약 조건을 충족하는 단순 뷰의 경우 직접 반영
  - 단일 테이블 기반 
  - 집계 함수, GROUP BY, DISTINCT, JOIN, 서브쿼리 등이 포함되지 않은 경우
- 반영되지 않는 경우
  - 여러 테이블을 조합(JOIN)하거나, 집계/계산/서브쿼리/중복제거 등이 포함된 View의 경우 
</details>


## 9. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.

<details>
  <summary> DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.</summary>

- DB Join이란?
  - 두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법

**JOIN 종류**
![hy3.png](./img/hy3.png)
- `INNER JOIN(NATURAL JOIN)`
  - 교집합(A ∩ B) 연산과 동일
  - 양쪽 테이블 데이터 집합에 공통적으로 존재하는 데이터만 결과 데이터 집합으로 추출
- `LEFT OUTER JOIN`
  - 교집합과 차집합 연산의 합((A ∩ B) ∪ (A - B))과 동일
  - 왼쪽(기준) 테이블의 모든 행과 오른쪽 테이블의 일치 데이터를 포함해 결과로 추출
- `RIGHT OUTER JOIN`
  - 교집합과 차집합 연산의 합((A ∩ B) ∪ (B - A))과 동일
  - 오른쪽(기준) 테이블의 모든 행과 왼쪽 테이블의 일치 데이터를 포함해 결과로 추출
- `FULL OUTER JOIN`
  - 합집합 연산(A ∪ B) 결과와 동일 
  - 양쪽 테이블의 모든 행을 합쳐서 결과로 추출
- `CROSS JOIN`
  - 곱집합 연산(A × B) 결과와 동일 
  - 두 테이블의 모든 행을 Cartesian Product 형태로 결합해 결과로 추출
- `SELF JOIN`
  - 같은 테이블을 자기 자신과 조인하는 방법 
  - 테이블의 서로 다른 별칭을 사용해 서로 다른 것처럼 사용
</details>

<details>
  <summary>  사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.</summary>

**JOIN 구현 알고리즘 종류**
- `중첩 루프 조인(Nested-loop Join)`
  - 가장 단순한 조인 방식
  - 릴레이션의 모든 튜플에 대해 모든 조합을 검사하는 방식
  - 이중 반복문을 돌면서 한쪽 테이블(A) 의 각 행마다 다른 테이블(B) 을 반복 탐색하며 조건을 비교
  - 장점: 모든 레코드를 비교하기 때문에 어떤 조인 조건이든 사용할 수 있음
  - 단점: 테이블의 크기가 클 경우 시간 복잡도 O(M×N)으로 매우 느리고, 비용이 큼
  - 개선 방법
    - Block Nested-loop Join: 
      - 외부 테이블의 모든 레코드가 아닌 블록에 대해서 내부 테이블을 비교하는 방법
      - 레코드당 I/O가 아닌, 블록당 I/O가 발생하므로 보다 적은 비용으로 작업 처리 가능
    - Indexed Nested-loop Join
      - 내부 테이블(B)에 인덱스가 있으면 반복 검색 속도를 대폭 개선
- `정렬 병합 조인(Sort-Merge Join)`
  - 두 테이블(A, B)을 조인 키 기준으로 정렬 → 두 정렬된 결과를 병합(Merge) 하며 매칭되는 행을 찾아냄
  - 장점: 정렬된 데이터에서는 매우 빠름, 등가(=)뿐만 아니라 범위 조인(>, <)도 가능
  - 단점: 정렬 비용이 발생할 수 있음, 대용량 데이터는 디스크 I/O 비용이 큼
    - 정렬 알고리즘은 External Sorting(외부 정렬)을 사용
    - *External Sorting: 대용량 데이터를 정렬할 때, 디스크(보조기억장치) 를 활용해서 정렬하는 방법
- `해시 조인(Hash Join)`
  - 작은 테이블(A)을 기준으로 해시 테이블을 메모리에 생성 → 큰 테이블(B)을 순회하며 해시 키로 빠르게 일치 여부 확인
  - 모든 블록을 읽어서 파티션을 나눈 뒤 디스크에 쓰고 다시 모든 파티션을 읽어서 조인하는 알고리즘
  - 장점: 대용량 테이블 조인에 적합, 정렬 불필요, 등가 조건(=)에 최적화
  - 단점: 메모리 사용량 많음, 범위 조인(>, <) 불가
</details>

<details>
  <summary>  그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?</summary>

- DBMS의 실행 계획(Execution Plan)을 통해 확인 가능 
  - MySQL 기준, 실행하려는 쿼리 앞에 `EXPLAIN`을 추가하면 어떤 조인 알고리즘을 사용하는지 확인할 수 있음
  - `EXPLAIN ANALYZE`을 추가하면 실제 실행 시간, I/O 비용, 행 수 등의 정보 역시 확인 가능 
</details>

<details>
  <summary> 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?</summary>

- SQL 옵티마이저가 데이터의 크기, 결합키(Key), 인덱스(Index), 정렬 상태 등에 따라 알고리즘을 결정
  - 옵티마이저 (Optimizer): SQL 쿼리를 실행했을 때 해당 쿼리를 전달받아 조건을 고려해 실행계획을 작성하고, 각 선택지의 비용을 연산하여 가장 낮은 비용을 가진 실행 계획을 선택
- Nested Loop Join: 
  - 인덱스의 영향을 받으므로, 인덱스 구성 전략이 중요함
- Sort-Merge Join:
  - 조인 컬럼에 인덱스가 있으면 정렬(Sort) 단계를 생략해 효율을 높일 수 있음.
  - Sort-Merge Join은 정렬된 두 테이블을 병합하는 과정(Merge) 에서 대부분의 비용이 발생하므로, 큰 영향이 있지 않음
- Hash Join: 
  - Hash Join은 인덱스를 직접 사용하지 않고, 작은 테이블을 기준으로 메모리 내 해시 테이블을 생성
  - 이 해시 테이블이 일시적으로 인덱스처럼 작동하므로 인덱스 유무의 영향은 거의 없음
  - 인덱스가 없어도 빠른 조인이 가능하지만, 인덱스 통계 정보(카디널리티, 분포 등)는 옵티마이저의 비용 계산에 참고될 수 있음 
</details>

<details>
  <summary> 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.</summary>

- 3중 조인의 주요 동작 방식
  - 단계적 조인: 두 테이블씩 순차적으로 조인을 수행하므로 중간 결과(Intermediate Result)가 발생함 
  - 옵티마이저는 중간 결과의 크기가 가장 작은 조인 순서를 선택하여 실행
- 성능에 영향을 주는 요인
  - 조인 순서: 디스크 I/O, 메모리 사용량, 정렬 비용 최소화하기 위해 가장 중요한 성능 요인
  - 조인 알고리즘, 인덱스, 통계정보 등도 성능에 영향을 줌
  - 옵티마이저는 가능한 모든 조합의 비용을 계산해 최적의 순서·방식을 선택 
</details>


## 10. B-Tree와 B+Tree에 대해 설명해 주세요.

<details>
  <summary> B-Tree와 B+Tree에 대해 설명해 주세요.</summary>

**B-Tree**
![hy4.png](./img/hy4.png)
- 균형 이진 탐색 트리(Balanced Search Tree)의 확장 구조 
  - 이진 트리와의 차이점: 
    - 하나의 노드는 2개 이상의 데이터를 가질 수 있음
    - 자식 노드를 여러 개 가질 수 있음
    - INSERT, DELETE와 같은 작업이 일어나도 항상 균형을 유지하도록 구성되어 있음
- B-Tree 구조 규칙
  - B-Tree 구성 요소
    - Root Node: 탐색 시작점
    - Branch Node: 자식 노드로 분기하는 중간 노드
    - Leaf Node: 최하단의 노드, 실제 데이터(레코드) 위치 정보 저장
  - B-Tree 구조의 특징
    - 균형 이진 탐색 트리의 확장 구조
      - 노드가 여러 개의 키를 가질 수 있음, 자식 노드 수도 여러 개일 수 있음
      - 모든 Branch, Leaf 노드는 키, 데이터를 함께 저장 
      - 삽입(INSERT), 삭제(DELETE) 시에도 트리가 자동으로 균형 유지 → 모든 Leaf 노드들은 같은 깊이에 존재하는 balanced tree
      - 각 노드 내부의 키들은 항상 오름차순으로 정렬되어 있음 → 이진 탐색 가능 
    - 탐색·삽입·삭제의 시간 복잡도: O(log N)
    - 항상 균형을 유지하므로 탐색 성능이 일정함
  
**B+Tree**
![hy4.png](./img/hy5.png)
- B-Tree에 인덱스 역할을 추가해 최적화한 확장 구조
  - B-Tree의 균형 특성을 유지하면서, 검색·범위 탐색·순차 접근에 효율적
- B+Tree 구조 규칙
    - B-Tree 구성 요소
      - Root Node: 탐색 시작점
      - Branch Node: 자식 노드로 분기하는 중간 노드, 키(key) 값만 저장, 실제 데이터는 없음
        - 하나의 Branch 노드에 더 많은 key를 저장할 수 있게 되어서, 트리의 높이가 더 낮아짐 
      - Leaf Node: 실제 데이터(레코드) 위치 정보 저장, 리프 노드 간 연결 포인터(Linked List) 를 통해 순차 탐색 가능
    - B+Tree 구조 특징
      - B-Tree의 균형 특성 유지: 모든 리프 노드는 같은 깊이에 존재, 삽입·삭제 시 자동으로 균형 유지
      - 키 정렬 유지: 각 노드 내부의 키들은 항상 오름차순으로 정렬되어 있음, 리프 노드 간 연결로 범위 검색에 효율적
      - 검색 효율 향상
        - 내부 노드는 인덱스 역할만 하므로 더 많은 키를 메모리에 적재 가능
        - 리프 노드 간 연결로 BETWEEN, >=, <= 등의 범위 쿼리 최적화, 순차 접근 속도 향상 
          - *Full Scan 시 B-Tree는 모든 노드를 확인해야하지만, B+Tree의 경우 리프노드에 연결된 연결리스트로 선형 탐색이 가능
      - 모든 탐색은 리프 노드까지 진행
        - B-Tree는 내부 노드에서도 데이터를 찾을 수 있음
        - +Tree는 항상 리프 노드까지 내려가서 최종 데이터 접근해야 함 
</details>

<details>
  <summary> 그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?</summary>

- 인덱싱 목적에서는 더 효율적이지만, 반드시 좋다고 말할 수 없음 
  - 범위 검색, 순차 접근, 대용량 데이터 처리에는 B+Tree가 유리하지만 모든 상황에서 B-Tree보다 우위에 있지는 않음
- B+Tree의 장단점
  - 장점:
    - 범위 검색에 강함 (빠른 순차 탐색 가능)
    - 인덱스 효율적 → 내부 노드에는 키만 저장, 더 많은 키를 메모리에 적재 가능
    - 디스크 I/O 횟수 감소로 대규모 데이터 처리에 유리
  - 단점:
    - 데이터에 접근하기 위해 반드시 Leaf 노드까지 접근해야 함
    - 리프 노드 간 연결 포인터, 키 복제 등으로 추가적인 메모리·디스크 공간 사용
    - 동적 수정에 불리함: 데이터 구조가 리프 중심이기 때문 
- B-Tree가 더 유리한 경우
  - 단일 키 검색이 잦은 경우: 중간 노드에서 바로 데이터 반환 가능
  - 데이터 크기가 작고, 디스크 접근 비용이 낮은 환경
  - 내부 노드에 데이터가 포함되어 있고 수정 쿼리가 잦은 환경
</details>

<details>
  <summary> DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?</summary>

- 레드-블랙 트리(Red-Black Tree, RBT):
  - 메모리 기반(RAM) 데이터 저장
  - 노드당 key를 한 개만 가질 수 있는 구조
  - 상대적으로 트리의 깊이가 더 깊음 
  - 탐색·삽입·삭제는 빠르지만, 디스크 접근을 전제로 설계되지 않음 
- RBT 대신 B-Tree/B+Tree를 사용하는 이유:
  - RBT는 트리의 depth가 상대적으로 깊어, 특정 key의 데이터를 찾기 위해 많은 디스크 I/O 발생
  - DB는 디스크 기반 저장 구조이기 때문에, I/O 효율이 핵심 성능 요인
    - RBT의 경우 각 노드가 작아 여러 블록 접근 필요
    - B-Tree/B+Tree의 경우 하나의 디스크 블록(페이지) 안에 여러 키를 저장, 한 번의 디스크 I/O로 다수의 키 탐색 가능
</details>

<details>
  <summary> 오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.</summary>

- B-Tree/B+Tree의 특징
  - 인덱스는 트리 구조 내부에서 항상 오름차순으로 연결되어 있음 
  - 내림차순 정렬을 시도할 경우 반대 방향으로 역순 탐색(reverse traversal)이 필요한 구조
- B+Tree의 경우
  - 리프 노드 간 양방향 연결(Double-linked list) 구조이므로 역방향 탐색은 구조적으로 문제 없음
  - 하지만 리프 노드를 이루는 하나의 페이지 안의 데이터(레코드)들은 오름차순으로 정렬, 단방향 배열 형태로 저장되어 있음 (역방향 링크 존재 X)
  - 이 과정에서 역순 탐색을 위해 추가 연산이 필요하므로, 캐시 비효율(Cache Miss) 발생 가능, 성능 저하 발생 가능 
</details>

<details>
  <summary><h3>11. DB Locking에 대해 설명해 주세요.</h3></summary>
<ul>
<li> Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.</li>
<li> 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?</li>
</ul>
</details>

<details>
  <summary><h3>12. 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?</h3></summary>
<ul>
<li> DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?</li>
</ul>
</details>

<details>
  <summary><h3>13. Schema가 무엇인가요?</h3></summary>
<ul>
  <li>Schema의 3계층에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>14. DB의 Connection Pool에 대해 설명해 주세요.</h3></summary>
<ul>
  <li>DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.</h3></summary>
<ul>
  <li>가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?</li>
  <li> COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(*), COUNT(column) 의 동작 과정에는 차이가 있나요?</li>
</ul>
</details>

<details>
  <summary><h3>16. SQL Injection에 대해 설명해 주세요.</h3></summary>
<ul>
  <li>그렇다면, 우리가 서버 개발 과정에서 사용하는 수많은 DB 라이브러리들은 이 문제를 어떻게 해결할까요?</li>
</ul>
</details>