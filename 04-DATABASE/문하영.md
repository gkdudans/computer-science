# 데이터베이스

## 1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.

<details>
    <summary>Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.</summary>

- 1)슈퍼 키(Super Key)
  - 유일성 O, 최소성 X
  - 중복된 값이 존재하지 않는다.
  - 예를 들어, 유일성을 만족하는 학번을 가진 [학번 + 이름], [성별 + 학번] 등은 슈퍼키가 될 수 있다.
  - 하지만 [이름 + 성별] 은 두 가지가 모두 일치하는 사람이 존재할 수 있기 때문에 유일성 성립이 안된다.
- 2)복합 키(Composite Key)
  - 유일성 O, 최소성 O
  - 2개 이상의 속성(attribute)을 묶어서 기본키로 지정한 것이다.
- 3)후보 키(Candidate key)
  - 유일성 O, 최소성 O
  - 슈퍼키 중에서 최소성을 만족하는 키로, 기본키가 될 수 있는 후보이기 때문에 후보키라고 불린다.
  - 예를 들어, [주민등록번호], [학번] 같이 유일성을 만족하면서 최소성도 만족하면 후보키이다.
- 4)기본 키(Primary key)
  - 유일성 O, 최소성 O
  - 후보 키에서 선택된 키로, 레코드를 식별할때 기준이 되는 반드시 필요한 키이다.
  - NULL값, 중복값은 들어갈 수 없다.
- 5)대체 키(Surrogate / Alternate key)
  - 유일성 O, 최소성 O
  - 후보 키 중에 기본 키로 선택되지 않은 키이다.
- 6)외래 키(Foreign Key)
  - 테이블(relation)간의 관계를 나타낼때 사용하며, 다른 테이블의 기본키를 참조해 외래키로 사용한다.
  - 데이터 무결성을 위해 외래키를 설정한다.
  - 예를 들어, 왼쪽 테이블의 student_id 값이 변경되면 오른쪽 테이블의 student_id 도 변경되어야 한다.
</details>

<details>
    <summary>기본키는 수정이 가능한가요?</summary>

- 기본키는 논리적으로 수정 가능함 
- 단, 기본키는 한 행을 고유하게 식별하는 기준이기 때문에 이를 수정하면 관련된 외래키 관계나 다른 테이블의 데이터 무결성이 깨질 위험이 있음.
  - `ON UPDATE CASCADE`를 외래키 제약조건으로 설정하면 그 값을 참조하고 있는 테이블의 외래키 값도 함께 수정됨.
</details>

<details>
    <summary> 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?</summary>

- MySQL(InnoDB)는 반드시 한 개의 클러스터링 인덱스(clustered index)를 가져야 함. 
- **상황에 따른 InnoDB의 클러스터링 인덱스 사용**
  - PRIMARY KEY가 존재: 그 키를 클러스터형 인덱스로 사용
  - PRIMARY KEY가 없고, NOT NULL UNIQUE 인덱스가 있음: 그 중 첫 번째 인덱스를 클러스터형 인덱스로 사용
  - 위 두 경우 모두 없음: InnoDB가 숨겨진 6바이트짜리 `GEN_CLUST_INDEX`(암시적 기본 키) 를 생성
- **PK가 없는 테이블의 특징, 주의사항**
  - disk I/O 증가: GEN_CLUST_INDEX는 항상 INT 또는 BIGINT 타입의 숨겨진 열을 사용하므로, PK가 있는 테이블보다 저장 공간이 더 많이 차지할 수 있음
  - PK를 지정하지 않으면 데이터 무결성이 저하되고, PK를 지정할 때보다 성능이 저하될 수 있음
  - 사용자가 해당 암시적 기본 키를 볼 수도, 제어할 수도 없으므로 가시성 저하, 쿼리 성능 예측 어려움.
</details>

<details>
    <summary> 외래키 값은 NULL이 들어올 수 있나요?</summary>

- 가능한 이유: 외래키 제약조건(FK Constraint)에 의하면 NULL값은 '참조하지 않음'을 의미하기 때문
- 즉, 외래키 칼럼이 NOT NULL로 선언되어 있지 않다면, NULL을 허용
  - 외래키 칼럼에 NULL을 허용하는지 여부는 칼럼에 대한 정의에 따라 달라짐 
</details>

<details>
    <summary> 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?</summary>

- UNIQUE 제약조건을 설정하면 해당 컬럼에 자동으로 인덱스(index) 가 생성
  - 해당 컬럼을 이용한 검색(WHERE, JOIN, ORDER BY 등)을 훨씬 빠르게 수행할 수 있음
  - 다만 데이터 삽입/수정 시에는 인덱스 갱신이 필요하므로 쓰기 성능이 저하될 수 있음 
</details>

## 2. RDB와 NoSQL의 차이에 대해 설명해 주세요.

<details>
    <summary> RDB와 NoSQL의 차이에 대해 설명해 주세요.</summary>

- **RDB의 특징**
  - 데이터를 정해진 스키마와 테이블 기반 구로조 저장
  - 데이터 간의 관계를 외래키(Foreign Key) 로 표현
  - 대표적인 RDB: MySQL, Oracle 등
  - 정형화된 구조와 안정성 위주로 설계됨, 수직 확장, 복잡한 쿼리에 강하며 트랜잭션 ACID 보장 
- **NoSQL의 특징**
  - 정형화되지 않은(unstructured) 데이터를 관계형 모델이 아닌, 문서(document), 키-값(key-value), 그래프(graph), 컬럼(column) 등 다양한 형태로 저장
  - 대표적인 NoSQL: MongoDB (Document형), Redis, DynamoDB(Ke-Value형) 등
  - 스키마가 유연하고 수평 확장이 용이, 고가용성, 대용량 데이터와 비정형 데이터 처리에 적합함.
</details>

<details>
    <summary> NoSQL의 강점과, 약점이 무엇인가요?</summary>

- **NoSQL의 강점**
  - 수평적 확장성: 서버를 여러 대 추가하는 방식(Scale-out)으로 쉽게 확장 가능.
  - 빠른 읽기/쓰기 성능: RDB와 비교해 복잡한 연산이 적기 때문에 대용량 데이터에 비해 빠른 일긱/쓰기 처리 가능
  - 스키마의 유연성, 특정 용도에 최적화된 구조 선택 가능, 대규모 분산 저장에 유리한 고가용성
- **NoSQL의 약점**
  - 일관성 보장의 어려움: 데이터 불일치 상태가 발생하기 쉬운 구조.
  - 트랜잭션 지원이 제한적: RDB처럼 트랜잭션의 ACID를 지원하기 적음.
  - 복잡한 쿼리 처리의 어려움: 관계형 모델이 아니기 때문에 JOIN, GROUP By 등 복잡한 SQL 연산 처리는 어려움.
  - 관리 및 운영 복잡도 증가, 데이터 중복 및 관리 문제 발생 가능
</details>

<details>
    <summary> RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)</summary>

- RDB의 구조적 특징 때문
  - ACID 트랜잭션 보장: 데이터 무결성을 보장하는 핵심 기능, 데이터의 정합성을 지키기 위해 I/O와 동기화로 인한 부하 발생
  - JOIN 연산: 테이블을 읽고, 키로 조합한 후, 필요한 결과를 새로 구성해야 하는 연산으로, 데이터가 많을수록 조인으로 인한 부하가 급격히 커질 수 있음 
  - 테이블 정규화: RDB를 정규화(Normalization)할 경우 하나의 요청을 처리하기 위해 여러 테이블을 읽고 JOIN해야 함 
  - 동시성 제어를 위한 Lock: RDB는 트랜잭션 충돌을 방지하기 위해 행/테이블 단위로 Lock을 사용, 성능이 저하될 수 있음 
  - 제약 조건 검사: 삽입/수정 연산 시마다 데이터 무결성을 위한 기본키/외래키/도메인 제약조건을 검증하기 때문
  - 디스크 기반 저장 구조 사용: 버퍼 풀에 적재되지만, 디스크 기반 저장구조를 사용함 (일부 NoSQL은 메모리/분산 중심)
</details>

<details>
    <summary> NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.</summary>

- 채팅 기능(WebSocket + STOMP)을 위한 NoSQL(MongoDB)를 사용해 본 경험이 있음
  - 실시간 통신 환경에 적합한 빠른 쓰기/읽기 성능: 비정규화된 문서(Document) 구조 덕분에 메시지를 빠르게 저장하고 조회할 수 있음
  - 대용량 메시지 저장, 확장성 고려: 채팅 서버는 시간이 지날수록 데이터가 급격히 증가함, 수평적 확장을 지원하기 때문에 여러 노드로 부하 분산이 가능함.
  - 복잡한 관계가 없는 채팅 구조: 사용자-채팅방-메시지의 단순한 구조이기 때문에 JOIN 등의 복잡한 쿼리가 필요하지 않음 
</details>


## 3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.

<details>
    <summary> 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.</summary>

- 트랜잭션이란?
  - 데이터베이스에서 수행되는 하나의 논리적인 작업 단위
- **트랜잭션의 ACID 원칙**
  - 원자성 (Atomicity)
    - 트랜잭션 내 모든 작업이 모두 수행되거나 모두 수행되지 않아야 함 (All or Nothing)
  - 일관성 (Consistency)
    - 트랜잭션 수행 전후로 데이터의 무결성이 항상 유지되어야 함
  - 독립성 (Isolation)
    - 동시에 실행되는 트랜잭션들이 서로의 작업에 간섭하지 않아야 함
  - 지속성 (Durability)
    - 트랜잭션이 커밋(commit) 된 후에는, 시스템 장애가 나도 결과가 보존되어야 함
</details>

<details>
    <summary> ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?</summary>

- Write-Ahead Logging (WAL, 로그 선기록 기법): 
  - 트랜잭션이 커밋되면 그 변경 사항은 디스크에 기록되며, 시스템 장애 발생 시에도 로그를 이용해 데이터를 복구할 수 있음
  - Redo/Undo 로그: WAL 기법을 구현하기 위한 로그 종류 (WAL을 구현하는 실제 구조체)
    - Redo 로그: 커밋된 변경 사항을 복구 (Durability)
    - Undo 로그: 롤백 시 변경사항을 되돌림 (Atomicity)
  - 참고 자료
    - https://tech.kakao.com/posts/721
    - https://d2.naver.com/helloworld/407507
  - 로그를 디스크에 쓰는 과정
    - 1)트랜잭션 수행 중: 메모리의 버퍼(Buffer Pool)에서 데이터 수정, 동시에 UNDO/REDO 정보를 로그 버퍼(Log Buffer) 에 기록
    - 2)커밋 시점: 로그 버퍼의 해당 트랜잭션 로그를 디스크(Log File) 로 fsync(), 로그를 물리적으로 디스크에 기록 
    - 3)장애 발생 시: 아직 데이터 파일에는 반영되지 않았더라도 로그 파일에 기록된 REDO 로그를 이용해 다시 반영(redo)
- STEAL/FORCE 정책
  - STEAL 정책: 아직 커밋되지 않은 트랜잭션에 의해 수정된 데이터 페이지라도, 필요 시 해당 페이지를 버퍼 풀에서 디스크로 내려보내는 것(flush)을 허용
  - FORCE 정책: 트랜잭션이 커밋될 때, 해당 트랜잭션에 의해 변경된 모든 데이터 페이지를 즉시 디스크에 기록하도록 강제하는 정책
  - 대부분의 상용 DBMS는 성능상의 이유로 STEAL / NO-FORCE 정책 조합을 채택
- 체크포인트:
  - 주기적으로 로그 내용을 실제 데이터 파일에 반영
  - 이를 이용해 시스템 장애 발생 시 빠르게 복구할 수 있음. 
</details>

<details>
    <summary> 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?</summary>

- REST API 서버 개발에서 트랜잭션을 자주 사용해 봄.
  - 특히 데이터를 변경하는 요청 (POST, PUT/PATCH, DELETE) 처리 시, 여러 DB 연산을 하나의 논리적 단위로 묶기 위해 트랜잭션을 적용
  - 예) 회원 가입, 결제 처리, 게시글 추가 등.
  - 하지만 대량 데이터 업데이트나 외부 API 호출을 포함한 로직이라면 락 유지 시간이 길어져 성능 저하가 발생할 수 있으므로, 트랜잭션을 최소한으로 명확하게 유지하는 것이 좋음 
</details>

<details>
    <summary> 읽기에는 트랜잭션을 걸지 않아도 될까요?</summary>

- 기본적으로 단순 조회만 수행하는 읽기 작업은 트랜잭션이 반드시 필요하지 않을 수 있음.
- **트랜잭션이 필요하지 않은 읽기 작업**
  - 단순 조회, 캐싱되어도 문제 없는 데이터
  - 데이터의 실시간 정확성이 중요하지 않은 경우
- **트랜잭션이 필요한 읽기 작업**
  - 조회(읽기) 중 데이터의 실시간 정확성이 중요한 경우
  - 비즈니스 로직 중 읽기와 쓰기가 연속적으로 일어나는 경우 등 
</details>


## 4. 트랜잭션 격리 레벨에 대해 설명해 주세요.

<details>
    <summary> 트랜잭션 격리 레벨에 대해 설명해 주세요.</summary>

- 트랜잭션 격리 레벨
  - 여러 트랜잭션이 동시에 실행될 때, 서로의 변경 내용을 얼마나 차단할 것인가를 정의하는 기준
  - 격리 수준이 높을수록 일관성은 강해지지만 동시성(성능)은 낮아짐.
- 트랜잭션의 동시성 문제
  - Dirty Read (더티 리드): 다른 트랜잭션이 아직 커밋하지 않은 데이터를 읽는 현상
  - Non-Repeatable Read (반복 불가능한 읽기): 한 트랜잭션 내에서 같은 쿼리를 두 번 실행했을 때 결과가 달라지는 현상
  - Phantom Read (팬텀 리드): 한 트랜잭션 내에서 같은 조건으로 두 번 조회했을 때, 새로운 행이 추가되거나 사라지는 현상
- 트랜잭션의 격리 수준

  | 격리 수준 (Isolation Level)           | Dirty Read | Non-Repeatable Read | Phantom Read | 특징                               | 비고                   |
  | --------------------------------- | ---------- | ------------------- | ------------ |----------------------------------| -------------------- |
  | **READ UNCOMMITTED** (커밋되지 않은 읽기) | O  | O | O | 다른 트랜잭션의 미커밋 데이터까지 읽음            | 가장 낮은 격리 수준, 거의 사용 X |
  | **READ COMMITTED** (커밋된 읽기)       | X  | O   | O | 커밋된 데이터만 읽음                      | 대부분의 실무에서 사용         |
  | **REPEATABLE READ** (반복 가능한 읽기)   | X  |  X | O | 한 트랜잭션 내에서는 같은 행을 반복 조회해도 동일한 결과 | MySQL(InnoDB) 기본값    |
  | **SERIALIZABLE** (직렬화)            | X |  X  |  X | 트랜잭션을 순차적으로 실행한 것과 동일한 결과 보장     | 동시성↓, 완전한 격리 수준      |
    - MySQL(InnoDB)는 기본 격리 수준으로 REPEATABLE READ
    - PostgreSQL, Oracle, SQL Server는 READ COMMITTED 사용 
    - 격리 수준은 DBMS 설정이나 세션, 트랜잭션 단위로 변경할 수 있음 
- 📌 **READ COMMITTED vs REPEATABLE READ의 실제 동작 차이 (MVCC 관점)**
  - MVCC: 
    - 동시성 제어를 위해 데이터의 여러 버전을 관리하는 방식
    - DB는 데이터에 대해 변경이 일어날 때마다 새로운 버전(snapshot)을 만들어 저장, 각 트랜잭션은 자신이 시작한 시점의 버전을 ㅇ릭음
  - READ COMMITTED: 
    - 매 쿼리마다 최신 커밋 데이터를 읽음
    - 각 쿼리 실행 시점의 최신 커밋 버전의 스냅샷을 읽음, 비교적 빠르고 동시성 높음 
  - REPEATABLE READ: 트랜잭션 시작 시점의 “스냅샷” 데이터를 계속 읽음
    - 트랜잭션 시작 시점의 스냅샷(버전)을 읽음
    - 같은 트랜잭션 내에서는 항상 동일한 결과, 일관성이 강함 
</details>

<details>
    <summary> 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?</summary>

- 모든 DBMS가 4개의 레벨을 모두 구현하고 있지는 않음.
- 이유: DBMS마다 채택한 동시성 제어 방식(MVCC)과 성능 목표, 사용 목적이 다르기 때문
  - MVCC 기반 DB(PostgreSQL, Oracle) 등은 Dirty Read 자체가 구조적으로 불가능하므로, READ UNCOMMITTED를 구현할 필요 없음
  - 또한, REPEATABLE READ 대신 Snapshot Isolation (스냅샷 격리) 개념을 사용, 트랜잭션 시작 시점의 데이터를 스냅샷으로 읽는 방법 → READ COMMITTED보다 강한 자체 확장된 MVCC 스냅샷 격리
- DBMS가 구현하는 트랜잭션 격리 레벨 예시)
  - MySQL (InnoDB), SQL Server: 표준 4개의 격리 수준 모두 구현
  - PostgreSQL: 상위 3개의 격리 수준만 구현
  - Oracle: 자체 MVCC 기반 READ COMMITTED와 SERIALIZABLE만 지원
</details>

<details>
    <summary> 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.</summary>

- **Redo Log**
  - Redo 영역의 역할: 트랜잭션의 지속성(Durability) 보장, 이미 커밋된 변경사항을 장애 발생 후 재반영(복구) 하기 위한 로그
  - 동작 방식: 
    - ![img.png](./img/hy2.png)
    - Redo Log 버퍼에 무엇을 변경했는지를 기록한 뒤 순차적으로 로그 파일에 flush (WAL)
  - 이후 시스템 장애가 나더라도, 디스크에 Redo Log가 남아있으면 → DB 재시작 시 해당 로그를 읽어 변경사항을 다시 반영(redo) 
  - Redo Log 기본 요소: Log Buffer, Log File
    - Redo Log Buffer: Redo Log 작성 전에 변경정보가 먼저 저장되는 메모리 영역
    - Redo Log File: 데이터 변경 정보를 저장하는 디스크에 생성되는 파일, 이를 바탕으로 Crash Recovery 진행
- **Undo Log**
  - Undo 영역의 역할: 트랜잭션의 원자성(Atomicity) 보장, 아직 커밋되지 않은 변경사항을 되돌리기 위해 필요한 로그
  - 동작 방식: InnoDB는 데이터 변경 시, 변경 전을 Undo 로그에 먼저 기록하고 트랜잭션이 롤백되면 Undo를 이용해 이전 상태로 복원
  - MVCC 스냅샷 읽기에도 사용: 아직 커밋되지 않은 트랜잭션이 있을 때, 다른 트랜잭션이 데이터를 읽으면 Undo 영역을 참조하여 이전 버전(스냅샷)을 읽음
- 📌 InnoDB가 따르는 STEAL/NO-FORCE 정책
  - STEAL: 커밋 전에도 버퍼의 페이지가 디스크에 기록될 수 있음 (Undo 필요)
  - NO-FORCE: 커밋 시점에 바로 디스크에 쓰지 않을 수 있음 (Redo 필요)
- 📌 **MTR(Mini-Transaction)**
  - InnoDB 내부에서 페이지 단위로 수행되는 아주 작은 원자적 작업 단위(atomic operation), 물리적인 데이터 페이지를 안전하게 갱신하기 위한 최소 단위
    - 트랜잭션: SQL 수준의 논리적 작업 단위
  - MTR을 사용하는 이유:
    - InnoDB는 하나의 SQL 트랜잭션이 여러 데이터 페이지(page)를 수정할 수 있음
    - SQL 트랜잭션 단위로 Lock을 걸기에는 비효율적인 경우, MTR이라는 작은 내부 트랜잭션을 활용해 페이지 단위 원자성 보장
    - Redo Log 작업의 최소 단위, 실제 동작하는 I/O의 최소 단위 
</details>

<details>
    <summary> 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?</summary>

- 스토리지 엔진(Storage Engine)
  - 역할: DBMS 내부에서 실제 데이터 저장, 읽기, 수정, 복구하는 역할을 담당하는 모듈
  - SQL 엔진이 쿼리를 해석하면 스토리지 엔진이 인덱스 접근, 트랜잭션, 로그 관리 등 실제 문리 작업을 수행
  - InnoDB: ACID 트랜잭션, MVCC, 복구 기능, Row-level Locking 지원 등을 지원해 대표적으로 사용 
- 예시) MySQL의 구조
  - SQL Layer: 
    - SQL 해석, 최적화, 실행 결정
    - SQL Parser, Optimizer, Query Executor, Caching Security, ACL 등
  - Storage Engine Layer: 
    - 실제 데이터 저장·검색·트랜잭션 처리를 수행하는 계층
    - InnoDB, MyISAM, Memory, NDB 등 여러 엔진 중 선택할 수 있음
</details>

## 5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.

<details>
    <summary> 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.</summary>

- 인덱스: 
  - 데이터베이스에서 검색 속도를 높이기 위해 사용하는 자료구조 
  - 특정 컬럼에 대해 별도의 정렬된 구조(B-Tree, Hash 등)을 만들어 원하는 데이터를 빠르게 찾을 수 있음
- 인덱스를 사용하는 경우:
  - WHERE, JOIN, ORDER BY, GROUP BY 절에서 자주 사용되는 컬럼
  - 이터 검색 빈도가 높고, 수정·삽입·삭제가 적은 테이블일 때
- **인덱스의 종류**
  - B-Tree 인덱스
    - 가장 일반적으로 사용되는 인덱스 종류
    - 데이터베이스에서 기본적으로 제공되며, 이진 트리의 변형인 B-트리 구조를 사용하여 데이터를 저장하고 검색
    - 데이터의 정렬 순서를 유지, 범위 검색과 정렬된 결과 반환에 효율적
  - Hash 인덱스
    - 해시 함수를 사용하여 데이터를 저장하고 검색
    - 일치 검색에 효율적이지만, 범위 검색이나 정렬된 결과 반환에는 적합하지 않을 수 있음
  - 클러스터형 인덱스(Clustered Index)
    - 테이블의 데이터를 인덱스의 순서에 따라 물리적으로 정렬
    - 데이터의 논리적인 순서와 물리적인 저장 순서를 일치, 범위 검색 및 정렬된 결과 반환에 효율적
    - 하나의 테이블에는 하나의 클러스터드 인덱스만 생성 가능 
  - 비클러스터형 인덱스(Non-Clustered Index)
    - 테이블의 데이터를 인덱스의 순서에 따라 물리적으로 정렬하지 않음
    - 테이블의 열이나 열의 조합에 대한 별도의 데이터 구조를 생성하며, 데이터의 위치를 가리키는 포인터를 포함
</details>

<details>
    <summary> 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?</summary>

- 인덱스는 데이터 변경 시마다 함게 갱신되는 구조
- 쓰기(INSERT, UPDATE, DELETE) 작업이 잦은 테이블에 인덱스가 많으면 오히려 성능이 저하될 수 있음
  - 데이터 변경 시 인덱스 역시 수정해야 함: 추가/삭제/변경 시 인덱스 변경 필요
  - 쓰기 연산 오버헤드 증가: 인덱스 갱신 비용으로 인한 오버헤드
  - 디스크 I/O 증가: 인덱스는 별도의 공간을 차지함 
</details>

<details>
    <summary> 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?</summary>

- 인덱스에서 사용하지 않겠다고 선택된 값: 인덱스 갱신 비용이 발생하지 않으므로 성능 저하되지 않음
  - 인덱스에 포함된 컬럼 → 수정 시 인덱스도 함께 갱신 (쓰기 비용 증가)
  - 인덱스에 포함되지 않은 컬럼 → 단순히 데이터만 변경 (쓰기 비용 증가 없음)
</details>

<details>
    <summary> ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.</summary>

- **인덱스가 있는 경우 ORDER BY/GROUP BY 연산**:
  - 인덱스는 이미 정렬된 구조(B-Tree)를 가지고 있음
  - ORDER BY 연산 시 별도의 정렬 연산을 수행할 필요 없이 순차적으로 탐색 가능
  - GROUP BY 연산 시 정렬된 순서대로 그룹화가 가능하므로 정렬 생략 가능
- **인덱스가 없는 경우**:
  - DB는 데이터를 전부 탐색한 뒤 임시 메모리나 디스크 공간에서 직접 정렬을 수행
  - ORDER BY/GROUP BY 연산 시 테이블 전체 스캔+정렬을 수행하므로 성능 저하 발생
  - CPU 및 I/O 부하 증가, 연산 속도가 느려질 수 있음
</details>

<details>
    <summary> 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?</summary>

- 기본키(PK) == 인덱스는 아니지만, 기본키를 생성하면 자동으로 Unique Index가 생성됨
- 기본키와 인덱스의 차이
  - 기본키(PK)는 중복 불가능, NOT NULL
  - 인덱스는 중복 가능(Unique INDEX 제외), NULL값 가능 
  - 기본키는 테이블당 1개, 인덱스는 여러 개 생성 가능 
</details>

<details>
    <summary> 그렇다면 외래키는요?</summary>

- 외래키(FK)는 인덱스가 아니며, 외래키 지정 시에 인덱스가 자동으로 지정되지 않음
- 외래키로 지정된 컬럼에 인덱스를 추가하는 것을 권장
  - 부모 테이블의 변경 검사 시 효율성이 향상됨: 부모 테이블에서 데이터 삭제 시 자식 테이블의 외래키 참조 여부 확인 
  - JOIN 성능 향상: 외래키 컬럼은 JOIN 조건으로 자주 사용되기 때문
</details>

<details>
    <summary> 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?</summary>

- **클러스터형 인덱스(Clustered Index)의 경우**
  - 데이터의 물리적 저장 순서와 인덱스 순서가 동일
  - MySQL(InnoDB): 기본키(PK)를 자동으로 클러스터형 인덱스로 사용 
- **비클러스터형 인덱스(Non-Clustered Index)의 경우**
  - 인덱스는 별도의 구조(B-Tree) 로 관리, 실제 데이터는 물리적으로 별도의 위치
  - 인덱스 노드에는 데이터의 위치인 퐁인터만 저장되므로, 데이터의 물리적 저장 순서와 인덱스 순서가 동일하지 않음 
</details>

<details>
    <summary> 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?</summary>

- NoSQL(Redis, MongoDB)도 인덱스를 가지고 있음 
  - RDB의 인덱스와는 달리, 데이터 구조와 접근 패턴에 맞게 설계된 다양한 형태의 인덱스를 사용 
- 예) MongoDB (Document)
  - B-Tree 기반의 인덱스 사용, RDB와 유사
  - 하나의 쿼리에 하나의 인덱스만 사용 가능, 두 개 이상의 index 가 필요하다면 복합 index를 사용
  - 복합 인덱스, 텍스트 인덱스 등 다양한 형태 지원
- 예) Redis (key-value)
  - 메모리 내 자료구조 기반의 검색 수행
  - 키(key) 자체가 인덱스 역할을 하기도 함
  - 특정 키(@Id) 외에 다른 필드에 대한 인덱스인 보조 인덱스, 정렬된 세트(Sorted Set) 등 사용 
</details>

<details>
    <summary> (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?</summary>

- 인덱스를 타지 않음
  - 복합 인덱스 (A, B)는 왼쪽부터 순차적으로 사용하는 왼쪽 법칙(`Leftmost Prefix Rule`)을 따르기 때문
  - A 조건이 있어야 B 인덱스까지 활용 가능
  - 복합 인덱스는 데이터를 정렬할 때, 인덱스에 포함된 컬럼 순서대로 트리 구조를 이루기 때문 
    - B-Tree 인덱스는 첫 번째 컬럼을 기준으로 정렬, 첫 번째 컬럼이 같은 값들은 두 번째 컬럼을 기준으로 정렬
    - 따라서 첫 번째 컬럼 없이 두 번째나 세 번째 컬럼만으로는 효율적인 검색이 불가능
</details>

## 6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.

<details>
    <summary> RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.</summary>

- `클러스터링 (Clustering)`
  - 데이터베이스 서버들을 서로 연결해 하나의 논리적 서버처럼 사용해 고가용성과 부하 분산을 실현하는 구조
  - **RDBMS에서의 클러스터링**
    - 주로 Active-Active 또는 Active-Passive 방식으로 노드 간 요청을 분산 처리
      - Active-Active: DB 서버를 동시에 동작 가능
      - Active-Passive(Standby): 실제 가동하는 것만 Active, 나머지는 대기(Standby) 상태
    - Shared-Nothing 구조 또는 Shared-Disk 구조를 사용
        - Shared-Nothing(샤딩): 자원 분리, 서버와 저장소를 세트로 묶어 사용해 병목을 방지하고 성능 형성 가능, 정합성 문제 발생 
        - Shared-Disk: 여러 대의 서버가 1대의 저장소를 사용하는 구성, 서버 개수가 증가할수록 정보 공유를 위한 오버헤드 발생
    - SQL 레벨에서 트랜잭션 일관성을 유지하며, 모든 노드가 동일한 스키마를 공유
    - 예) MySQL InnoDB Cluster, PostgreSQL Patroni, Oracle RAC 등
  - **NoSQL에서의 클러스터링**
    - 분산 클러스터 구조를 기본적으로 채택: NoSQL은 수평 확장성(Scalability) 과 고가용성(High Availability) 을 목표로 설계됨
    - 데이터 샤딩(Sharding)을 기반으로 데이터 분산 저장, 각 노드는 특정 데이터 범위(Shared Key)에 대한 책임
      - 샤딩(Sharding): 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장
    - 예) MongoDB Sharded Cluster, Redis Cluster 등
- `레플리케이션 (Replication)`
  - 데이터의 변경 사항을 다른 서버(Replica)에 동일하게 복제하여 데이터 일관성과 가용성을 보장하는 기술
  - 읽기 부하 분산(read scalability) 및 장애 복구(failover) 목적에서 사용
  - **RDBMS에서의 레플리케이션**
    - 일반적으로 Master–Slave (Primary–Replica) 구조로 동작
      - Master (Primary): 모든 쓰기(INSERT/UPDATE/DELETE) 작업 수행
      - Slave (Replica): Master의 변경 로그를 전달받아 읽기(SELECT) 요청 처리
    - 복제 매커니즘
      - 트랜잭션 로그 기반 동작(binlog, WAL 등) 
      - MySQL: Binary Log(binlog) 를 기반으로 Slave가 Relay Log로 받아 재적용 
      - PostgreSQL: Write-Ahead Log (WAL) 복제를 통해 트랜잭션 로그를 전달 
      - Oracle: Data Guard 등 전용 동기화 엔진을 사용해 고가용성 구성
  - **NoSQL에서의 레플리케이션**
    - 레플리케이션 매커니즘
      - Document, Key 단위로 복제 
      - MongoDB: Replica Set 구조 사용, 하나의 Primary 노드와 다수의 Secondary 노드 구성, 비동기 복제
      - Redis: Master–Replica 구조로 데이터 복제, 데이터 슬롯(Hash Slot)을 기준으로 노드 간 복제
</details>

<details>
    <summary> 이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?</summary>

- 2단계 커밋(2PC, Two-Phase Commit) 프로토콜
  - 1단계(Prepare): Coordinator가 각 노드에 트랜잭션 수행 가능 여부를 질의
  - 2단계(Commit): 모든 노드가 ‘OK’를 응답하면 커밋, 하나라도 실패하면 전체 롤백
  - 일관성 보장 가능, 가용성과 확장성이 낮음
- 사가 패턴(Saga Pattern) 사용
  - 마이크로서비스 아키텍처(MSA)나 비동기 메시지 기반 시스템에서 자주 사용하는 패턴
  - 여러 서비스(또는 DB 트랜잭션)에 걸친 작업을 2PC 없이 일관성 있게 처리하기 위한 분산 트랜잭션 관리 방식
  - 작동 원리: 각 서비스는 자신의 DB 내에서만 트랜잭션을 수행 → 모든 서비스가 순서대로 작업을 수행, 중간에 실패하면 이전 단계들의 변경을 보상 트랜잭션(Undo Logic) 으로 복구
  - 최종적 일관성(Eventual Consistency) 보장, 개별 서비스 장애에 유연
</details>

<details>
    <summary> 마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?</summary>

- Master-Slave 구조
    - Master: 쓰기(Write), 업데이트, 삭제를 담당
    - Slave(Replica): 읽기(Read) 전용, Master의 데이터를 복제 (비동기 복제 일반적)
    - 복제가 실시간이 아니라면 데이터 불일치가 발생할 수 있고, 이러한 현상을 복제 지연이라고 함.
- 데이터 동기화 전까지 데이터 정합성을 지키는 방법
    - 비동기 복제방식 (Async Replication)
        - Master가 commit 후 Slave로 binlog 전송 (Slave 응답 기다리지 않음)
        - 속도가 빠름, 복제 지연이 발생할 수 있음
        - Master 장애 시 Slave가 아직 못 받은 로그 유실 가능
    - 반동기 복제방식 (Semi-Sync Replication)
        - Master가 commit 시, 적어도 한 Slave의 ACK 수신 후 완료
        - Master 장애 시 ACK 받은 Slave가 최신 상태를 가지므로 데이터 손실 최소화
        - 성능은 비동기보다 느리지만, 데이터 정합성 측면에서 안정적
        - MySQL 5.5부터 공식 지원 (rpl_semi_sync_master_enabled 옵션)
    - 세션/캐시 기반의 Read-After-Write 처리:
        - 사용자가 데이터를 쓴 세션(혹은 요청 흐름)에서는 일정 시간 동안 Master로부터만 조회하도록 처리
</details>

<details>
    <summary> 다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.</summary>

- Deadlock 현상:
    - 두 개 이상의 트랜잭션이 서로가 보유한 자원의 락(lock)을 기다리며 무한 대기 상태에 빠지는 현상
    - 예) T1은 자원 A를 잠그고 자원 B를 기다리고, T2는 자원 B를 잠그고 자원 A를 기다리는 경우 발생
- DeadLock이 발생하는 조건
    - 상호 배제(Multual Exclusion) : 자원은 한 번에 하나의 프로세스만 사용할 수 있음
    - 점유와 대기(Hold and Wait) : 최소한 하나의 프로세스가 하나의 자원을 점유하고 있으며, 추가적인 자원을 요청하면서 대기
    - 비선점(No Preemption) : 자원이 선점될 수 없다. 즉, 프로세스가 자원을 자발적으로 놓지 않는 한, 다른 프로세스가 그 자원을 강제로 가져갈 수 없음
    - 순환 대기(Circular Wait) : 두 개 이상의 프로세스가 원형으로 자원을 대기
- Deadlock 해결 전략:
    - 트랜잭션의 순서화: 트랜잭션을 실행하는 순서를 일관되게 유지, 교착 상태의 가능성을 줄임
    - 락의 범위 최소화: 트랜잭션에서 필요한 자원에 대해서만 락을 설정
    - 락 타임아웃 설정: 트랜잭션이 락을 대기하는 시간을 제한하여 시스템이 무한히 대기하는 상황을 방지
    - 짧은 트랜잭션 유지: 커밋(commit)을 빠르게 수행하여 다른 트랜잭션이 Lock을 기다리는 시간을 단축
    - 트랜잭션 격리 수준 조정: 너무 높은 격리 수준은 불필요한 락 범위를 증가시켜 Deadlock 위험 증가
</details>

<details>
    <summary> 샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?</summary>

- 샤딩(Sharding):
    - 하나의 데이터베이스를 여러 개의 작은 데이터베이스(Shard)로 나누어 분산 저장하는 방식
    - 데이터를 수평 분할(Horizontal Partitioning) 하여 각 샤드가 전체 데이터의 일부만 담당하도록 구성
- 레플리케이션(Replication)과 샤딩 방식의 차이
- 
  | 구분     | 샤딩 (Sharding)           | 레플리케이션 (Replication)                    |
  | ------ | ----------------------- | --------------------------------------- |
  | 목적     | **데이터 분산** (부하 분산, 확장성) | **데이터 복제** (고가용성, 백업)                   |
  | 데이터 구조 | 샤드마다 서로 다른 데이터 저장       | 모든 노드가 동일한 데이터 보유                       |
  | 트래픽 분산 | 수평 확장 (쓰기/읽기 분산 가능)     | 주로 읽기 부하 분산(Read Scaling)               |
  | 장애 대응  | 특정 샤드 장애 시 해당 범위만 영향    | Master 장애 시 Replica로 Failover 가능        |
  | 예시     | MongoDB Sharded Cluster | MySQL Master–Slave, MongoDB Replica Set |

</details>


<summary><h3>7. 정규화가 무엇인가요?</h3></summary>
<ul>
<li> 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.</li>
<li> 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.</li>
<li> 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>8. View가 무엇이고, 언제 사용할 수 있나요?</h3></summary>
<ul>
<li> 그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?</li>
</ul>
</details>

<details>
  <summary><h3>9. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.</li>
<li> 그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?</li>
<li> 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?</li>
<li> 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>10. B-Tree와 B+Tree에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?</li>
<li> DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?</li>
<li> 오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>11. DB Locking에 대해 설명해 주세요.</h3></summary>
<ul>
<li> Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.</li>
<li> 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?</li>
</ul>
</details>

<details>
  <summary><h3>12. 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?</h3></summary>
<ul>
<li> DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?</li>
</ul>
</details>

<details>
  <summary><h3>13. Schema가 무엇인가요?</h3></summary>
<ul>
  <li>Schema의 3계층에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>14. DB의 Connection Pool에 대해 설명해 주세요.</h3></summary>
<ul>
  <li>DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.</h3></summary>
<ul>
  <li>가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?</li>
  <li> COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(*), COUNT(column) 의 동작 과정에는 차이가 있나요?</li>
</ul>
</details>

<details>
  <summary><h3>16. SQL Injection에 대해 설명해 주세요.</h3></summary>
<ul>
  <li>그렇다면, 우리가 서버 개발 과정에서 사용하는 수많은 DB 라이브러리들은 이 문제를 어떻게 해결할까요?</li>
</ul>
</details>