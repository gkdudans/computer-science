## 데이터베이스

### 1\. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.
> - 기본키: 릴레이션(테이블)의 튜플을 고유하게 식별할 수 있는 후보키 중 테이블의 대표 키로 선택된 속성(컬럼)들의 집합입니다. (고유성과 NOT NULL (개체 무결성)을 만족해야 함.)
> - 후보키: 릴레이션의 튜플을 고유하게 식별할 수 있는 최소한의 속성들의 집합입니다. (고유성(Unique)과 최소성(Minimal)을 만족하는 키들의 총집합이며, 이들 중 하나가 기본키로 선택됨.)
> - 슈퍼키: 릴레이션의 튜플을 고유하게 식별할 수 있는 모든 속성 집합입니다. (고유성은 만족하지만, 최소성은 만족하지 않아도 됨. 후보키와 기본키를 모두 포함하는 가장 큰 개념.)

*   기본키는 수정이 가능한가요?
> - 가능하지만, 권장되지 않습니다. 기본키는 튜플의 고유한 식별자이며, 다른 테이블의 외래키(Foreign Key)가 이를 참조하고 있을 수 있습니다(참조 무결성). 기본키를 수정하면 참조하는 모든 외래키를 연쇄적으로 업데이트(Update Cascade)해야 하거나, 무결성 위반으로 인해 수정이 실패할 수 있습니다. 따라서 기본키는 불변(Immutable)의 의미를 갖는 값으로 선정하는 것이 좋습니다.

*   사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?
> - MySQL(InnoDB 엔진 기준)은 기본키(Primary Key) 가 명시적으로 정의되지 않아도 테이블 생성을 허용합니다. 이는 InnoDB가 내부적으로 클러스터형 인덱스(Clustered Index) 를 반드시 가져야 하기 때문인데, 사용자가 지정하지 않은 경우 대체 키(Pseudo Primary Key)를 자동으로 생성합니다.
> - 작동 방식:
> 1. 기본키가 명시된 경우 → 해당 기본키가 클러스터형 인덱스로 사용됩니다.
> 2. 기본키가 없고, UNIQUE NOT NULL 컬럼이 존재하는 경우 → 그 컬럼을 클러스터형 인덱스로 자동 사용합니다.
> 3. 그마저도 없을 경우 → InnoDB가 내부적으로 숨겨진 6바이트 크기의 ROW ID(일종의 내부 기본키) 를 생성하여 각 레코드를 식별합니다.
> - 즉, MySQL은 기본키가 없어도 테이블을 만들 수 있지만, 실제 내부적으로는 항상 레코드를 유일하게 식별하기 위한 식별자(Internal Cluster Key) 를 유지하고 있습니다. 따라서 사용자 입장에서는 기본키가 없어 보여도, InnoDB는 내부적으로 보이지 않는 기본키를 자동으로 만들어 테이블의 정렬 및 데이터 접근을 관리하는 구조입니다.

*   외래키 값은 NULL이 들어올 수 있나요?
> - 네, NULL이 들어올 수 있습니다. 외래키 칼럼에 NULL이 들어오는 것은 "참조하는 부모 테이블의 어떤 튜플과도 현재 튜플이 관련이 없다"는 의미를 갖습니다. (외래키 칼럼을 정의할 때 NOT NULL 제약조건을 명시적으로 추가하면 NULL 값이 들어올 수 없습니다.) NULL이 아닌 값이 들어온다면, 반드시 참조 무결성 제약조건에 따라 부모 테이블의 기본키 값 중 하나와 일치해야 합니다.

*   어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?
> - UNIQUE 키워드가 붙으면 해당 칼럼에 유니크 인덱스(Unique Index)가 자동으로 생성됩니다.
> - 이 칼럼을 활용하는 경우 성능 차이:
>   - SELECT (읽기) 성능: WHERE 절에서 해당 칼럼을 사용할 경우, 인덱스를 통한 검색이 가능해져 테이블 전체를 탐색하는 것보다 훨씬 빠르게 데이터를 찾을 수 있습니다. (성능 향상)
>    - DML (쓰기/수정) 성능: INSERT 또는 UPDATE 시, 새로운 값이 들어올 때마다 UNIQUE 제약조건을 만족하는지 검사하는 추가 작업이 필요하며, 데이터가 변경될 때마다 인덱스 자체도 함께 갱신하는 오버헤드가 발생하여 성능이 저하될 수 있습니다. (성능 저하)

### 2\. RDB와 NoSQL의 차이에 대해 설명해 주세요.
> - **RDB(관계형 데이터베이스) **: 테이블 기반의 고정된 스키마를 사용하며, 조인을 통해 데이터 간의 관계와 ACID 속성을 이용한 강력한 일관성을 보장합니다.
> - **NoSQL**: 문서, 키-값 등 다양한 모델을 사용하며 유연하고 동적인 스키마를 갖습니다. NoSQL은 주로 BASE 모델을 추구하며 강력한 일관성 대신 수평 확장(Scale-out)을 통한 대용량 처리와 분산에 강점을 가집니다.

*   NoSQL의 강점과, 약점이 무엇인가요?
> - 강점: 수평 확장이 용이하여 대량의 트래픽과 데이터를 저렴하게 처리할 수 있고, 유연한 스키마 덕분에 데이터 구조 변화에 민첩하게 대응할 수 있어 빠른 개발에 유리합니다.
> - 약점: 강력한 데이터 일관성(ACID)을 보장하기 어려우며, 조인 기능이 제한적이거나 없기 때문에 복잡한 관계 질의에는 적합하지 않습니다. 또한, 데이터 모델이 다양하여 표준화된 쿼리 언어(SQL)가 없어 학습 곡선이 높습니다.

*   RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)
> - RDB는 데이터의 무결성을 보장하는 ACID 트랜잭션 처리 과정에서 NoSQL보다 더 큰 부하가 걸릴 수 있습니다. 구체적으로는 데이터의 일관성을 유지하기 위한 복잡한 잠금(Locking) 메커니즘과 트랜잭션 로그 기록 오버헤드가 발생하며, 정규화된 구조 때문에 데이터를 가져올 때 발생하는 조인(JOIN) 연산이 대규모 데이터에서 성능 병목을 유발할 수 있습니다.

*   NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.
> 저는 MongoDB를 활용하여 식당 장소 정보 및 리뷰 크롤링 데이터를 저장하는 시스템을 구축한 경험이 있습니다. <br>
> **1. 데이터 구조의 유연성**:
식당 장소 정보와 리뷰 데이터는 비정형 요소(예: 리뷰 내용, 태그, 영업 시간의 변동 등)가 많고, 추후 서비스 확장이나 크롤링 대상 사이트의 변화에 따라 필드 구조가 유연하게 변경될 수 있는 특성을 가집니다. RDB는 고정된 스키마를 요구하기 때문에 구조 변경 시 테이블 전체를 수정하는 번거로움과 서비스 중단 위험이 따르지만, MongoDB는 스키마리스(Schema-less) 또는 동적 스키마(Dynamic Schema) 방식이라 이러한 변화에 민첩하게 대응할 수 있어 개발 속도를 높일 수 있었습니다.<br>
> **2. 단일 문서(Document) 기반의 빠른 조회 성능**:
식당 정보를 조회할 때, 일반적으로 식당의 기본 정보, 메뉴, 리뷰 등이 함께 필요합니다. RDB에서 이 정보를 가져오려면 여러 테이블 간의 복잡한 조인(JOIN) 연산이 필수적이며, 이는 대규모 데이터에서 성능 병목을 유발합니다. 반면, MongoDB는 식당 정보를 하나의 문서(Document) 안에 포함(Embed)할 수 있어, 데이터를 가져올 때 단 한 번의 쿼리로 모든 관련 정보를 얻을 수 있으므로 조회 성능이 월등히 빠릅니다.<br>
> **3. 대용량 데이터 처리 및 수평 확장 용이성**: 
크롤링을 통해 수집된 데이터는 그 양이 방대하며 지속적으로 증가합니다. RDB는 주로 서버 성능을 높이는 **수직 확장(Scale-up)**에 의존하는 반면, MongoDB는 서버를 쉽게 늘려(Scale-out) 용량과 트래픽을 분산 처리하는 **수평 확장(Sharding)**에 강점을 가집니다. 대용량 데이터를 저렴하고 효율적으로 저장하고 처리하기 위해서는 분산 아키텍처를 지원하는 MongoDB가 더 적합하다고 판단했습니다.<br>

### 3\. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.
> - **트랜잭션(Transaction):** 데이터베이스의 상태를 변환시키는 논리적인 작업 단위입니다. 여러 개의 SQL 명령어들을 하나의 묶음으로 처리하여, 전체 작업이 완벽하게 성공되거나(Commit), 하나라도 실패하면 전체가 취소(Rollback)되어 데이터베이스의 일관성을 유지하는 것을 목표로 합니다.
> - **ACID 원칙(Atomicity, Consistency, Isolation, Durability)**: 데이터베이스 트랜잭션이 안전하게 수행되는 것을 보장하기 위한 네 가지 핵심 속성입니다.
| 속성 | 한국어 명칭 | 설명 |
|------|--------------|------|
| A | 원자성 (Atomicity) | 트랜잭션 내의 모든 작업은 전부 성공하거나, 아니면 전부 실패해야 한다. (All or Nothing) |
| C | 일관성 (Consistency) | 트랜잭션이 실행되기 전후에 데이터베이스는 항상 일관된 상태를 유지해야 한다. (정의된 규칙이나 제약조건을 위반하지 않아야 함) |
| I | 격리성 (Isolation) | 동시에 실행되는 트랜잭션들은 서로 간에 독립적으로 수행되어야 하며, 각 트랜잭션은 다른 트랜잭션의 연산을 알 수 없다. |
| D | 영속성 (Durability) | 트랜잭션이 성공적으로 완료(Commit)되면, 그 결과는 시스템 장애(정전, 서버 다운 등)에도 불구하고 영구적으로 보존되어야 한다. |

*   ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?
> - DBMS는 주로 로그(Log) 메커니즘을 사용하여 영속성을 보장합니다. 트랜잭션이 Commit되는 순간, 변경된 데이터가 실제 디스크의 데이터 파일에 기록되기 전에, 그 변경 내용이 담긴 **트랜잭션 로그(Transaction Log)**를 먼저 영구 저장 장치(디스크)에 기록합니다. 이를 WAL(Write Ahead Logging) 또는 Force Logging이라고 한다.
> - Commit 후 시스템 장애가 발생하더라도, 재시작 시 DBMS는 로그 파일을 확인하여 Commit된 변경 사항은 데이터 파일에 **복구(Redo)**함으로써 데이터의 영구적인 보존을 보장합니다.

*   트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?
> - (대표적인 상황) 쇼핑몰 서비스 - 상품 주문 시 재고 감소, 주문 정보 생성, 결제 정보 기록까지 세 단계를 하나의 논리적인 작업 단위로 묶기 위해 트랜잭션을 사용할 수 있습니다.
사용하는 경우: 데이터의 정합성(Consistency)이 가장 중요하며, 여러 개의 데이터베이스 작업이 분리될 수 없는 단일한 업무 흐름을 구성할 때 사용해야 합니다. (대표적인 예시: 계좌 이체, 상품 주문 및 재고 처리, 복합적인 데이터 입력 등)

*   읽기에는 트랜잭션을 걸지 않아도 될까요?
> - 아닙니다. 읽기 연산에도 트랜잭션은 필수적입니다.
> - 단순히 한 번의 조회로 끝나는 쿼리라면 트랜잭션의 필요성이 낮지만, 동일 트랜잭션 내에서 여러 번의 읽기가 수행되거나 읽은 데이터에 기반하여 후속 로직을 처리해야 하는 경우 **격리성(Isolation)**을 보장해야 합니다.
> - 트랜잭션을 걸지 않거나 격리 수준이 낮으면, 다른 트랜잭션의 중간 변경사항이 읽히는 Dirty Read, 같은 데이터를 두 번 읽었는데 값이 달라지는 Non-Repeatable Read와 같은 동시성 문제가 발생하여 데이터 일관성이 깨질 수 있습니다. DBMS는 이러한 문제 방지를 위해 읽기 트랜잭션에도 격리 수준을 적용합니다.

### 4\. 트랜잭션 격리 레벨에 대해 설명해 주세요.
- **트랜잭션 격리 레벨(Isolation Level)**: 동시에 여러 트랜잭션이 실행될 때, 각 트랜잭션이 다른 트랜잭션의 변경 내용을 어디까지 볼 수 있도록 허용할지 정의하는 표준 수준입니다. (데이터의 일관성(Consistency)과 동시성(Concurrency) 간의 균형을 맞추기 위해 존재) 격리 레벨이 높아질수록 데이터 일관성은 높아지지만, 동시성은 낮아져 성능 저하가 발생할 수 있습니다.

  | 레벨 (낮음 → 높음) | 설명 | 발생하는 문제 |
  |---------------------|------|----------------|
  | Read Uncommitted | 커밋되지 않은(Uncommitted) 다른 트랜잭션의 변경 내용도 읽을 수 있음. | Dirty Read |
  | Read Committed | 커밋된(Committed) 데이터만 읽을 수 있음. | Non-Repeatable Read, Phantom Read |
  | Repeatable Read | 트랜잭션 내에서 동일한 데이터를 반복 조회해도 항상 같은 결과를 보장. | Phantom Read |
  | Serializable | 가장 엄격한 격리 레벨. 트랜잭션을 순차적으로(Serial) 실행하는 것처럼 완벽히 격리. | 없음 (모든 동시성 문제 해결) |

  - Dirty Read: 커밋되지 않은 데이터(임시 변경된 데이터)를 읽는 현상.
  - Non-Repeatable Read: 한 트랜잭션이 같은 행을 두 번 읽었는데, 그 사이에 다른 트랜잭션이 그 행을 수정하고 커밋하여 두 번째 읽기 결과가 달라지는 현상.
  - Phantom Read: 한 트랜잭션이 특정 조건으로 행 집합을 조회했는데, 그 사이에 다른 트랜잭션이 해당 조건에 맞는 새로운 행을 삽입(Insert)하고 커밋하여 두 번째 조회 결과에 '유령'처럼 새로운 행이 나타나는 현상.


*   모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?
> - X. 모든 DBMS가 4개의 표준 레벨을 모두 구현하지는 않습니다.
> - SQL Server나 Oracle 같은 일부 DBMS는 표준 외에 Snapshot Isolation 같은 자체적인 격리 레벨을 제공하거나, 표준 레벨 중 일부를 다른 방식으로 구현합니다.
> - Oracle의 경우, Read Committed 레벨이 가장 기본이며, Repeatable Read는 별도로 지원하지 않고 Serializable로 대체됩니다. 이는 Oracle이 Undo 영역을 활용하는 다중 버전 동시성 제어(MVCC) 방식을 기본으로 채택하여, Read Committed에서도 대부분의 Non-Repeatable Read 문제를 발생시키지 않기 때문입니다.
> 
*   만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.
> - MySQL의 InnoDB 스토리지 엔진은 데이터 복구 및 트랜잭션 격리(특히 MVCC)를 위해 이 두 영역을 핵심적으로 사용합니다.
>   - Undo 영역 (로그):
>     - 목적: 트랜잭션의 **원자성(Atomicity)**과 **격리성(Isolation)**을 보장합니다.
>     - 역할: 트랜잭션이 데이터를 변경할 때, **변경 전의 이전 데이터(Old Version)**를 보관합니다. 트랜잭션이 실패하여 Rollback이 필요할 경우, 이 로그를 사용하여 데이터를 원래 상태로 되돌립니다(원자성). 또한, **MVCC(Multi-Version Concurrency Control)**를 구현하여 다른 트랜잭션이 이전 버전의 데이터를 읽게 하여 Non-Repeatable Read 등의 문제를 방지합니다(격리성).
>   - Redo 영역 (로그):
>     - 목적: 트랜잭션의 **영속성(Durability)**을 보장합니다.
>     - 역할: 트랜잭션이 데이터를 변경했을 때, 그 변경 내용을 순서대로 디스크에 기록합니다. 트랜잭션이 Commit된 후 시스템에 장애(정전 등)가 발생하여 데이터가 디스크에 완전히 기록되지 못했더라도, 재시작 시 이 Redo 로그를 사용하여 Commit된 내용을 **복구(Redo)**함으로써 데이터의 영속성을 보장합니다.

*   그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?
>  - **스토리지 엔진(Storage Engine) **은 데이터베이스 관리 시스템(DBMS)의 가장 하위 계층에서 실제로 디스크에 데이터를 저장하고, 읽고, 관리하는 역할을 담당하는 핵심 모듈입니다.
> - DBMS의 **핵심 기능(SQL 파싱, 권한 관리, 트랜잭션 처리 등) **은 DBMS 코어에서 담당하고, 스토리지 엔진은 "어떻게" 데이터를 저장할지 결정합니다.
> - MySQL의 경우 InnoDB, MyISAM 등 여러 스토리지 엔진을 플러그인 방식으로 지원하며, 각 엔진마다 트랜잭션 지원 여부, 잠금 방식, 인덱싱 구조, 성능 특성이 다릅니다. 예를 들어, InnoDB는 트랜잭션(ACID)과 행 레벨 잠금을 지원하지만, MyISAM은 트랜잭션을 지원하지 않고 테이블 레벨 잠금만 지원합니다.

### 5\. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.
> - 인덱스(Index): 데이터베이스에서 검색 속도를 향상시키기 위해 사용하는 자료구조입니다. 흔히 책의 색인처럼, 원하는 데이터를 빠르게 찾기 위해 특정 열(Column)의 값을 정렬해 별도로 관리합니다. 내부적으로는 주로 B+Tree나 Hash 구조를 사용하며, 인덱스가 존재하면 WHERE, JOIN, ORDER BY, GROUP BY 연산의 탐색 범위를 크게 줄일 수 있습니다.

*   일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?
> - 인덱스는 데이터를 빠르게 검색하기 위한 자료구조이지만, 테이블 데이터가 변경될 때마다 인덱스도 함께 갱신해야 하는 오버헤드(Overhead)가 발생합니다.
>   1) INSERT (삽입 시): 테이블에 새로운 행이 삽입되면, 해당 행의 키 값은 인덱스 구조(대부분 B-Tree) 내의 적절한 위치에 삽입되어야 합니다. 이는 **페이지 분할(Split)**과 같은 추가적인 디스크 I/O 작업을 유발합니다.
>   2) UPDATE (수정 시): 인덱스 키로 사용된 칼럼의 값이 수정되면, 기존 인덱스 항목은 삭제되고 새로운 값으로 삽입되는 두 단계의 작업이 발생하여 비용이 높습니다.
>   3) DELETE (삭제 시): 테이블에서 행이 삭제되면 인덱스에서도 해당 항목을 삭제해야 합니다.
> - 이처럼 쓰기(Write) 작업이 빈번할 경우, 인덱스 유지 보수 비용이 검색 성능 향상 이득을 상쇄하고도 남게 되어 전체적인 DBMS 성능을 저하시킬 수 있습니다.

*   앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?
> - YES. 인덱스가 없는 일반 칼럼이라 할지라도, 그 값이 변경될 때는 테이블의 데이터 페이지 자체를 수정해야 합니다. DBMS는 변경된 내용을 디스크에 반영하기 위해 **트랜잭션 로그(Redo Log) **를 기록해야 합니다. 인덱스 갱신만큼 복잡한 구조 변경 작업은 없지만, 디스크 I/O와 로깅 오버헤드는 여전히 발생합니다. 다만, 인덱스가 있는 칼럼은 데이터 페이지 변경과 인덱스 페이지 변경 두 가지 모두를 수행해야 하므로, 인덱스가 없는 칼럼보다 수정 부하가 훨씬 큽니다.

*   ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.
> - ORDER BY (정렬)나 GROUP BY (그룹핑) 연산은 기본적으로 CPU와 메모리를 많이 사용하는 고비용 연산입니다.
> - 인덱스가 없는 경우: DBMS는 쿼리 결과를 가져온 후, 디스크에 임시 저장 공간(보통 Sort Buffer나 Temp Table)을 사용하여 데이터를 **직접 정렬(Filesort)**하거나 그룹핑 작업을 수행합니다. 데이터 크기가 메모리 용량을 초과하면 디스크 I/O가 발생하여 성능이 크게 저하되는 성능 병목이 발생합니다.
> - 인덱스가 있는 경우: 인덱스는 데이터가 이미 정렬된 상태로 저장되어 있는 자료구조(예: B-Tree). 쿼리에서 인덱스의 순서와 같은 방향으로 ORDER BY나 GROUP BY를 요청하면, DBMS는 인덱스를 처음부터 순차적으로 읽는 것만으로 별도의 정렬/그룹핑 과정 없이 결과를 바로 반환할 수 있습니다. 이를 통해 Filesort 과정이 생략되어 성능이 극적으로 향상됩니다.

*   기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?
> - 기본키는 인덱스라고 할 수 있습니다. 대부분의 RDB(특히 InnoDB)에서 기본키를 정의하면 DBMS가 해당 칼럼에 자동으로 **클러스터형 인덱스(Clustered Index)**를 생성합니다.
> 차이점:
> - 기본키(Primary Key): 데이터베이스 논리적 제약조건의 하나입니다. 튜플을 고유하게 식별하며 NOT NULL을 강제하는 개념입니다.
> - 인덱스(Index): 디스크에 저장된 데이터를 빠르게 찾기 위한 물리적인 자료구조입니다. 기본키는 이 인덱스를 생성하는 논리적 기반이 됩니다.

*   그렇다면 외래키는요?
> - 외래키(Foreign Key)는 그 자체가 인덱스는 아닙니다. 하지만 외래키가 정의될 때, 대부분의 DBMS(특히 MySQL의 InnoDB)는 참조 무결성을 확인하는 작업의 효율성을 높이기 위해 **자동으로 인덱스(Non-Clustered Index) **를 생성해 줍니다.
> - 외래키의 역할은 참조 무결성을 보장하는 것이고, 인덱스는 이 무결성 검사 속도를 높이기 위한 보조 수단입니다.

*   인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?
> - 클러스터형 인덱스(Clustered Index)는 물리적 저장 순서에 영향을 미칩니다.
> - 클러스터형 인덱스 (기본키): 인덱스의 리프 페이지가 곧 실제 데이터 행(튜플) 자체를 포함합니다. 따라서 데이터는 클러스터형 인덱스 키 값의 물리적인 순서대로 디스크에 저장됩니다. 테이블당 오직 하나만 가질 수 있습니다.
> - 비클러스터형 인덱스 (Non-Clustered Index): 데이터의 물리적 저장 순서에 영향을 미치지 않습니다. 리프 페이지는 인덱스 키와 해당 데이터 행을 찾아가기 위한 **주소 값(Primary Key 또는 물리적 주소)**만 가지고 있습니다. 데이터 자체는 클러스터형 인덱스의 순서를 따릅니다.
> 
*   우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?
> - 네, 대부분의 NoSQL DB도 인덱스를 갖고 있습니다.
> - MongoDB: RDB와 유사하게 B-Tree 기반의 인덱스를 사용하며, 단일 필드, 복합 필드, Unique, TTL(Time-To-Live) 등 다양한 인덱스 타입을 지원하여 빠른 쿼리 성능을 보장합니다.
> - Redis: Key-Value Store로, 기본적으로 메모리에 데이터를 저장하며, Key 자체가 해시 테이블의 인덱스 역할을 하므로 별도의 명시적 인덱스가 필요하지 않습니다.
> - RDB 인덱스와의 차이점:
>   - 자료구조의 다양성: RDB가 주로 B-Tree 인덱스에 집중하는 반면, NoSQL은 데이터 모델에 따라 지리 공간(Geospatial), 텍스트 검색(Text Index) 등 특화된 인덱스를 제공합니다.
>   - 트랜잭션 오버헤드: NoSQL(특히 MongoDB)의 인덱스는 RDB만큼 엄격한 ACID 트랜잭션과 잠금 메커니즘을 거치지 않기 때문에, 인덱스 갱신에 드는 트랜잭션 부하가 RDB보다 낮을 수 있습니다.

*   (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?
> - 아닙니다. 해당 쿼리는 인덱스를 타지 못할 가능성이 높습니다. 이는 복합 인덱스(Composite Index)의 핵심인 선행 칼럼의 원칙(Leftmost Prefix Rule) 때문입니다.
> - 복합 인덱스 (A, B)는 A, B 순서로 데이터가 정렬되어 있습니다. 인덱스를 사용하려면 반드시 인덱스의 첫 번째 칼럼인 A를 조건으로 사용해야 합니다.
> - A 조건 없이 B 조건만 사용하는 것은 정렬된 목록의 중간 값만 가지고 검색을 시도하는 것과 같기 때문에, DBMS는 인덱스를 활용할 수 없다고 판단하고 Full Table Scan을 수행할 가능성이 높습니다. (매우 예외적으로 B 칼럼의 선택도가 극도로 높아 인덱스 스캔이 효율적이라고 판단하는 경우가 있을 수 있지만, 일반적인 경우는 '타지 못한다'입니다.)

### 6\. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.

RDBMS의 클러스터링(Clustering)은 여러 DB 서버를 하나의 논리적 시스템처럼 구성하여 **고가용성(HA)** 과 **부하 분산(Load Balancing)** 을 달성하는 방식입니다. 일반적으로 **Active-Standby(이중화)** 또는 **Active-Active** 형태로 구성되며, 하나의 노드가 장애를 일으켜도 다른 노드가 즉시 서비스를 이어받을 수 있습니다.  
반면, 레플리케이션(Replication)은 **Master–Slave 구조**로 동작하며, 마스터에서 발생한 변경 사항을 슬레이브로 비동기 또는 반동기 방식으로 복제합니다. 읽기 부하를 분산하고, 장애 시 슬레이브를 승격(Promotion)하여 복구 시간을 단축할 수 있습니다.

NoSQL에서는 시스템 특성상 **수평 확장성(Scalability)** 과 **가용성(Availability)** 이 우선이기 때문에, 대부분 **클러스터링 + 레플리케이션 + 파티셔닝(Sharding)** 을 동시에 지원합니다. 예를 들어 MongoDB는 **Replica Set**(복제)과 **Sharded Cluster**(분산 저장)를 함께 구성하여 노드 장애에도 데이터 접근이 가능하게 설계합니다.


*   이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?
분산 환경에서는 **2PC (Two-Phase Commit)** 나 **3PC (Three-Phase Commit)** 프로토콜을 사용해 트랜잭션 일관성을 보장합니다.  
하지만 네트워크 지연이나 노드 장애가 잦은 환경에서는 완벽한 일관성을 유지하기 어렵기 때문에, **CAP 이론**에 따라 RDBMS는 **Consistency**를 우선하고, NoSQL은 **Availability**와 **Partition tolerance**를 더 중시하는 방향으로 설계됩니다.  
NoSQL에서는 주로 **Eventually Consistent(최종적 일관성)** 모델을 사용합니다.


*   마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?
비동기 복제에서는 마스터에 커밋된 데이터가 아직 슬레이브로 전송되지 않았을 수 있습니다.  
이를 보완하기 위한 대표적 방법은 다음과 같습니다:
- **Semi-Synchronous Replication:** 마스터가 슬레이브 중 최소 하나로부터 ACK(수신 확인)를 받기 전까지 커밋을 완료하지 않음.
- **GTID (Global Transaction ID):** 트랜잭션에 전역 식별자를 부여해 동기화 상태를 정밀하게 추적.
- **Read-After-Write Consistency 보장:** 특정 세션에서만 마스터로 읽기 요청을 강제.


*   다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.

다중 트랜잭션 환경에서 두 트랜잭션이 서로가 점유한 자원을 기다리며 무한 대기하는 상태를 **데드락(Deadlock)** 이라고 합니다.  
예시로, 트랜잭션 A가 Row X를 점유하고 Y를 기다리는 동안, 트랜잭션 B가 Y를 점유하고 X를 기다리면 교착 상태가 발생합니다.  
해결 방법은 다음과 같습니다:
- **Lock Timeout 설정:** 일정 시간 후 자동 롤백.
- **Lock 순서 정렬:** 모든 트랜잭션이 동일한 자원 획득 순서를 따르도록 설계.
- **낙관적 락(Optimistic Lock):** 충돌 발생 시점에만 검증 후 재시도.
- **DBMS Deadlock Detection:** InnoDB 등은 주기적으로 Wait-for Graph를 검사하여 교착 상태를 감지하고, 비용이 적은 트랜잭션을 강제 종료합니다.


*   샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?

샤딩은 데이터를 **수평 분할(Horizontal Partitioning)** 하여 여러 노드에 나누어 저장하는 방식입니다. 예를 들어 사용자 ID 기준으로 데이터를 여러 서버에 분산 저장하면, 단일 DB의 저장 한계와 부하를 줄일 수 있습니다.  

- **레플리케이션**: 데이터 복제(중복 저장)로 **가용성** 향상  
- **샤딩**: 데이터 분산으로 **확장성** 향상  

만약 내가 분산 환경을 설계한다면, **읽기 부하가 많고 장애 복구가 중요한 서비스에는 레플리케이션**,  
**데이터가 방대하고 트래픽이 급증하는 서비스에는 샤딩**을 선택할 것입니다.  
실무에서는 두 방식을 **혼합 구성(Sharded Replica Cluster)** 하여 성능과 안정성을 동시에 확보합니다.

### 7\. 정규화가 무엇인가요?

*   정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.
*   각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.
*   정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.

### 8\. View가 무엇이고, 언제 사용할 수 있나요?

*   그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?

### 9\. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.

*   사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.
*   그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?
*   앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?
*   3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.

### 10\. B-Tree와 B+Tree에 대해 설명해 주세요.

*   그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?
*   DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?
*   오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.

### 11\. DB Locking에 대해 설명해 주세요.

*   Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.
*   물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?

### 12\. 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?

*   DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?

### 13\. Schema가 무엇인가요?

*   Schema의 3계층에 대해 설명해 주세요.

### 14\. DB의 Connection Pool에 대해 설명해 주세요.

*   DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.

### 15\. Table Full Scan, Index Range Scan에 대해 설명해 주세요.

*   가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?
*   COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(\*), COUNT(column) 의 동작 과정에는 차이가 있나요?

### 16\. SQL Injection에 대해 설명해 주세요.

*   그렇다면, 우리가 서버 개발 과정에서 사용하는 수많은 DB 라이브러리들은 이 문제를 어떻게 해결할까요?