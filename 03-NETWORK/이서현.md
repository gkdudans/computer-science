\## 네트워크

### 1\. 쿠키와 세션의 차이에 대해 설명해 주세요.
> - 쿠키와 세션은 HTTP의 Stateless 특성을 보완하기 위해 상태를 유지하는 방식입니다. 쿠키는 클라이언트 저장 방식이라 가볍지만 보안이 약하고, 세션은 서버 저장 방식이라 안전하지만 확장성이 떨어집니다.
>   - 쿠키; 클라이언트, 즉 브라우저에 저장되는 작은 데이터 조각. 서버가 응답 시 Set-Cookie 헤더를 통해 전달하며, 브라우저는 이후 요청마다 Cookie 헤더에 해당 값을 포함해 전송. 쿠키 방식은 서버 부담이 적지만, 데이터가 클라이언트에 그대로 노출되므로 변조나 탈취 위험이 있어 보안이 약하다.
>   - 세션: 서버 측에서 사용자 상태를 관리. 클라이언트는 세션 ID만 쿠키나 URL 파라미터를 통해 전달하고, 실제 데이터는 서버 메모리나 Redis 같은 세션 스토리지에 보관. 세션 방식은 보안성이 높지만 서버 자원을 소모하고, 서버가 여러 대일 경우 세션 동기화나 공유 문제를 해결해야 한다는 단점이 있다.

*   세션 방식의 로그인 과정에 대해 설명해 주세요.
> (1) 사용자가 로그인 요청을 보냄.
> (2) 서버가 사용자 인증에 성공하면 세션 객체를 생성하고, 고유한 세션 ID를 발급.
> (3) 세션 ID를 클라이언트에 쿠키로 저장.
> (4) 이후 요청마다 세션 ID를 포함해 전송하면, 서버가 세션 저장소에서 사용자 정보를 조회해 상태를 복원.


*   HTTP의 특성인 Stateless에 대해 설명해 주세요.
> - HTTP는 Stateless Protocol입니다. 각 요청과 응답은 독립적으로 처리되며, 서버는 이전 요청의 상태를 기억하지 않습니다. 클라이언트가 한 번 요청을 보냈다고 해서, 서버가 그 사용자의 상태나 맥락을 자동으로 보존하지 않는다는 의미입니다.

*   Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
> - HTTP는 Stateless한 프로토콜이기 때문에 본질적으로 상태를 유지하지 않습니다. 따라서 세션 방식은 이 특성에 반하지만, 매번 인증을 요구하면 사용자 경험이 크게 저하될 수 있습니다.
실제 웹/앱 서비스에서는 편의성과 보안성을 위해 서버가 클라이언트의 상태 정보를 세션에 저장하는 방식을 사용하기도 합니다. 

*   규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
> - 서버가 수평 확장-> 각 서버가 세션을 따로 보관하면 불일치가 발생하기 때문에 세션 스티키, 세션 복제, 또는 Redis 같은 외부 저장소가 필요합니다.


### 2\. HTTP 응답코드에 대해 설명해 주세요.

> - HTTP 응답코드는 클라이언트 요청에 대한 서버의 처리 결과를 나타내며, 5가지 클래스로 구분됩니다. 각 응답 코드를 통해 클라이언트는 서버가 요청을 어떻게 처리했는지, 다음에 취해야 할 동작이 무엇인지 알 수 있습니다.
> - 1xx (정보 응답, Informational Responses): 요청을 처리 중임. 클라이언트는 추가적인 요청을 기다려야 합니다.
>   - 100 Continue: 클라이언트가 요청을 계속 진행할 수 있음을 알립니다.
>   - 101 Switching Protocols: 프로토콜 전환이 이루어짐을 알립니다.
> - 2xx (성공 응답, Successful Responses): 요청이 성공적으로 처리됨.
>   - 200 OK: 요청이 정상적으로 처리되었으며 응답 본문에 결과가 포함.
>   - 201 Created: 요청이 성공적으로 처리되었으며, 새로운 리소스가 생성됨.
>   - 202 Accepted: 요청이 성공적으로 수락되었으나 아직 처리되지 않았음.
>   - 204 No Content: 요청이 성공적으로 처리되었으나 응답 본문이 없음.
> - 3xx (리디렉션 응답, Redirection Responses): 클라이언트가 요청한 리소스를 다른 위치에서 찾을 수 있음. 추가 동작(다른 URI 요청)이 필요함.
>   - 301 Moved Permanently: 요청한 리소스가 영구적으로 다른 위치로 이동됨.
>   - 302 Found: 요청한 리소스가 일시적으로 이동되어 다른 위치에 존재함.
>   - 303 See Other: 클라이언트는 다른 URI로 요청을 보내야 함.
>   - 304 Not Modified: 리소스가 수정되지 않았으므로 클라이언트는 캐시된 버전을 사용해도 됨.
> - 4xx (클라이언트 오류, Client Error Responses): 클라이언트 요청에 문제가 있음.
>   - 400 Bad Request: 잘못된 요청이므로 서버가 이해할 수 없음.
>   - 401 Unauthorized: 인증이 필요하거나 잘못된 인증 정보가 제공됨.
>   - 403 Forbidden: 인증은 되었지만 권한 없음.
>   - 404 Not Found: 리소스를 찾을 수 없음.
>   - 405 Method Not Allowed: 요청된 HTTP 메서드가 리소스에서 지원되지 않음.
> - 5xx (서버 오류, Server Error Responses): 서버에서 요청을 처리하는 중에 오류가 발생함.
>   - 500 Internal Server Error: 일반적 서버 오류.
>   - 501 Not Implemented: 요청된 메서드가 서버에서 지원되지 않음.
>   - 502 Bad Gateway: 게이트웨이 또는 프록시 서버 오류.
>   - 503 Service Unavailable: 서버가 일시적으로 과부하되거나 점검 중.
>   - 504 Gateway Timeout: 서버가 다른 서버로부터 응답을 받지 못함. 게이트웨이 시간 초과.

*   401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?
> - 401 Unauthorized: 인증(Authentication)이 필요하지만 제공되지 않았거나, 제공된 자격 증명이 유효하지 않음. → 인증 실패.
> - 403 Forbidden: 인증은 성공했지만 해당 리소스에 접근 권한(Authorization)이 없음. → 권한 부족.

*   200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.
> 200 OK: 요청이 성공적으로 처리됨. 주로 조회(GET) 요청이나 일반 처리 결과 반환 시 사용.
> 201 Created: 요청으로 인해 새로운 리소스가 생성되었음을 의미. RESTful API에서 POST 요청 후 생성된 리소스의 URI를 Location 헤더에 담아 응답하는 것이 일반적.

*   필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.
> 표준 이외의 커스텀 코드로 사용 가능하지만, 클라이언트/라이브러리 호환성과 표준성 측면에서 권장되지 않는다. 대신 200 OK + 커스텀 에러 메시지 바디(JSON) 형태로 정의하는 것이 일반적이다.

### 3\. HTTP Method 에 대해 설명해 주세요.
> - HTTP Method는 클라이언트가 서버 리소스에 대해 **어떤 행위(동작)**를 요청하는지를 표현하는 수단입니다.같은 URI라도 Method에 따라 의미와 처리 방식이 달라집니다. HTTP Method는 단순한 요청 구분이 아니라, RESTful API 설계에서 리소스를 조작하는 표준화된 인터페이스라고 할 수 있습니다.
> 
> - GET: 리소스 조회 (안전, 멱등).
> - POST: 리소스 생성 혹은 처리 요청 (비멱등).
> - PUT: 리소스 전체 교체 (멱등).
> - PATCH: 리소스 일부 수정 (비멱등).
> - DELETE: 리소스 삭제 (멱등).
> - HEAD: 리소스의 메타데이터만 조회.
> - OPTIONS: 서버가 지원하는 메서드 및 CORS 정책 확인.


*   HTTP Method의 멱등성에 대해 설명해 주세요.
> 멱등성이란 같은 요청을 여러 번 반복해도 서버의 최종 상태가 변하지 않는 성질을 말합니다. 이는 서버 자원의 일관성과 안전한 재시도를 보장하는 중요한 개념입니다.

> HTTP Method별 멱등성 여부:
> | Method  | 멱등성 여부 | 설명                                                  |
> |---------|-------------|-------------------------------------------------------|
> | GET     | O           | 조회만 수행 → 서버 상태 변화 없음                     |
> | HEAD    | O           | 응답 헤더만 반환 → 상태 변화 없음                     |
> | PUT     | O           | 동일한 리소스로 전체 교체 → 여러 번 호출해도 결과 동일 |
> | DELETE  | O           | 같은 리소스 삭제 요청 반복 시 최종 상태 동일          |
> | OPTIONS | O           | 서버 지원 메서드 질의용 → 상태 변화 없음             |
> | TRACE   | O           | 요청을 그대로 반환 → 상태 변화 없음                  |
> | POST    | X           | 요청마다 새로운 리소스 생성 가능 → 상태 달라짐        |
> | PATCH   | 보장되지 않음 | 일부 수정이므로 연산 정의에 따라 멱등/비멱등 달라짐     |
> 


*   GET과 POST의 차이는 무엇인가요?
> * GET은 서버의 리소스를 조회할 때 사용하고, 요청 데이터는 URL 쿼리 스트링으로 전달됩니다. 멱등적이고 캐싱이 가능하지만, 데이터가 URL에 노출되기 때문에 보안상 민감 정보에는 적절하지 않습니다.
> * POST는 리소스를 생성하거나 처리할 때 사용하며, 데이터가 HTTP Body에 담겨 전송됩니다. 비멱등적이고 기본적으로 캐싱되지 않으며, GET보다 보안상 안전하지만 반드시 HTTPS를 통해 보호하는 것이 중요합니다.

*   POST와 PUT, PATCH의 차이는 무엇인가요?
> * POST는 주로 새로운 리소스를 생성하거나 서버에 어떤 동작을 요청할 때 사용합니다. 비멱등이기 때문에 같은 요청을 여러 번 보내면 리소스가 중복 생성될 수 있습니다.
> * PUT은 특정 리소스를 전체 교체하는 용도로 쓰이며, 멱등적이라 동일한 요청을 반복해도 결과가 변하지 않습니다.
> * PATCH는 리소스의 일부만 수정하는 데 사용되고, 부분 업데이트를 지원한다는 점에서 PUT과 구분됩니다. 멱등성이 보장되지 않습니다.

*   HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?

### 4\. HTTP에 대해 설명해 주세요.

*   공개키와 대칭키에 대해 설명해 주세요.

*   왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?
> HTTPS Handshake에서 인증서는 신원 검증과 보안 채널 수립을 동시에 달성하기 위한 장치입니다. 두 가지 핵심 이유가 있습니다.
첫째, 서버가 주장하는 도메인이 실제로 신뢰할 수 있는 주체임을 보장합니다. 인증서는 공인된 CA의 서명을 통해 위조 여부를 검증할 수 있기 때문에 중간자 공격을 방지합니다.
둘째, 안전한 키 교환을 가능하게 합니다. 클라이언트는 인증서에 포함된 서버의 공개키를 사용해 세션키를 안전하게 전달하고, 이후에는 성능이 좋은 대칭키 암호화를 사용해 통신합니다.

*   SSL과 TLS의 차이는 무엇인가요?

### 5\. 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.
> - 소켓은 네트워크 상에서 프로세스 간 통신을 위한 프로그래밍 인터페이스(API)로, 운영체제에서 제공하는 네트워크 통신의 추상화된 개념입니다.
> - 웹소켓은 HTTP를 기반으로 하는 양방향 통신 프로토콜로, 웹 브라우저와 서버 간 실시간 통신을 위해 설계된 웹 표준입니다.

*   소켓과 포트의 차이가 무엇인가요?
> - 포트는 하나의 호스트 내에서 여러 네트워크 서비스나 프로세스를 구분하기 위한 논리적 주소입니다.
> - 소켓은 네트워크 통신의 끝점(endpoint)으로, IP 주소와 포트 번호의 조합으로 구성되는 통신 인터페이스입니다.

*   여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?
> 포트 번호는 하나의 호스트내에서 고유하지만, 하나의 프로세스는 여러 개의 소켓을 열 수 있으므로 같은 IP, 같은 포트수를 가지고 있다 하더라도 여러 개의 소켓이 존재할 수 있습니다. 이에 따라 여러 소켓의 포트 번호가 같을 수 있습니다.
포트 번호가 같은 예시: 온라인 게임 서버는 수천 명의 플레이어가 동시에 서버에 접속하지만, 서버의 동일한 포트에서 접속한다. 게임 서버는 각 플레이어와의 연결을 별도의 소켓으로 관리한다.

*   사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?
> - 사용자의 요청이 증가함에 따라 서버가 처리해야 하는 소켓도 증가한다. 다만 고려 사항이 있다.
> - 각 클라이언트 요청은 일반적으로 소켓을 생성하지만, 서버는 동시에 처리할 수 있는 소켓의 수에 제한이 있다. 따라서 대규모로 사용자 요청이 증가하는 경우, 서버는 소켓 풀링, 비동기 처리, 로드 밸런싱(부하 분산)과 같은 기술을 사용하여 효율적으로 요청을 처리하고 리소스를 관리해야 한다.

### 6\. HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?
> - **HTTP/1.1**
>   - 연결당 단일 요청: 하나의 TCP 연결에서 하나의 요청과 응답만을 처리합니다. 따라서 페이지의 여러 리소스를 요청할 경우, 각각의 요청에 대해 별도의 연결을 열어야 하므로 성능에 제한이 있습니다.
>   - HOL(Head-of-Line) Blocking: 요청은 순차적으로 처리되므로, 앞선 요청이 지연되면 뒤의 모든 요청도 대기하게 되는 문제가 발생합니다.
>   - 헤더 비효율성: 각 요청마다 같은 헤더를 반복적으로 보내야 하며, 이는 데이터 낭비를 초래합니다.

> - **HTTP/2**
>   - 멀티플렉싱: 하나의 TCP 연결에서 여러 요청과 응답을 동시에 처리합니다. 애플리케이션 계층에서의 HOL Blocking을 해결하여 성능을 크게 향상시킵니다.
>   - 헤더 압축: HPACK 압축 방식을 사용하여 요청과 응답 헤더를 효율적으로 압축, 효율성을 높입니다.
>   - 서버 푸시: 서버는 클라이언트의 요청 없이도 필요한 리소스를 미리 전송할 수 있어 페이지 로딩 속도를 개선합니다.

*   HOL Blocking 에 대해 설명해 주세요.
> - HOL (Head-of-line) Blocking은 데이터 패킷 전송 시 앞에 있는 패킷이 처리되지 않으면 뒤의 패킷도 처리되지 않는 현상입니다. HTTP/1.1에서는 하나의 연결에서 요청이 순차적으로 처리되기 때문에, 하나의 요청이 대기 중일 경우 나머지 요청도 모두 대기 상태에 빠지게 됩니다.
> - HTTP/2이 지원하는 멀티플렉싱 기능은 한 연결에서 여러 요청을 병렬로 처리할 수 있기 때문에 애플리케이션 레벨에서 HOL Blocking 문제를 해결합니다. 하지만 TCP 프로토콜 특성상 Transport Layer에서는 HOL Blocking이 발생합니다. HTTP/3.0은 이를 QUIC을 통해 해결했습니다.

*   HTTP/3.0의 주요 특징에 대해 설명해 주세요.
> - HTTP/3.0은 QUIC(Quick UDP Internet Connections) 프로토콜을 기반으로 만들어졌습니다.
>   - UDP 기반: QUIC은 TCP를 대체하는 범용 목적으로 개발된 4계층 통신 프로토콜로, UDP 위에서 동작합니다. TCP의 3-way handshake를 생략하고, 0-RTT(Round Trip Time) 연결을 지원하여 연결 설정 시간을 크게 단축합니다.
>   - 0-RTT 연결: 첫 연결 시 데이터를 즉시 전송할 수 있습니다.
>   - HOL Blocking 해결: HTTP/2가 해결하지 못했던 TCP 계층에서의 HOL Blocking 문제를 해결합니다. QUIC은 패킷 손실 시 해당 스트림(stream)만 영향을 받고, 다른 스트림은 정상적으로 작동합니다.
>   - 강화된 보안: QUIC은 TLS 1.3을 내장하고 있어 보안성이 향상되었습니다.

### 7\. TCP와 UDP의 차이에 대해 설명해 주세요.
> * TCP:
>   - 연결 지향: 3-way handshake를 통한 연결 설정, 4-way handshake를 통한 연결 해제
>   - 신뢰성 보장: 순서 보장, 오류 검출 및 재전송, 중복 제거
>   - 흐름 제어: 수신자의 처리 능력에 맞춰 전송 속도 조절
>   - 혼잡 제어: 네트워크 상황에 따른 전송량 조절
>   - 전이중 통신: 양방향 동시 데이터 전송
>   - 사용 예: HTTP/HTTPS, FTP, SMTP 등
> * UDP (User Datagram Protocol):
>   - 비연결 지향: 연결 설정 없이 즉시 데이터 전송
>   - 신뢰성 미보장: 순서 보장 없음, 오류 검출만 수행(재전송 없음)
>   - 빠른 전송: 오버헤드가 적어 실시간성 중요한 애플리케이션에 적합
>   - 단순한 구조: TCP 대비 헤더 크기가 작음(8바이트 vs 20바이트)
>   - 사용 예: DNS, DHCP, 실시간 스트리밍, 온라인 게임 등

*   Checksum이 무엇인가요?
> - 체크섬(Checksum)은 데이터 전송 중 발생할 수 있는 오류를 검출하기 위한 방식입니다. 송신자는 데이터를 전송할 때 해당 데이터를 일정한 방식으로 계산하여 체크섬 값을 생성하고, 수신자는 이 체크섬을 이용해 데이터가 올바르게 전송되었는지 확인합니다.

*   TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?
> - TCP와 UDP 모두 Checksum을 수행합니다. TCP에서는 필수적이고, UDP는 선택적입니다. UDP에서 checksum을 쓰지 않는다면, checksum 부분을 전부 0으로 체웁니다.

*   그렇다면, Checksum을 통해 오류를 정정할 수 있나요?
> Checksum은 오류 발생 여부만 확인할 수 있다. 오류를 정정할 수 없고, 오류가 검출되면 송신 측에 재전송을 요청해 오류를 처리합니다.

*   TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.
> - 세그먼트 번호: 데이터의 순서를 보장합니다.
> - 확인 응답(ACK): 송신자는 데이터를 전송한 후, 수신자가 해당 데이터를 받았다는 확인을 보냅니다.
> - 재전송: 응답이 오지 않으면 일정 시간 후 데이터를 재전송합니다.
> - 흐름 제어: 수신자의 버퍼가 오버플로우하지 않도록 데이터 전송 속도를 조절합니다.
> - 혼잡 제어: 네트워크가 혼잡할 때 전송 속도를 조절하여 혼잡을 피합니다.

*   TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.
> 슬로우 스타트(Slow Start), 혼잡 회피(Congestion Avoidance), 빠른 재전송(Fast Retransmit), 빠른 회복(Fast Recovery)

*   왜 HTTP는 TCP를 사용하나요?
> HTTP는 웹 브라우저와 서버 간에 오류 없이 완전한 정보를 주고받아 웹 페이지를 정상적으로 표시하기 위해 TCP를 사용합니다. TCP는 연결 지향적이며 오류를 검출하고 수정할 수 있는 기능을 제공하며, 데이터가 순서대로 정확하게 전달되도록 보장합니다. 만약 신뢰성이 보장되지 않는 UDP를 사용한다면 웹 페이지의 일부 이미지가 깨지거나 아예 표시되지 않는 문제가 발생할 수 있습니다.

*   그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?
> - QUIC은 UDP를 기반으로 TCP의 장점을 자체적으로 구현해 UDP의 문제를 일부 해결한 프로토콜입니다.
>   - UDP는 데이터 전송의 신뢰성을 보장하지 않지만, QUIC은 패킷의 순서를 보장하고 손실된 패킷을 재전송하는 기능을 자체적으로 내장하여 TCP와 유사한 신뢰성을 확보합니다.
>   - QUIC은 TCP처럼 수신자의 처리 능력과 네트워크 상황에 따라 데이터 전송량을 조절하는 흐름 제어 및 혼잡 제어 메커니즘을 가지고 있습니다.
>   - QUIC은 TLS 1.3 암호화를 프로토콜 계층에 통합하여 보안을 강화했습니다.
> - HTTP/3에서 QUIC 사용의 장점
>   - 연결 설정 시간 단축: HTTP/3는 UDP 기반의 QUIC을 사용해 TCP의 3-way handshake를 건너뛰고, 첫 연결 시 0-RTT로 데이터를 즉시 보낼 수 있어 연결 설정 오버헤드가 크게 줄어듭니다.
>   - HOL Blocking 해결: QUIC은 여러 스트림을 독립적으로 관리합니다. 특정 스트림의 패킷이 유실되어도 다른 스트림은 영향을 받지 않고 통신을 계속할 수 있어 TCP의 HOL Blocking 문제를 해결합니다.

*   그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?
> - 브라우저가 어떤 프로토콜(TCP 또는 UDP)을 사용하는지 파악하는 과정은 "Alt-Svc 헤더"를 통해 이루어집니다.
> - 1단계: 초기 TCP 연결 시도
>   - 브라우저의 기본값: 브라우저는 기본적으로 신뢰성이 보장되는 TCP를 사용하여 서버와 통신합니다. 이 때문에 HTTP/1.1이나 HTTP/2 요청을 보낼 때 TCP 소켓을 생성합니다. 
> - 2단계: 서버의 프로토콜 지원 정보 확인
>   - Alt-Svc 헤더: 서버가 HTTP/3를 지원한다면, 첫 번째 응답에 Alt-Svc 헤더를 포함하여 "나는 HTTP/3를 지원하니, 다음부터는 이 주소로 UDP를 사용해 통신해도 좋다"고 브라우저에게 알려줍니다.
>   - 예시: Alt-Svc: h3=":443"와 같은 형태로, HTTP/3(h3) 프로토콜을 UDP의 443 포트에서 사용할 수 있음을 알려줍니다.
> - 3단계: 프로토콜 전환
>   - 정보 캐싱: 브라우저는 이 정보를 캐시에 저장합니다.
>   - 다음 연결: 이후 해당 서버에 다시 접속할 때는 저장된 정보를 바탕으로 UDP 소켓을 열어 HTTP/3(QUIC) 프로토콜로 통신을 시도합니다.
> 
> 결론적으로, 브라우저는 먼저 TCP로 연결을 시도한 후, 서버로부터 받은 Alt-Svc 헤더 정보를 통해 UDP로 프로토콜을 전환하는 방식으로 통신합니다. 이 과정은 소켓 통신을 기반으로 이루어지며, 브라우저가 TCP 소켓을 사용할지 UDP 소켓을 사용할지를 결정하는 데 중요한 역할을 합니다.

*   본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?
> 프로토콜을 선택할 때 중요한 기준은:
> - 신뢰성: 데이터의 정확한 전달이 필요한 경우 TCP를 사용합니다.
> - 속도: 빠른 전송 속도가 필요한 경우 UDP를 사용합니다.
> - 연결 설정 및 유지: 연결 설정을 최소화하고자 하면 UDP가 유리할 수 있습니다.
> - 애플리케이션의 특성: 실시간 스트리밍, 게임 등에서는 UDP가 선호될 수 있고, 파일 전송, 웹 페이지 요청 등에서는 TCP가 필요합니다.

### 8\. DHCP가 무엇인지 설명해 주세요.
> - DHCP는 네트워크상의 호스트들에게 IP 주소 및 네트워크 구성 정보를 자동으로 할당하는 네트워크 서비스 프로토콜입니다.
> * 주요 기능:
>   - 자동 IP 주소 할당: 사용 가능한 IP 주소 풀에서 클라이언트에게 동적 할당
>   - 네트워크 설정 제공: 서브넷 마스크, 기본 게이트웨이, DNS 서버 주소 등 설정 정보 전달
> - 주소 임대 관리: IP 주소 사용 기간(lease time) 관리 및 갱신
> * DHCP 동작 과정 (DORA 프로세스):
>   - Discover: 클라이언트가 브로드캐스트로 DHCP 서버 탐색
>   - Offer: DHCP 서버가 사용 가능한 IP 주소와 설정 정보 제안
>   - Request: 클라이언트가 특정 서버의 제안을 선택하여 요청
>   - Acknowledge: 서버가 IP 주소 할당을 확정하고 임대 정보 전송

*   DHCP는 몇 계층 프로토콜인가요?
> - DHCP는 애플리케이션 계층 프로토콜입니다. 네트워크에서 IP 주소를 동적으로 할당하는 프로토콜로, 보통 UDP를 사용하여 동작합니다.

*   DHCP는 어떻게 동작하나요?
> - DHCP Discover: 클라이언트는 DHCP 서버를 찾기 위해 브로드캐스트 메시지를 보냅니다.
> - DHCP Offer: 서버는 사용 가능한 IP 주소를 제시하며 응답합니다.
> - DHCP Request: 클라이언트는 서버에 IP 주소 할당을 요청합니다.
> - DHCP Acknowledge: 서버는 요청을 승인하고, 클라이언트에게 IP 주소를 할당합니다.

*   DHCP에서 UDP를 사용하는 이유가 무엇인가요?
> - 연결 지향적이지 않은 프로토콜이기 때문에 UDP를 사용합니다. UDP는 빠르고 간단한 통신을 제공하며, 연결을 설정할 필요가 없으므로 효율적입니다.

*   DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요?
> - 서브넷 마스크, 기본 게이트웨이, DNS 서버 등의 네트워크 설정 정보를 제공합니다.

*   DHCP의 유효기간은 얼마나 긴가요?
> - DHCP 유효기간(임대 기간)은 DHCP 서버에 의해 설정되며, 일반적으로 24시간에서 몇 일 정도로 설정됩니다. 클라이언트는 주기적으로 IP 주소 갱신을 요청할 수 있습니다.

### 9\. IP 주소는 무엇이며, 어떤 기능을 하고 있나요?
> - IP(Internet Protocol Address) 주소는 네트워크 상에서 장치나 호스트를 식별하는 고유한 숫자 주소입니다.
> - 주요 기능:
>   - 장치 식별: 네트워크상의 각 호스트를 유일하게 구분
>   - 라우팅: 데이터 패킷이 목적지까지 전달될 수 있도록 경로 정보 제공
>   - 네트워크 계층화: 네트워크 부분과 호스트 부분으로 구분하여 효율적인 주소 관리

*   IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요?
> - IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 설계되었으며, 주소 공간이 거의 무한에 가까운 크기를 제공합니다. 그러나 IPv4와 IPv6의 호환성 문제, 기존 인프라의 전환 비용 등으로 인해 여전히 IPv4가 널리 사용되고 있습니다. NAT(Network Address Translation)와 같은 기술을 통해 IPv4 주소 고갈을 완화할 수 있으며, IPv6로의 전환을 촉진하는 것이 중요합니다.

*   IPv4와 IPv6의 차이에 대해 설명해 주세요.
> 1. 주소 및 헤더 구조
> - IPv4: 32비트 주소 체계로, 헤더는 기본적으로 20바이트 크기이며, 옵션 필드에 따라 최대 60바이트까지 확장됩니다. 헤더에는 TTL(Time to Live), Checksum, Options 등 다양한 필드가 포함되어 있습니다.
> - IPv6: 128비트 주소 체계로, 헤더는 고정된 40바이트 크기입니다. 단순하고 효율적인 라우팅을 위해 Checksum 필드가 제거되었고, TTL은 Hop Limit으로 이름이 바뀌었습니다.
> 2. 주소 자동 설정
> - IPv4: IP 주소는 DHCP 서버를 통해 수동 또는 동적으로 할당받아야 합니다.
> - IPv6: SLAAC(Stateless Address Autoconfiguration) 기능을 통해 별도의 서버 없이도 자동으로 IP 주소를 설정할 수 있습니다. 이는 IoT(사물 인터넷) 기기에 IP 주소를 할당하는 데 매우 효율적입니다.
> 3. 보안
> - IPv4: 보안 기능인 IPsec이 필수가 아닌 선택 사항이었습니다.
> - IPv6: IPsec이 프로토콜 자체에 내장되어 있어, 모든 IPv6 통신은 기본적으로 종단 간 암호화 및 인증을 지원하여 보안성이 향상됩니다.
> 4. 기타 특징
> - 단편화 (Fragmentation):
>   - IPv4: 라우터에서 패킷을 단편화할 수 있습니다. 이는 중간 라우터에 부담을 주어 네트워크 성능을 저하시킵니다.
>   - IPv6: 패킷 단편화는 송신자에서만 가능하며, 라우터는 단편화를 수행하지 않습니다. 이는 라우터의 부담을 줄여 라우팅 속도를 높입니다.
> - 모바일 지원:
>   - IPv4: 모바일 기기의 이동성을 지원하는 기능이 별도로 없습니다.
>   - IPv6: 모바일 IPv6를 지원하여 모바일 기기가 네트워크를 옮겨 다녀도 기존 연결을 유지할 수 있도록 돕습니다.

*   수많은 사람들이 유동 IP를 사용하고 있지만, 수많은 공유기에서는 고정 주소를 제공하는 기능이 이미 존재합니다. 어떻게 가능한 걸까요?
> - 유동 IP는 ISP에서 할당하는 임시 주소이지만, 고정 IP는 사용자가 요청하면 지속적으로 같은 주소를 제공하는 방식입니다. 공유기에서는 DHCP 서버를 통해 내부 네트워크에서 고정 주소를 설정할 수 있습니다. 이는 특정 장치에 대해 고정 IP를 할당하는 방식으로 작동합니다.

*   IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요?
> - IPv4와 IPv6는 기본적으로 호환되지 않지만, IPv6-to-IPv4 변환 기술이나 터널링을 통해 통신할 수 있습니다. Dual Stack 방식으로 동일한 장비가 IPv4와 IPv6 주소를 모두 지원하면 두 프로토콜 간의 통신이 가능합니다.

*   IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요?
> - IP는 데이터의 전송 경로를 지정할 수 있지만, 전송이 완료되는지, 정확한 순서로 도달하는지를 보장하지 않습니다. 이를 보장하는 것은 TCP 프로토콜입니다.

*   IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?
> - IPv4 체크섬
>   - 검증 대상: IPv4 헤더만을 대상으로 합니다. 데이터 페이로드(payload)는 포함하지 않습니다.
>   - 역할: 라우터가 패킷을 처리하는 동안 헤더에 오류가 발생했는지 확인하는 데 사용됩니다. TTL(Time to Live) 값이 변경될 때마다 재계산되어야 하므로, 빠른 처리를 위해 간단한 알고리즘을 사용합니다.
> - TCP 체크섬
>   - 검증 대상: TCP 헤더와 데이터 페이로드를 모두 포함합니다.
>   - 역할: 종단 간(end-to-end) 신뢰성을 보장하기 위해 사용됩니다. 패킷이 출발지에서 목적지까지 전송되는 동안 데이터가 손상되지 않았는지 확인합니다. TCP는 IP 헤더의 변경 여부와 상관없이 데이터의 무결성만을 검증합니다.

*   TTL(Hop Limit)이란 무엇인가요?
> - TTL(Time to Live)은 패킷이 네트워크를 통과할 수 있는 최대 홉 수를 지정합니다. TTL 값이 0이 되면 패킷은 폐기됩니다.

*   IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.
> - IP 주소는 네트워크에서 논리적이고 라우팅 가능한 주소입니다. MAC 주소는 물리적이고 고유한 장치 식별자입니다. IP 주소는 네트워크에서 통신을 위해 사용되며, MAC 주소는 로컬 네트워크에서 장치를 식별하는 데 사용됩니다.

### 10\. OSI 7계층에 대해 설명해 주세요.
> - OSI(Open Systems Interconnection) 7계층은 국제 표준화 기구(ISO)에서 개발한 컴퓨터 네트워크 프로토콜 모델입니다. 이 모델은 네트워크 통신 과정을 7개의 계층으로 분리하여 각 계층이 특정 기능을 수행하도록 하는 것을 목적으로 합니다.

> | 계층 | 계층명 (영문) | 주요 기능 | 대표 프로토콜 |
> | :---: | :---: | :--- | :--- |
> | **7** | **응용 계층** (Application Layer) | 사용자 서비스 및 응용프로그램의 네트워크 접속 지원 | **HTTP**, FTP, SMTP, DNS, SSH |
> | **6** | **표현 계층** (Presentation Layer) | 데이터 형식 변환, 암호화/복호화, 압축 | JPEG, MPEG, SSL, TLS |
> | **5** | **세션 계층** (Session Layer) | 통신 세션 관리, 연결 설정 및 해제, 동기화 | NetBIOS, RPC, NFS |
> | **4** | **전송 계층** (Transport Layer) | 종단 간(End-to-End) 신뢰성 있는 데이터 전송, 포트 관리 (패킷 분할 및 재조립) | **TCP**, **UDP** |
> | **3** | **네트워크 계층** (Network Layer) | 패킷을 목적지까지 전달, 경로 선택(라우팅), 논리적 주소(IP) 지정 | **IP**, ICMP, ARP, RARP |
> | **2** | **데이터 링크 계층** (Data Link Layer) | 같은 네트워크(LAN) 내 데이터 교환, 물리적 주소(MAC) 지정, 프레이밍 | Ethernet, Token Ring, HDLC |
> | **1** | **물리 계층** (Physical Layer) | 물리적 연결 제공, 전기/빛 신호로 데이터 전송 | RS-232C, V.35, 케이블 표준 |

*   Transport Layer와, Network Layer의 차이에 대해 설명해 주세요.

> **L3 네트워크 계층**은 패킷이 어디(IP 주소)로 가야 하는지 길을 찾아줍니다.
> **L4 전송 계층**은 그 패킷이 도착한 컴퓨터 내의 어떤 프로그램(Port 번호)으로 전달되어야 하며, 데이터가 유실 없이 완전하게 전달되었는지 (TCP의 경우) 관리합니다.
>
> | 구분 | Transport Layer (L4) | Network Layer (L3) |
> | :---: | :---: | :---: |
> | 통신 목표 | 프로세스 대 프로세스 (Port to Port) | 호스트 대 호스트 (Host to Host) |
> | 주소 체계 | Port Number (포트 번호) | IP Address (논리적 주소) |
> | 핵심 역할 | 종단 간 신뢰성 및 흐름 제어 | 경로 선택 (라우팅) 및 논리적 전달 |
> | 대표 프로토콜 | TCP, UDP | IP, ICMP, ARP |
> 

*   L3 Switch와 Router의 차이에 대해 설명해 주세요.

> - 라우터는 네트워크 간 통신(Inter-network), 특히 인터넷이나 원거리망(WAN) 연결에 최적화되어 복잡한 정책 처리 및 보안 기능에 강합니다.
> - L3 스위치는 주로 기업 내부망과 같은 단일 네트워크 범위(Intra-network) 내에서 대용량 트래픽을 매우 빠르게 처리(스위칭 및 라우팅)하는 데 중점을 둡니다.

> | 구분 | Router (라우터) | L3 Switch (L3 스위치) |
> | :---: | :---: | :---: |
> | 주요 활용 | 서로 다른 네트워크 간 연결 (WAN) | 동일 네트워크 내부 고속 라우팅 (LAN) |
> | 라우팅 방식 | 소프트웨어 기반 (CPU) 및 복잡한 경로 결정 | 하드웨어 기반 (ASIC 칩) 및 고속 포워딩 |
> | 기능 | NAT, VPN, QoS 등 광범위한 기능 지원 | L2 스위칭 및 기본 라우팅 기능에 집중 |
> | 처리 속도 | 상대적으로 느릴 수 있음 | Wire Speed (회선 속도)에 가까운 고속 처리 |

*   각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.

> OSI 7 계층에서 각 계층이 처리하는 데이터 단위를 **PDU**(Protocol Data Unit)라고 합니다.

> | 계층 번호 | 계층명 | PDU 명칭 (전송 단위) |
> | :---: | :---: | :---: |
> | 7, 6, 5 | 응용, 표현, 세션 | Data (데이터) 또는 Message (메시지) |
> | 4 | 전송 | Segment (세그먼트) / Datagram (데이터그램) |
> | 3 | 네트워크 | Packet (패킷) |
> | 2 | 데이터 링크 | Frame (프레임) |
> | 1 | 물리 | Bit (비트) |

*   각각의 Header의 Packing Order에 대해 설명해 주세요.

> 데이터가 상위 계층에서 하위 계층으로 이동하면서 각 계층의 정보를 추가하는 과정을 **캡슐화**라고 하며, 이 순서가 바로 Header Packing Order입니다.
데이터는 **안쪽, 가장 먼저 출발한 데이터**에서 **바깥쪽, 가장 마지막에 추가된 헤더**으로 포장됩니다.

> - L7/6/5 (데이터): 응용 프로그램 데이터.
> - L4 Header (전송 계층 헤더): L4 헤더(TCP/UDP)가 데이터에 붙어 세그먼트/데이터그램을 형성합니다. (Port 정보 포함)
> - L3 Header (네트워크 계층 헤더): L3 헤더(IP)가 세그먼트/데이터그램에 붙어 패킷을 형성합니다. (IP 주소 정보 포함)
> - L2 Header/Trailer (데이터 링크 계층 헤더/트레일러): L2 헤더(MAC 주소 정보)가 패킷 앞에, L2 트레일러(오류 검출용)가 패킷 뒤에 붙어 프레임을 형성합니다.
> - 프레임=[L2 Header]+[L3 Header]+[L4 Header]+[Data]+[L2 Trailer]
> - 이 프레임이 **L1 물리 계층**을 통해 비트 단위로 변환되어 전송됩니다. 수신 측에서는 이 과정을 역순으로 진행하며 각 계층의 헤더를 제거하고 데이터를 추출합니다(=역캡슐화, Decapsulation).

> | 순서 | 작업 | 결과 데이터 단위 | 포함되는 헤더 정보 |
> | :---: | :---: | :---: | :---: |
> | 시작 | 응용 계층 데이터 | Data | (없음) |
> | 1 | L4 헤더 추가 | Segment (or Datagram) | Port Number |
> | 2 | L3 헤더 추가 | Packet | IP Address (Source/Destination) |
> | 3 | L2 헤더/트레일러 추가 | Frame | MAC Address (Source/Destination) |
> | 최종 | L1 비트 변환 | Bit | (물리 신호) |
> 
*   ARP에 대해 설명해 주세요.

> - ARP(Address Resolution Protocol, 주소 결정 프로토콜)는 네트워크 계층(L3)의 IP 주소를 데이터 링크 계층(L2)의 MAC 주소(물리적 주소)로 변환하기 위해 사용되는 프로토콜입니다.
> - 네트워크 통신이 다른 네트워크로 전달되려면 L3 주소(IP)가 필요하지만, 실제 물리적인 통신 매체(LAN 케이블 등)를 통해 데이터를 전달할 때는 반드시 L2 주소(MAC)가 필요합니다. 따라서 ARP는 IP 주소를 알고 있을 때, 실제 통신을 위한 MAC 주소를 알아내는 역할을 합니다.
> - ARP 동작 과정 (동일 네트워크 내)
>   - 요청 (ARP Request): 발신지 컴퓨터는 목적지 IP 주소를 알고 있지만 MAC 주소를 모를 때, ARP Request 메시지를 브로드캐스트(Broadcast) 합니다. (예: "IP 주소 192.168.1.100을 가진 컴퓨터야, 너의 MAC 주소는 뭐니?")
>   - 응답 (ARP Reply): 해당 IP 주소를 가진 컴퓨터만 이 요청을 받고, 자신의 MAC 주소를 담아 발신지 컴퓨터에게 **유니캐스트**(Unicast)로 응답합니다.
>   - 캐싱 (Caching): 발신지 컴퓨터는 이 MAC 주소 정보를 **ARP 캐시**에 일정 시간 저장하여, 다음 통신 시 요청 과정 없이 바로 MAC 주소를 사용합니다.

> | 구분 | 내용 |
> | :---: | :--- |
> | 목적 | IP 주소를 MAC 주소로 변환 (주소 결정) |
> | 사용 계층 | Network Layer (L3) 프로토콜로 분류되나 L2/L3 경계에서 동작 |
> | 요청 방식 | ARP Request는 로컬 네트워크 전체에 브로드캐스트 |
> | 응답 방식 | ARP Reply는 요청한 호스트에게 유니캐스트 |
> | 저장소 | 변환된 정보는 ARP 캐시(Cache)에 저장 후 재사용 |

### 11\. 3-Way Handshake에 대해 설명해 주세요.

> - 3-Way Handshake는 TCP(Transmission Control Protocol) 통신을 시작하기 위해 클라이언트와 서버가 서로 연결을 설정하는 과정으로, 신뢰성 있는 연결을 구축하는 데 필수적입니다. 이 과정은 세 단계의 패킷 교환을 통해 이루어집니다.
> 
> 1. 첫 번째 단계 (SYN): 클라이언트 → 서버
> -   클라이언트가 서버에 연결을 요청하면서 SYN(synchronize) 플래그를 보냅니다.
> -   이때 클라이언트는 **초기 시퀀스 번호(ISN)**를 포함시킵니다.
> 
> 2. 두 번째 단계 (SYN + ACK): 서버 → 클라이언트
> -   서버는 요청을 수락하며, 자신도 연결을 시작하겠다는 의미로 SYN을 보냅니다.
> -   동시에 클라이언트의 SYN에 대한 응답으로 ACK를 보냅니다.
> -   즉, SYN + ACK 패킷을 보냅니다.
> 
> 3. 세 번째 단계 (ACK): 클라이언트 → 서버
> -   클라이언트는 서버의 SYN을 수락했다는 의미로 ACK를 보냅니다.
> -   이 시점에서 연결이 정상적으로 성립됩니다.


*   ACK, SYN 같은 정보는 어떻게 전달하는 것일까요?
> - TCP 헤더(Header) 내의 1비트짜리 '플래그' 필드에 포함되어 전달됩니다. TCP 헤더에는 여러 1비트 플래그 필드가 있습니다. 특정 플래그 필드의 해당 비트가 1로 설정되면, 해당 패킷이 SYN 요청이나 ACK 응답과 같은 특정 제어 기능을 수행함을 의미합니다.
> - 주요한 것들:
>   - SYN: 동기화 요청 (연결 시작)
>   - ACK: 승인 응답 (수신 확인)
>   - FIN: 연결 종료 요청
>   - RST: 비정상적인 연결 리셋
>   - URG, PSH 등 (참고: https://mindgear.tistory.com/206)

*   2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.
> - 2-Way Handshake만으로는 신뢰성 있는 연결을 보장할 수 없으며, 특히 이전 연결에서 지연된 패킷으로 인해 혼란이 발생할 수 있습니다.
>   - 지연된 SYN 문제: 클라이언트가 과거에 보냈던 SYN 패킷이 네트워크 혼잡 등으로 인해 지연되었다가 뒤늦게 서버에 도착했다고 가정해 봅시다.
>   1. [1st Way] 지연된 SYN 도착 (클라이언트 C1이 보낸 과거 SYN)
>   2. [2nd Way] 서버는 이를 새 연결 요청으로 오해하고 ACK를 클라이언트에게 보냅니다.
>   - 만약 여기서 연결이 완료된다면, 서버는 이미 종료된 연결의 유효하지 않은 SYN을 기반으로 연결을 설정하게 됩니다. 서버는 데이터를 전송하기 시작하지만, 클라이언트는 이 ACK가 과거의 요청에 대한 응답임을 알고 데이터를 무시하거나 오류를 발생시킵니다.
>   - 3-Way Handshake의 세 번째 ACK는 클라이언트가 서버의 SYN+ACK에 대해 **"이 연결이 유효하고, 이제부터 데이터를 주고받을 준비가 되었다"**는 최종적인 확인을 제공하여, 이러한 혼란을 방지하고 양방향 통신이 가능한 상태임을 상호 확인하는 데 필수적입니다.


*   두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?
> - 두 호스트가 동시에 연결을 시도해도 연결은 가능합니다. 이 과정을 동시 오픈, Simultaneous Open이라고 합니다.
>   - [Step 1] 호스트 A와 B가 동시에 서로에게 SYN 패킷을 전송합니다.
>   - [Step 2] A는 B로부터 SYN을 받고, B는 A로부터 SYN을 받습니다. 각 호스트는 상대방의 SYN에 응답하기 위해 SYN + ACK를 생성하여 상대방에게 전송합니다.
>   - [Step 3] A는 B의 SYN + ACK를 받고, B는 A의 SYN + ACK를 받습니다. 이 시점에서 각 호스트는 상대방의 SYN을 승인했기 때문에 연결이 완료됩니다.
>   - 동시 오픈 시에는 일반적인 3단계가 아닌 4단계를 통해 연결이 확립되지만, 최종적으로 두 호스트 모두 연결을 설정했다는 "Establish" 상태가 되며 정상적으로 통신을 수행할 수 있습니다.

*   SYN Flooding에 대해 설명해 주세요.
>   - SYN Flooding은 3-Way Handshake의 취약점을 악용한 대표적인 DoS(Denial of Service, 서비스 거부) 공격입니다.
>     - 원리: 공격자는 존재하지 않거나 도달 불가능한 가짜 IP 주소를 사용하여 서버에 대량의 SYN 요청을 보냅니다.
>     - 서버 반응: 서버는 각 SYN 요청에 대해 SYN + ACK를 보내고, 클라이언트의 최종 ACK를 기다리는 상태인 "SYN_RECV" 상태로 들어갑니다.
>     - 문제 발생: 공격자가 보낸 IP 주소는 가짜이므로, 서버는 절대 최종 ACK를 받을 수 없습니다. 서버는 이 상태에서 대기하며 **연결 대기 큐(Backlog Queue)**의 자원을 계속해서 점유합니다.
>     - 결과: 대량의 SYN 요청이 큐를 가득 채우게 되면, **정상적인 사용자의 연결 요청(SYN)**은 처리되지 못하고 드롭(Drop)되어, 서버의 서비스가 마비되는 결과를 초래합니다.



*   위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?
> - 0-RTT(Zero-Round Trip Time) 연결은 이전에 TLS 연결을 맺었던 클라이언트가 서버에 처음 데이터를 보내면서, 이전 세션에서 얻은 사전 공유 키(PSK) (Pre-Shared Key) 또는 세션 티켓을 사용해 핸드셰이크 과정 없이 즉시 애플리케이션 데이터를 암호화하여 전송하는 방식입니다. 
> - 이 방식은 연결 속도를 크게 향상시키지만, 이전 데이터가 재전송될 수 있는 재생 공격(Replay Attack)에 취약하므로, 클라이언트와 서버가 0-RTT 사용에 동의하고 재사용되는 데이터에 대한 보안을 강제해야 합니다. 

> 1. TCP Fast Open (TFO)
> - TFO는 TCP 연결 수립 단계의 지연을 줄이는 기법입니다.
> - 기본 원리: TFO는 서버가 발급한 보안 쿠키를 사용하여 클라이언트를 검증하고, 클라이언트가 SYN 패킷에 HTTP 요청 데이터를 함께 실어 보내도록 허용합니다.
> - 동작 과정:
>   - 첫 연결 (쿠키 발급): 클라이언트와 서버는 일반적인 3-Way Handshake를 수행합니다. 이때 서버는 클라이언트의 IP 주소를 기반으로 암호화된 TFO 쿠키를 생성하여 클라이언트에게 발급합니다.
>   - 재연결 (0-RTT): 클라이언트는 다음에 연결할 때 SYN 패킷에 저장된 쿠키와 함께 실제 HTTP 요청 데이터를 넣어 보냅니다. 서버는 쿠키를 검증하여 유효하면 즉시 데이터를 처리하고, SYN-ACK 응답에 HTTP 응답 데이터를 함께 실어 보낼 수 있습니다.
>   - 보안: 쿠키에는 클라이언트 IP 주소와 타임스탬프가 포함되어 있어, 악의적인 SYN Flood 공격이나 **패킷 재전송 공격(Replay 공격)**을 방어하는 데 사용됩니다. 쿠키 검증에 실패하면 서버는 데이터를 무시하고 일반적인 연결 절차로 돌아갑니다.
> 
> 2. TLS 1.3의 0-RTT
> - TLS 1.3은 TFO를 사용하여 TCP 연결이 수립된 후, **TLS Handshake**(보안 설정 단계)의 지연을 줄이는 데 0-RTT를 적용합니다.
> - 기본 개념: 이전 세션에서 공유했던 **PSK**(Pre-Shared Key)라는 암호화 컨텍스트를 재사용합니다.
> - 동작 과정:
>   -  첫 연결 (PSK 발급): 클라이언트와 서버가 완전한 TLS 핸드셰이크를 완료하면, 서버는 클라이언트에게 세션 티켓을 발급합니다. 이 티켓에는 PSK 및 관련 암호화 정보가 들어 있습니다.
>   -  재연결 (0-RTT Resumption): 클라이언트는 저장된 PSK로 **Early Data**(HTTP 요청)를 암호화한 후, 첫 번째 ClientHello 패킷에 PSK 식별자와 함께 실어 서버로 보냅니다.
>   -  결과: 서버는 PSK를 검증하고 Early Data를 즉시 복호화하여 처리할 수 있으므로, 보안 설정에 필요한 왕복 시간이 0으로 단축됩니다.
> 
> 3. QUIC (HTTP/3)의 0-RTT
> - QUIC은 UDP 기반으로 TCP와 TLS를 통합한 차세대 전송 프로토콜로, 0-RTT를 기본 기능으로 설계했습니다.
> - 동작 방식: QUIC은 첫 연결 시 Source Address Token을 발급받습니다. 이후 재연결 시, 클라이언트는 이 Token과 암호화된 HTTP 요청 데이터를 첫 패킷에 실어 보냅니다. 서버는 토큰을 검증하고 즉시 데이터를 처리하여 응답을 보냅니다.
> - 특징: QUIC은 프로토콜 자체에 암호화와 흐름 제어가 통합되어 있어, 별도의 TLS 핸드셰이크 단계를 거치지 않고도 진정한 0-RTT를 구현할 수 있습니다.
> 
> 4. 0-RTT의 근본적인 보안 문제: Replay 공격
> - 0-RTT의 가장 큰 취약점은 Replay 공격입니다.
> - 문제 상황: 공격자가 0-RTT로 전송된 유효한 패킷(예: "계좌이체: $100")을 복사한 후, 이를 서버에 재전송하면, 서버는 이를 새로운 요청으로 인식하고 중복 처리하여 문제가 발생할 수 있습니다.
> - 방어 메커니즘:
>   - 멱등성(Idempotent) 요청만 허용: 서버는 GET, HEAD와 같이 여러 번 실행해도 결과가 동일한 안전한 요청에만 0-RTT를 허용해야 합니다. POST, DELETE와 같은 상태 변경 작업은 0-RTT로 전송되더라도 거부(Too Early 에러)해야 합니다.
>   - 서버의 중복 요청 감지: PSK 티켓에 타임스탬프를 포함하거나, Single-Use Ticket 방식을 사용하여 한 번 사용된 티켓의 재사용을 거부해야 합니다. 분산 환경에서는 이 캐시 관리가 복잡합니다.
>   - 애플리케이션 레벨 보호: HTTP 헤더에 Idempotency Key와 같은 고유한 키를 포함하여, 서버 측에서 이 키를 확인하고 중복 처리 시도는 방지해야 합니다.
> 
> 5. 성능 비교 및 실무 적용
> - 0-RTT는 특히 RTT가 높은 모바일 또는 위성 네트워크 환경에서 체감 속도를 획기적으로 개선합니다.
> - 성능 향상: 기존의 TCP 3-Way + TLS Handshake(약 4 RTT)가 필요한 연결을 0 RTT로 줄여 페이지 로드 시간을 크게 단축할 수 있습니다.
> - 실무 고려사항: 0-RTT는 성능이 크게 향상되는 이점이 있지만, Replay 공격 위험 때문에 금융 거래, 인증/인가, 상태 변경(POST, PUT, DELETE)과 같은 민감한 작업에는 사용해서는 안 되며, 정적 콘텐츠 로딩이나 안전한 조회(GET) 작업에 제한적으로 적용해야 합니다.


### 12\. 4-Way Handshake에 대해 설명해 주세요.
> - 4-Way Handshake는 TCP 세션을 정상적으로 끊을 때 이루어집니다. 
> - TCP는 전이중(Full Duplex) 통신이기 때문에, 송신과 수신 양쪽이 각각 독립적으로 닫아야 합니다. 따라서 종료 시 4단계가 필요합니다.
> 
> - 1단계: 클라이언트 → 서버 (FIN 전송)
>   - 클라이언트가 더 이상 보낼 데이터가 없을 때, FIN 플래그가 설정된 세그먼트를 서버로 보냅니다.
>   - 이 패킷에는 클라이언트의 **현재 시퀀스 번호(ISN)**가 포함됩니다.
>   - 의미: “나는 이제 데이터를 다 보냈으니 송신을 닫겠다.”
> - 2단계: 서버 → 클라이언트 (ACK 응답)
>   - 서버는 클라이언트의 FIN을 받으면, ACK를 보냅니다.
>   - 이 ACK는 클라이언트의 시퀀스 번호 + 1을 확인 응답으로 담습니다.
>   - 이 시점에서: 클라이언트 → 서버 방향 송신은 종료됨.
>   - 서버 → 클라이언트 방향 송신은 아직 가능 (서버가 남은 데이터를 보낼 수 있음).
> - 3단계: 서버 → 클라이언트 (FIN 전송)
>   - 서버도 더 이상 보낼 데이터가 없으면, FIN을 클라이언트에 전송합니다.
> - 4단계: 클라이언트 → 서버 (ACK 응답)
>   - 클라이언트는 서버의 FIN을 받고 ACK를 응답합니다.
>   - 이 ACK 역시 서버의 시퀀스 번호 + 1을 담습니다.
>   - 이제 서버 → 클라이언트 방향 송신도 종료됩니다.
>   - 클라이언트는 마지막 ACK를 보낸 후 **TIME_WAIT 상태**로 대기합니다.

*   패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?
> - 각 패킷의 **TCP 플래그**를 확인하면 알 수 있습니다:
>   - FIN : 송신 측이 더 이상 데이터를 전송하지 않겠다는 종료 요청
>   - ACK : FIN 요청을 받았음을 확인하는 응답
>   - 이후 반대쪽에서도 동일하게 FIN → ACK 순서 진행
즉, FIN 플래그가 등장하고 뒤이어 ACK가 교환되면 해당 패킷이 4-way handshake 과정임을 식별할 수 있습니다.

*   빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?
> - TCP RST(Reset) 플래그를 사용합니다. (정상적인 종료(4-way handshake)를 거치지 않고, 현재 연결을 즉시 끊음)
> - 비정상 종료이므로 데이터 유실 위험이 있습니다. (예: 서버에 오류가 발생하거나, 더 이상 연결을 유지하는 것이 불가능할 때 RST를 전송해 연결을 강제 종료합니다.
 
*   4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?
> - 정상 FIN/ACK 수신 없음 → 일정 시간 동안 응답이 오지 않으면 **TCP 타이머**(재전송 타임아웃, RTO)가 만료되고, 결국 연결이 끊어졌다고 판단합니다.
> - 강제 종료(RST) → 상대방이 즉시 RST 패킷을 받으면, 해당 연결이 비정상적으로 종료되었음을 인식합니다.
> - 즉, 반대쪽은 ACK 응답 지연 + 타임아웃 또는 RST 플래그 수신을 통해 종료 상황을 알게 됩니다.

*   왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것일까요?
> - 마지막 ACK가 서버에 도착하지 못했을 경우 서버가 다시 FIN을 보낼 수 있는데, 이를 처리하기 위함입니다. 또한 네트워크 상에 남아 있는 지연 패킷이 새로운 연결에 영향을 주지 않도록 하기 위합니다.

### 13\. www.github.com을 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.
> 1. URL 파싱
> - 브라우저가 입력된 URL을 파싱
> - 프로토콜(https), 도메인(www.github.com), 경로(/) 식별
> 2. HSTS (HTTP Strict Transport Security) 확인
> - 브라우저가 HSTS 리스트 확인
> - github.com이 있으면 자동으로 HTTPS 사용
> 3. DNS 조회
> ① 브라우저 DNS 캐시 확인
> ② OS DNS 캐시 확인 (hosts 파일 포함)
> ③ 로컬 DNS 서버(ISP의 Recursive DNS)에 쿼리
> ④ 없으면 Root DNS 서버 → TLD DNS 서버(.com) → Authoritative DNS 서버 순으로 질의
> ⑤ github.com의 IP 주소 반환 (예: 140.82.121.4)
> 4. TCP 연결 수립 (3-Way Handshake)
> - 클라이언트 → GitHub 서버: SYN
> - GitHub 서버 → 클라이언트: SYN-ACK
> - 클라이언트 → GitHub 서버: ACK
> 5. TLS/SSL Handshake (HTTPS)
> ① Client Hello: 지원하는 암호화 방식, TLS 버전 전송
> ② Server Hello: 선택한 암호화 방식, 인증서 전송
> ③ 인증서 검증: CA(Certificate Authority) 확인
> ④ 키 교환: 대칭키 생성을 위한 키 교환
> ⑤ Finished: 암호화 통신 시작
> 6. HTTP 요청
> ```
> GET / HTTP/1.1
> Host: www.github.com
> User-Agent: Mozilla/5.0...
> Accept: text/html,application/xhtml+xml...
> Accept-Language: ko-KR,ko;q=0.9
> Accept-Encoding: gzip, deflate, br
> Connection: keep-alive
> ```
> 7. 서버 처리
> - 로드 밸런서가 요청을 받아 적절한 웹 서버로 분산
> - 웹 서버(Nginx/Apache)가 요청 처리
> - 필요시 WAS(Application Server)로 전달
> - 데이터베이스 조회
> - HTML 생성
> 8. HTTP 응답
> ```
> HTTP/1.1 200 OK
> Content-Type: text/html; charset=utf-8
> Content-Encoding: gzip
> Cache-Control: max-age=0, private
> Set-Cookie: ...
> ...
> <!DOCTYPE html>
> <html>...
> ```
> 9. 브라우저 렌더링
> ① HTML 파싱 → DOM 트리 구성
> ② CSS 파싱 → CSSOM 트리 구성
> ③ JavaScript 실행
> ④ Render 트리 구성 (DOM + CSSOM)
> ⑤ Layout (Reflow): 요소의 위치와 크기 계산
> ⑥ Paint: 픽셀로 변환하여 화면에 그림
> ⑦ Composite: 레이어 합성
> 10. 추가 리소스 로딩
> - CSS, JavaScript, 이미지, 폰트 등 병렬 다운로드
> - HTTP/2의 경우 하나의 TCP 연결로 멀티플렉싱

*   DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요?
> - DNS로 얻은 IP는 도메인 이름이 실제로 매핑된 네트워크 엔드포인트(서버, 로드밸런서, CDN 노드 등)를 가리킨다.
>   - 보통은 웹 서버: 도메인과 연결된 웹 애플리케이션 서버의 IP
>   - 경우에 따라 로드 밸런서나 프록시 서버: 여러 서버를 대신해 트래픽을 분산 처리하는 장비의 IP
>   - 클라우드 서비스 도메인의 경우 CDN 서버: 예컨대 youtube.com의 IP는 전 세계에 분산된 Google CDN 노드 중 하나의 주소
>   - 내부망이라면 사설 서버: 조직 내 DNS에서 내부 서비스(예: intranet.local)의 서버 IP


*   Web Server와 Web Application Server의 차이에 대해 설명해 주세요.
- Web Server는 정적 콘텐츠(HTML, CSS, JS, 이미지 등)를 HTTP 프로토콜을 통해 클라이언트에게 전달하는 역할을 합니다. 요청에 대해 단순히 파일을 찾아 응답하는 방식으로 작동하며, Nginx, Apache가 대표적입니다.
- Web Application Server(WAS)는 동적 콘텐츠를 생성하기 위해 애플리케이션 로직을 실행하는 서버입니다. 데이터베이스 조회, 비즈니스 로직 처리 등을 수행한 후 결과를 HTML로 변환하여 전달합니다. Tomcat, JBoss, Node.js가 대표적입니다. 일반적으로 Web Server 뒤에 WAS를 배치하는 구조를 사용합니다.

*   URL, URI, URN은 어떤 차이가 있나요?
- **URI(Uniform Resource Identifier) **: 리소스를 식별하는 가장 상위의 개념입니다. 리소스를 유일하게 구분할 수 있는 모든 형태를 포함합니다.
- **URL(Uniform Resource Locator) **: 리소스의 위치를 나타냅니다. https://example.com/page처럼 어디에서 어떻게 접근할 수 있는지를 명시합니다. URL은 URI의 하위 개념입니다.
- **URN(Uniform Resource Name) **: 리소스의 이름을 나타냅니다. 위치와 무관하게 리소스를 식별하며, urn:isbn:0451450523같은 형태입니다. URN도 URI의 하위 개념입니다. 실제로는 URL이 훨씬 더 광범위하게 사용됩니다.

### 14\. DNS에 대해 설명해 주세요.
- DNS는 Domain Name System의 약자로, 사람이 이해하기 쉬운 도메인 이름을 IP 주소로 변환하는 분산형 데이터베이스 시스템입니다. 예를 들어 www.google.com이라는 도메인을 입력하면, DNS가 이를 실제 서버의 IP 주소로 매핑해줍니다.

*   DNS는 몇 계층 프로토콜인가요?
- 애플리케이션 계층(7계층) 프로토콜입니다.

*   UDP와 TCP 중 어떤 것을 사용하나요?
- DNS는 일반적으로 UDP 53 포트를 사용합니다. UDP는 빠르고 오버헤드가 적어 DNS 쿼리에 적합합니다. 다만 Zone Transfer(DNS 레코드 대량 전송) 같은 경우에는 신뢰성이 중요하므로 TCP 53 포트를 사용합니다. 또한 DNS 응답이 512바이트를 초과하는 경우에도 TCP가 사용됩니다.

*   DNS Recursive Query, Iterative Query가 무엇인가요?
- Recursive Query: 클라이언트가 리졸버(보통 ISP의 DNS 서버)에 쿼리를 보낼 때 발생합니다. 리졸버는 최종 답변을 찾을 때까지 다른 DNS 서버들에 계속 물어봅니다. 클라이언트 입장에서는 리졸버로부터 최종 답변을 받습니다.
- Iterative Query: 리졸버가 다른 DNS 서버에 쿼리를 보낼 때 발생합니다. 각 DNS 서버는 자신이 알고 있는 정보만 응답하고, 모르면 다른 서버의 주소를 알려줍니다. 리졸버가 계속 다음 서버로 이동하며 질문합니다.


*   DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?
- DNS는 UDP를 사용하므로 패킷 손실이 발생할 수 있습니다. 이 경우 클라이언트는 일정 시간(보통 몇 초)을 기다린 후 Timeout이 발생하면 같은 쿼리를 다시 전송(Retry)합니다. 보통 3~5회 재시도 후에도 응답이 없으면 쿼리 실패로 처리됩니다.


*   캐싱된 DNS 쿼리가 잘못 될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?
- DNS 캐시가 만료되지 않은 상태에서 레코드가 변경되었다면, 일시적으로 잘못된 정보를 반환합니다.
- 해결 방법 1. TTL(Time To Live) 값 조정: 변경 가능성이 높은 레코드는 TTL을 짧게 설정하여 자주 갱신합니다.
- 해결 방법 2. DNS Flush: 사용자가 로컬 DNS 캐시를 수동으로 삭제합니다. (Windows: ipconfig /flushdns, Linux: 캐시 서비스 재시작)

*   DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.
- A 레코드는 도메인명을 IPv4 주소로 매핑합니다. 예를 들어 example.com A 192.0.2.1은 example.com을 IPv4 주소 192.0.2.1로 연결합니다.
- **CNAME 레코드(Canonical Name)**는 도메인명을 다른 도메인명으로 매핑합니다. 예를 들어 www.example.com CNAME example.com은 www.example.com이 example.com과 같다는 뜻입니다. CNAME의 대상은 반드시 다른 도메인명이어야 하고, 결국 A나 AAAA 레코드로 해석되어야 합니다.
- AAAA 레코드는 도메인명을 IPv6 주소로 매핑합니다. IPv6을 지원하는 시스템에서 사용되며, 형식은 A 레코드와 동일하지만 IPv6 주소를 사용합니다.

*   hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?
- hosts 파일은 로컬 컴퓨터에 저장된 텍스트 파일로, 도메인명과 IP 주소를 직접 매핑합니다. /etc/hosts (Linux/Mac) 또는 C:\Windows\System32\drivers\etc\hosts (Windows)에 위치합니다. 네트워크 접근 없이 로컬에서 즉시 작동하므로 성능이 빠릅니다.
- 우선순위는 hosts 파일이 DNS보다 높습니다. 도메인을 요청할 때 먼저 hosts 파일을 확인하고, 해당 항목이 없으면 DNS 쿼리를 수행합니다. 이를 이용해 특정 사이트를 차단하거나 개발 환경에서 로컬 도메인을 설정할 수 있습니다. 예를 들어 127.0.0.1 localhost 또는 127.0.0.1 dev.example.local로 설정할 수 있습니다.

### 15\. SOP 정책에 대해 설명해 주세요.
- SOP(Same-Origin Policy,동일 출처 정책)은 브라우저 보안의 핵심 원칙으로, 서로 다른 출처(origin)인 웹 페이지의 스크립트가 다른 출처의 리소스에 접근하지 못하도록 제한하는 정책입니다. (즉 프로토콜, 도메인, 포트 번호 중 하나라도 다른 경우)
- 예를 들어 https://example.com 페이지에서 https://api.example.com 혹은 http://example.com:8080 으로 요청을 보내면, 브라우저는 보안상 이를 차단합니다.
- 이 정책은 세션 탈취, 쿠키 탈취, 악성 스크립트 삽입(XSS) 등과 같은 클라이언트 사이드 공격을 예방하기 위해 도입되었습니다.

*   CORS 정책이 무엇인가요?
- CORS(Cross-Origin Resource Sharing)는 위의 SOP 정책을 우회하기 위한 서버 측 보안 메커니즘입니다. 서버가 응답 헤더에 Access-Control-Allow-Origin: https://client.com 과 같이 명시하면, 브라우저는 그 출처의 요청을 예외적으로 허용합니다.
- 또한 인증정보(쿠키, 토큰 등)를 포함하려면 Access-Control-Allow-Credentials: true를 하고 Access-Control-Allow-Origin을 특정 도메인으로 지정해야 합니다.

*   Preflight에 대해 설명해 주세요.
- Preflight Request(사전 요청) 은 브라우저가 실제 요청을 보내기 전에, 이 요청이 CORS 정책상 허용되는지 서버에 먼저 확인하는 과정입니다. Preflight는 보안상 민감한 요청(예: 커스텀 헤더 포함, PUT/DELETE 요청 등)에만 수행됩니다.
- 이는 HTTP OPTIONS 메서드로 전송되며, 브라우저는 다음 정보를 포함합니다:
```
Access-Control-Request-Method: POST  
Access-Control-Request-Headers: Content-Type, Authorization
```
- 서버가 아래대로 응답하면, 브라우저는 이후 실제 요청(예: POST)을 전송합니다.
```
Access-Control-Allow-Methods: POST  
Access-Control-Allow-Headers: Content-Type, Authorization
```

### 16\. Stateless와 Connectionless에 대해 설명해 주세요.
- Stateless는 서버가 클라이언트의 이전 요청 상태를 저장하지 않는 구조를 의미합니다. 즉, 각 요청이 완전히 독립적이며, 요청마다 필요한 모든 정보를 포함해야 합니다. 대표적으로 HTTP가 있습니다.
- Connectionless는 통신 시 연결을 유지하지 않고 패킷 단위로 데이터를 전송하는 방식을 말합니다. 대표적인 예는 UDP 프로토콜로, 연결 설정이나 종료 절차가 없기 때문에 속도는 빠르지만 신뢰성은 낮습니다.

*   왜 HTTP는 Stateless 구조를 채택하고 있을까요?
- 웹의 근본 목적은 단순한 문서 전송과 높은 확장성이었습니다. 서버가 클라이언트 상태를 저장하면 연결 수가 많아질수록 메모리와 리소스가 급격히 증가합니다. Stateless 구조는 이러한 문제를 피하고 수평 확장(Scalability)을 쉽게 만듭니다. 요청 간 독립성이 보장되므로, 로드밸런싱 환경에서도 세션 공유 없이 요청 분산이 가능합니다.
- 대신 상태 정보는 쿠키, 세션, 토큰(JWT) 등을 통해 별도로 관리합니다.

*   Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?
- HTTP는 요청마다 연결을 새로 열면 3-way handshake → 요청 → 응답 → 종료 과정이 반복되어 비효율적입니다. 이를 개선하기 위해 다음 기술들이 사용됩니다.
- HTTP Persistent Connection (Keep-Alive): 여러 요청을 하나의 TCP 연결로 재사용.
- HTTP/2 Multiplexing: 하나의 연결에서 여러 요청을 동시에 처리.
- HTTP/3 (QUIC): TCP 대신 UDP 기반으로 빠른 연결 설정과 전송 효율 향상.
- 즉, Stateless는 논리적 특성, Persistent Connection은 물리적 최적화로 보완됩니다.

*   TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?

### 17\. 라우터 내의 포워딩 과정에 대해 설명해 주세요.

*   라우팅과 포워딩의 차이는 무엇인가요?
- **라우팅(Routing)**은 전체 네트워크에서 패킷이 출발지에서 목적지까지 가는 경로를 결정하는 프로세스입니다. 라우터들이 라우팅 프로토콜을 사용하여 최적의 경로 정보를 주고받으며, 이를 바탕으로 라우팅 테이블을 구성합니다. 이는 네트워크 전체적인 관점에서의 의사결정입니다.
- **포워딩(Forwarding)**은 라우터가 수신한 패킷을 라우팅 테이블의 정보를 참고하여 적절한 출력 인터페이스로 전달하는 과정입니다. 개별 라우터 차원에서의 실제 패킷 이동입니다. 즉, 라우팅이 결정한 정보를 실행하는 단계입니다.

*   라우팅 알고리즘에 대해 설명해 주세요.
- 라우팅 알고리즘은 최적의 경로를 찾기 위한 알고리즘입니다. 크게 두 가지로 분류됩니다.
- **링크 상태 라우팅(Link-State Routing)**은 각 라우터가 전체 네트워크의 토폴로지 정보를 파악하고 있는 방식입니다. 각 라우터가 자신의 연결 정보를 플러드 방식으로 다른 모든 라우터에게 전파하고, 이를 바탕으로 Dijkstra 알고리즘 같은 최단 경로 알고리즘을 사용하여 경로를 계산합니다. OSPF(Open Shortest Path First)가 대표적입니다. 수렴 속도가 빠르고 정확하지만 연산량이 많습니다.
- **거리 벡터 라우팅(Distance-Vector Routing)**은 각 라우터가 인접한 라우터에게만 정보를 주고받는 방식입니다. 라우터는 이웃 라우터의 정보를 바탕으로 간접적으로 네트워크 정보를 습득합니다. RIP(Routing Information Protocol)와 BGP(Border Gateway Protocol)가 해당합니다. 구현이 간단하지만 수렴이 느리고 루핑 문제가 발생할 수 있습니다.

*   포워딩 테이블의 구조에 대해 설명해 주세요.

포워딩 테이블(라우팅 테이블)은 다음과 같은 기본 구조를 가집니다.

| 목적지 주소 | 넷마스크 | 다음 홉 | 인터페이스 | 메트릭 |
|-----------|--------|--------|----------|-------|
| 192.168.1.0 | 255.255.255.0 | 192.168.0.1 | eth0 | 1 |
| 10.0.0.0 | 255.255.0.0 | 192.168.0.2 | eth1 | 5 |

각 필드의 의미는 다음과 같습니다. **목적지 주소**는 패킷이 도착할 네트워크 주소입니다. **넷마스크**는 목적지 주소의 어느 부분까지가 네트워크 주소인지를 나타냅니다. **다음 홉**은 패킷을 전달할 다음 라우터의 주소입니다. **인터페이스**는 패킷을 보낼 라우터의 출력 포트입니다. **메트릭**은 경로의 비용(거리, 지연시간 등)을 나타내며 최적 경로 선택에 사용됩니다.

라우터는 수신한 패킷의 목적지 IP 주소와 포워딩 테이블의 항목들을 비교하여(Longest Prefix Matching) 가장 일치하는 항목을 찾고, 그에 해당하는 인터페이스로 패킷을 전달합니다.


### 18\. 로드밸런서가 무엇인가요?

로드밸런서는 들어오는 트래픽을 여러 백엔드 서버에 분산시키는 장치 또는 소프트웨어입니다. 이를 통해 단일 서버의 부하를 줄이고, 전체 시스템의 처리 용량을 증가시키며, 서버 장애 시에도 서비스 가용성을 보장할 수 있습니다.

*   L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.

**L4 로드밸런서(Transport Layer Load Balancer)**는 OSI 모델의 4계층(전송 계층) 정보인 IP, 포트, TCP/UDP 등을 기반으로 트래픽을 분산합니다. 패킷 헤더 정보만 확인하면 되므로 매우 빠르고 효율적입니다. 단순한 라운드 로빈, IP 해시 같은 방식으로 분산하며, 구현이 간단하고 성능이 우수합니다. 다만 애플리케이션 수준의 정보를 인식하지 못합니다.
**L7 로드밸런서(Application Layer Load Balancer)**는 OSI 모델의 7계층(애플리케이션 계층) 정보인 HTTP 헤더, URL, 쿠키, 호스트명 등을 분석하여 트래픽을 분산합니다. 예를 들어 특정 URL 패턴이나 호스트명에 따라 다른 서버로 라우팅할 수 있습니다. 더욱 세밀한 제어가 가능하지만, 애플리케이션 데이터를 분석해야 하므로 성능 오버헤드가 있습니다.

*   로드밸런서 알고리즘에 대해 설명해 주세요.

**라운드 로빈(Round Robin)**은 들어온 요청을 순서대로 백엔드 서버에 분배합니다. 서버 간 성능 차이가 없을 때 가장 공평합니다.
**가중치 기반(Weighted Round Robin)**은 각 서버에 가중치를 부여하여 성능이 높은 서버가 더 많은 요청을 받도록 합니다.
**IP 해시(IP Hash)**는 클라이언트의 IP 주소를 해시하여 같은 클라이언트는 항상 같은 서버로 분배합니다. 세션 유지에 유용하지만 특정 서버가 다운되면 매핑이 변경됩니다.
**최소 연결(Least Connection)**은 현재 활성화된 연결 수가 가장 적은 서버로 요청을 보냅니다. 연결 지속 시간이 긴 서비스에 효과적입니다.
**리소스 기반(Resource Based)**은 각 서버의 CPU, 메모리 같은 현재 리소스 사용률을 고려하여 여유가 있는 서버에 요청을 할당합니다.
**응답 시간(Response Time)**은 각 서버의 응답 시간을 측정하여 더 빠른 응답 시간을 보이는 서버에 우선적으로 요청을 보냅니다.


*   로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능하다고 가정해 봅시다. 이 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하려면 어떻게 해야 할까요?

- 로드밸런서는 백엔드 서버의 상태를 주기적으로 점검하는 헬스 체크(Health Check) 기능을 가지고 있습니다. 로드밸런서가 특정 간격으로 각 서버에 HTTP 요청, TCP 연결 시도, 또는 핑(Ping) 같은 방식으로 서버의 정상 작동 여부를 확인합니다. 만약 서버가 응답하지 않거나 오류를 반환하면 로드밸런서는 해당 서버를 비활성화(Disable) 상태로 전환하여 더 이상 새로운 요청을 보내지 않습니다. 서버가 정상으로 복구되면 다시 활성 상태로 전환되어 요청을 받기 시작합니다. 이를 통해 장애 있는 서버로의 요청 분산을 방지합니다.

*   로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.

- **DNS 라운드 로빈(DNS Round Robin)**은 로드밸런서 하드웨어 없이 DNS만으로 로드밸런싱을 구현하는 방법입니다.
같은 도메인명에 대해 여러 개의 IP 주소를 DNS 레코드에 등록합니다. 예를 들어 example.com에 대해 A 192.168.1.1, A 192.168.1.2, A 192.168.1.3을 모두 등록합니다. 클라이언트가 example.com을 DNS에 질의할 때 DNS 서버는 이 여러 IP 주소를 반복되는 순서로 응답하므로, 각 클라이언트가 받는 IP 주소가 분산됩니다. 결과적으로 다양한 백엔드 서버로 연결됩니다.
- 장점: 로드밸런서 하드웨어 비용이 없고, DNS 캐싱 때문에 성능이 우수하다는 점입니다.
- 단점: 클라이언트나 중간의 DNS 리졸버가 응답을 캐싱하면 실제로는 라운드 로빈이 작동하지 않을 수 있습니다. 또한 특정 서버가 장애를 일으켜도 DNS는 즉시 반영하지 못하므로 여전히 그 서버의 IP를 응답할 수 있습니다. 세밀한 가중치 제어도 어렵습니다. (DNS 라운드 로빈은 단순한 경우에만 적합, 실제 프로덕션 환경에서는 전용 로드밸런서를 사용하는 것이 권장됨)

### 19\. 서브넷 마스크와, 게이트웨이에 대해 설명해 주세요.
- **서브넷 마스크(Subnet Mask)**는 IP 주소에서 네트워크 부분과 호스트 부분을 구분하는 역할을 하는 32비트의 숫자입니다. 같은 네트워크에 속한 컴퓨터들을 식별하기 위해 사용됩니다.
  -  예를 들어 IP 주소 192.168.1.100과 서브넷 마스크 255.255.255.0이 있을 때, 이진수로 변환하면 마스크는 11111111.11111111.11111111.00000000입니다. 이는 상위 24비트가 네트워크 주소, 하위 8비트가 호스트 주소라는 의미입니다. AND 연산을 통해 네트워크 주소는 192.168.1.0이 되고, 이 네트워크 내의 호스트 주소 범위는 192.168.1.1부터 192.168.1.254까지(브로드캐스트 주소 제외)입니다.

- **게이트웨이(Gateway)**는 서로 다른 네트워크 간의 통신을 중개하는 장치 또는 컴퓨터입니다. 로컬 네트워크에서 외부 네트워크로 나가는 출입문 역할을 합니다.
일반적으로 가정이나 기업의 공유기가 게이트웨이 역할을 합니다. 같은 로컬 네트워크(예: 192.168.1.x)의 컴퓨터들은 서로 직접 통신하지만, 다른 네트워크(예: 외부 인터넷)와 통신할 때는 게이트웨이(공유기)를 통해서만 통신합니다. 게이트웨이는 패킷을 받아 목적지를 확인하고, 필요하면 라우팅하거나 NAT 변환을 수행합니다.
각 컴퓨터의 네트워크 설정에는 **기본 게이트웨이(Default Gateway)**가 지정되어 있습니다. 이는 자신의 네트워크가 아닌 다른 네트워크로 가는 패킷을 어디로 보낼지를 결정합니다. 예를 들어 가정용 네트워크에서 기본 게이트웨이는 보통 192.168.1.1입니다.

*   NAT에 대해 설명해 주세요.

- NAT(Network Address Translation)는 사설 IP 주소와 공인 IP 주소 간의 변환을 수행하는 기술입니다. 내부 네트워크의 컴퓨터들은 사설 IP 주소(예: 192.168.x.x, 10.x.x.x)를 사용하며, 외부 인터넷과 통신할 때 NAT 장치(보통 라우터)가 이를 공인 IP 주소로 변환합니다. 따라서 외부에서는 내부 네트워크의 실제 구조를 알 수 없게 됩니다.
- NAT의 주요 기능은 보안 향상과 IP 주소 절약(여러 디바이스가 하나의 공인 IP 사용)입니다. 예를 들어 공유기 뒤의 여러 기기들이 모두 같은 공인 IP로 인터넷에 접속합니다. 공유기는 각 기기에서 나가는 패킷의 출발지 포트를 다르게 설정하여 돌아오는 응답 패킷을 올바른 기기로 라우팅합니다.


*   서브넷 마스크의 표현 방식에 대해 설명해 주세요.

- 서브넷 마스크는 IP 주소에서 네트워크 부분과 호스트 부분을 구분하는 역할을 합니다. 
- 일반적으로 CIDR 표기법과 점 표기법이 가장 많이 사용됩니다. 점 표기법은 직관적이고, CIDR 표기법은 간결합니다.
  - **점 표기법(Dotted Decimal Notation)**은 일반적인 표현 방식으로 `255.255.255.0` 같은 형태입니다. 각 옥텟을 0~255의 십진수로 표현합니다.
  - **CIDR 표기법(Classless Inter-Domain Routing)**은 IP 주소 뒤에 슬래시와 숫자를 붙이는 방식으로 `192.168.1.0/24` 같은 형태입니다. 슬래시 뒤의 숫자는 네트워크 비트의 개수를 나타냅니다. `/24`는 상위 24비트가 네트워크 주소, 하위 8비트가 호스트 주소라는 의미입니다.
  - **이진 표기법(Binary Notation)**은 서브넷 마스크를 이진수로 표현하는 방식입니다. `255.255.255.0`은 `11111111.11111111.11111111.00000000`입니다.


*   그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?
- 아니요, 불가능합니다. 서브넷 마스크는 반드시 연속된 1 비트 다음에 연속된 0 비트가 오는 형태여야 합니다. 즉, `11111111.00000000.11111111.00000000` 같은 형태로 1과 0이 섞여 있으면 안 됩니다.
  - `255.0.255.0`을 이진수로 변환하면 `11111111.00000000.11111111.00000000`인데, 중간에 0이 나온 후 다시 1이 나오므로 유효하지 않습니다. 이런 서브넷 마스크를 사용하면 네트워크 주소와 호스트 주소를 명확히 구분할 수 없어 라우팅이 올바르게 작동하지 않습니다.
- 유효한 서브넷 마스크는 `255.255.255.0`, `255.255.240.0`, `255.255.0.0` 같은 형태여야 합니다.



### 20\. 멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.

- **멀티플렉싱(Multiplexing)**은 여러 개의 데이터 흐름을 하나의 채널로 합쳐서 전송하는 과정입니다. 송신자 입장에서의 작업입니다. 예를 들어 한 컴퓨터에서 여러 애플리케이션(브라우저, 메신저, 게임 등)이 동시에 인터넷 연결을 사용하고 있습니다. 각 애플리케이션의 데이터는 전송 계층에서 여러 포트로 구분되어 하나의 IP 계층으로 통합되어 전송됩니다. 이것이 멀티플렉싱입니다.

- **디멀티플렉싱(Demultiplexing)**은 수신한 하나의 데이터 흐름을 여러 개의 데이터 흐름으로 분리하는 과정입니다. 수신자 입장에서의 작업입니다.



*   디멀티플렉싱의 과정에 대해 설명해 주세요.

- 디멀티플렉싱은 다음과 같은 단계로 진행됩니다.

1. 먼저 수신자가 물리 계층에서 프레임을 수신합니다. 데이터 링크 계층에서 프레임 헤더를 확인하여 링크 계층 정보를 제거합니다. 네트워크 계층에서 IP 헤더를 확인하여 이 패킷이 자신에게 온 것인지 확인하고, IP 헤더의 프로토콜 필드를 보며 상위 계층이 TCP인지 UDP인지 판단합니다.

2. 전송 계층에서는 TCP 또는 UDP 헤더를 확인합니다. **목적지 포트 번호**를 읽어서 어느 애플리케이션으로 보낼지 결정합니다. 예를 들어 포트 80이면 웹 브라우저, 포트 5222면 메신저 같은 방식으로 분류합니다.

3. 마지막으로 애플리케이션 계층에서 각 포트에 바인딩된 소켓을 통해 해당 애플리케이션에 데이터를 전달합니다. 이를 통해 하나의 네트워크 연결에서 오는 데이터가 여러 애플리케이션으로 올바르게 분산됩니다.

- 핵심은 **포트 번호를 기반으로** 어느 애플리케이션 또는 프로세스에 데이터를 전달할지 판단하는 것입니다.


### 21\. XSS에 대해서 설명해 주세요.

- **XSS(Cross-Site Scripting)**는 공격자가 악의적인 자바스크립트 코드를 웹사이트에 주입하여 다른 사용자의 브라우저에서 실행시키는 보안 취약점입니다.
- XSS는 주로 세 가지 유형으로 분류됩니다.
1. **Stored XSS(저장형 XSS)**는 악의적인 스크립트가 서버 데이터베이스에 저장되는 경우입니다. 예를 들어 게시판 글에 `<script>alert('hack')</script>`을 작성하고 저장하면, 이 글을 보는 모든 사용자의 브라우저에서 해당 스크립트가 실행됩니다. 가장 위험한 유형입니다.
2. **Reflected XSS(반사형 XSS)**는 URL이나 폼 데이터에 포함된 스크립트가 서버에서 즉시 응답으로 반영되는 경우입니다. 예를 들어 `search.php?q=<script>alert('hack')</script>`을 누르면 검색 결과 페이지에서 스크립트가 실행됩니다. 사용자가 악의적인 링크를 클릭할 때만 발생합니다.
3. **DOM-based XSS**는 클라이언트의 자바스크립트가 사용자 입력을 DOM에 안전하지 않게 삽입할 때 발생합니다. 예를 들어 `document.getElementById('result').innerHTML = userInput;`처럼 입력값을 검증 없이 HTML로 삽입하면 XSS가 발생합니다.
- XSS를 통해 공격자는 사용자의 쿠키나 세션 정보를 탈취하거나, 피싱 페이지를 띄우거나, 악성 소프트웨어를 다운로드하게 할 수 있습니다.



*   CSRF랑 XSS는 어떤 차이가 있나요?

- XSS는 악의적인 코드를 실행시키는 공격이고, CSRF는 사용자의 인증 정보를 악용하여 권한 없는 요청을 보내는 공격입니다.

**CSRF(Cross-Site Request Forgery, 사이트 간 요청 위조)**는 사용자가 인증된 상태에서 모르게 악의적인 요청을 보내도록 하는 공격입니다. 공격자는 스크립트를 실행시키지 않고, 사용자의 인증 정보(쿠키, 세션)를 악용하여 사용자 몰래 요청을 전송합니다. 예를 들어 사용자가 은행 웹사이트에 로그인한 상태에서 악의적인 사이트를 방문하면, 그 사이트가 사용자 몰래 은행에 송금 요청을 보낼 수 있습니다. 권한 악용이 핵심입니다.

**XSS(Cross-Site Scripting)**는 공격자가 악의적인 스크립트를 웹사이트에 주입하여 사용자의 브라우저에서 실행시키는 공격입니다. 공격자가 직접 사용자의 정보나 리소스에 접근하려고 합니다. 악의적인 코드 실행이 핵심입니다.


*   XSS는 프론트엔드에서만 막을 수 있나요?
아니요. 백엔드 방어도 필수입니다. 악의적인 사용자가 프론트엔드 검증을 우회하여 직접 API에 요청을 보낼 수 있기 때문입니다.
프론트엔드 단 방어에서는 사용자 입력을 HTML 이스케이핑하여 특수 문자를 안전한 형태로 변환합니다. 예를 들어 `<`를 `&lt;`, `>`를 `&gt;`로 변환합니다. 또한 DOMpurify 같은 라이브러리를 사용하여 입력 데이터를 정제합니다. 자바스크립트 프레임워크(React, Vue 등)가 기본적으로 템플릿에서 데이터를 자동으로 이스케이핑해주기도 합니다.
백엔드 방어도 중요합니다. 서버가 저장된 데이터(Stored XSS)나 응답 데이터(Reflected XSS)를 클라이언트로 전송하기 전에 반드시 검증하고 정제해야 합니다. 입력값 검증으로 악의적인 패턴을 감지하고, 출력 인코딩으로 데이터를 안전한 형태로 변환합니다. Content Security Policy(CSP) 헤더를 설정하여 인라인 스크립트 실행을 제한할 수 있습니다.