## 네트워크

# 1. 쿠키와 세션

<details>
<summary>쿠키와 세션의 차이에 대해 설명해 주세요.</summary>

- 쿠키와 세션은 모두 웹 애플리케이션에서 사용자 상태를 유지하기 위한 방법입니다. 
  - 쿠키는 클라이언트(브라우저)에 키-값 쌍으로 저장되는 데이터 파일로, 브라우저를 닫아도 유효 시간 내에는 지속됩니다. 
  - 세션은 서버에 저장되는 사용자 정보로, 세션 ID를 쿠키로 전달하여 사용자를 식별합니다.

- **쿠키와 세션의 주요한 차이점은 저장 위치입니다.** 쿠키는 클라이언트에 저장되고, 세션은 서버에 저장됩니다. 이 저장 위치의 차이가 보안성과 서버 부하에 직접적인 영향을 미칩니다.
  - **보안성 측면에서는 세션이 훨씬 안전합니다.** 쿠키는 클라이언트에 저장되어 네트워크를 통해 전송되므로 중간에 탈취되거나 변조될 위험이 있습니다. 반면 세션은 서버에 저장되어 클라이언트에는 세션 ID만 전송되므로 사용자 데이터가 노출되지 않습니다.
  - **서버 부하 측면에서는 쿠키가 유리합니다.** 쿠키는 클라이언트에 저장되므로 서버의 메모리나 스토리지를 사용하지 않아 서버 부하가 적습니다. 반면 세션은 서버에 사용자 데이터를 저장하고 관리해야 하므로 서버 리소스를 소모하고 부하가 증가할 수 있습니다.

- 쿠키와 세션은 HTTP의 connectionless와 stateless 특성을 해결하기 위해 사용됩니다. HTTP는 응답 후 연결을 끊고 서버는 클라이언트 상태를 유지하지 않는데, 쿠키/세션 없이는 사용자가 매번 로그인해야 하고 '로그인 유지'나 '장바구니' 같은 기능이 불가능합니다.

> - 쿠키: 브라우저(클라이언트)에 저장되는 작은 데이터. 주로 세션 ID를 저장하는 용도로 쓰임. → Stateless 방식(쿠키 자체는 상태를 서버에 저장하지 않으니까 Stateless 메커니즘이지만 Stateless한 HTTP를 보완해서 상태 유지를 가능하게 만들어주는 도구”로 사용됨)
> - 세션: 서버에 저장되는 사용자 상태 데이터. 쿠키로 전달된 세션 ID로 식별해서 로그인 정보 등을 관리함. → Stateful 방식
> - 토큰(JWT): 인증·인가 정보를 담은 문자열. 서버는 상태를 저장하지 않고, 토큰 유효성만 검사해서 요청 처리. → Stateless 방식

- 참고 자료: https://www.nossi.dev/c630d26d-6ccb-4637-918a-c2396d74f1bd

</details>

<details>
<summary>세션 방식의 로그인 과정에 대해 설명해 주세요.</summary>

- 먼저 사용자가 로그인 폼에 아이디와 비밀번호를 입력하고 서버에 전송합니다. 서버는 사용자 인증을 수행하고, 인증이 성공하면 서버에 세션을 생성합니다. 이때 세션에는 사용자 정보와 세션 ID가 포함됩니다.

- 서버는 생성된 세션 ID를 클라이언트에게 쿠키로 전송합니다. 클라이언트는 이후 요청 시 이 세션 ID를 포함하여 전송하고, 서버는 세션 ID를 통해 사용자를 식별합니다. 로그아웃 시에는 서버에서 해당 세션을 삭제하고 클라이언트의 쿠키도 만료시킵니다.

</details>

<details>
<summary>HTTP의 특성인 Stateless에 대해 설명해 주세요.</summary>

- HTTP는 Stateless(무상태) 프로토콜입니다. 이는 각 HTTP 요청이 독립적이며, 서버가 이전 요청의 상태를 기억하지 않는다는 의미입니다. 즉, 서버는 클라이언트가 누구인지, 이전에 어떤 요청을 했는지 기억하지 않습니다.

- Stateless의 장점으로는 서버의 확장성이 좋습니다. 서버가 상태를 유지하지 않으므로 여러 서버에 요청을 분산하기 쉽고, 서버가 장애가 발생해도 다른 서버가 요청을 처리할 수 있습니다. 또한 서버의 메모리 사용량이 적고 구현이 단순합니다.

- 단점으로는 사용자 상태를 유지하기 어렵습니다. 로그인 상태나 장바구니 같은 정보를 유지하려면 쿠키나 세션 같은 추가적인 메커니즘이 필요합니다.

</details>

<details>
<summary>Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?</summary>

- HTTP가 Stateless인데 세션을 사용하는 것이 모순적으로 보일 수 있습니다. 하지만 실제로는 세션도 HTTP의 Stateless 특성을 완전히 위반하지는 않습니다.

- 세션을 사용할 때도 각 HTTP 요청은 여전히 독립적입니다. 서버는 세션 ID만으로 사용자를 식별하고, 세션 데이터는 별도로 관리됩니다. 즉, HTTP 요청 자체는 여전히 Stateless하지만, 애플리케이션 레벨에서 상태를 유지하는 것입니다.

- 또한 세션은 서버 메모리에 저장되므로 서버가 재시작되면 사라지고, 여러 서버를 사용할 때는 세션 공유 문제가 발생할 수 있습니다. 이런 이유로 최근에는 JWT 같은 Stateless한 인증 방식이 선호되기도 합니다.

</details>

<details>
<summary>규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?</summary>

- 여러 서버를 사용할 때 세션 관리 문제를 해결하는 방법들이 있습니다. 첫 번째는 세션 클러스터링입니다. 여러 서버가 세션 정보를 공유하도록 설정하여, 어떤 서버로 요청이 와도 동일한 세션을 사용할 수 있습니다.

- 두 번째는 세션 저장소를 외부로 분리하는 방법입니다. Redis나 Memcached 같은 인메모리 데이터베이스에 세션을 저장하여 모든 서버가 접근할 수 있도록 합니다. 이 방법은 성능이 좋고 확장성이 뛰어납니다.

- 세 번째는 세션을 데이터베이스에 저장하는 방법입니다. 모든 서버가 동일한 데이터베이스를 사용하므로 세션 공유가 가능하지만, 성능상 오버헤드가 있을 수 있습니다.

- 최근에는 JWT 같은 Stateless한 토큰 기반 인증을 사용하여 세션 관리 문제를 근본적으로 해결하는 방법도 많이 사용됩니다.

</details>

# 2. HTTP 응답코드

<details>
<summary>HTTP 응답코드에 대해 설명해 주세요.</summary>

- HTTP 응답코드는 서버가 클라이언트의 요청에 대한 처리 결과를 나타내는 3자리 숫자 코드입니다. 주요 카테고리로는 1xx(정보), 2xx(성공), 3xx(리다이렉션), 4xx(클라이언트 오류), 5xx(서버 오류)가 있습니다.

- 2xx 성공 코드는 요청이 성공적으로 처리되었음을 의미합니다. 200 OK는 일반적인 성공, 201 Created는 리소스가 성공적으로 생성되었음을 나타냅니다.

- 4xx 클라이언트 오류는 클라이언트의 요청에 문제가 있음을 의미합니다. 401 Unauthorized는 인증이 필요함을, 403 Forbidden은 권한이 없음을 나타냅니다.

- 5xx 서버 오류는 서버 측에서 문제가 발생했음을 의미합니다. 500 Internal Server Error는 서버 내부 오류를 나타냅니다.

</details>

<details>
<summary>401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?</summary>

- 401 Unauthorized와 403 Forbidden은 모두 접근이 거부된 상황을 나타내지만, 의미적으로 차이가 있습니다.

- 401 Unauthorized는 인증(Authentication)이 필요한 상황입니다. 즉, 사용자가 누구인지 확인되지 않은 상태로, 로그인이 필요하거나 유효하지 않은 인증 정보를 제공한 경우입니다. 클라이언트는 적절한 인증 정보를 제공하면 접근이 가능할 수 있습니다.

- 403 Forbidden은 인가(Authorization)가 거부된 상황입니다. 사용자는 인증되었지만, 해당 리소스에 접근할 권한이 없는 경우입니다. 예를 들어, 일반 사용자가 관리자만 접근할 수 있는 페이지에 접근하려고 할 때 발생합니다.

> 요약하면, 401은 "누구인지 모르겠다", 403은 "알고 있지만 권한이 없다"는 의미

</details>

<details>
<summary>200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.</summary>

- 200 OK와 201 Created는 모두 성공적인 응답을 나타내지만, 구체적인 의미가 다릅니다.
  - 200 OK는 요청이 성공적으로 처리되었음을 나타내는 일반적인 성공 응답입니다. 주로 조회(GET), 수정(PUT), 삭제(DELETE) 작업에서 사용되며, 특별한 의미를 부여하지 않는 범용적인 성공 응답입니다.
  - 201 Created는 새로운 리소스가 성공적으로 생성되었음을 나타냅니다. 주로 POST 요청으로 새로운 데이터를 생성할 때 사용되며, 생성된 리소스의 위치를 Location 헤더에 포함할 수 있습니다.

-  사용자 정보를 조회할 때는 200 OK를, 새로운 사용자를 등록할 때는 201 Created를 사용하는 것이 RESTful API의 일반적인 관례입니다.

</details>

<details>
<summary>필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.</summary>

- 기술적으로는 가능하지만 권장되지 않습니다. HTTP 표준에서는 1xx, 2xx, 3xx, 4xx, 5xx 범위의 응답 코드를 정의하고 있으며, 각 범위는 특정한 의미를 가집니다.

- 커스텀 응답 코드를 사용하면 클라이언트나 프록시, 캐시 등이 해당 코드를 인식하지 못할 수 있습니다. 또한 HTTP 표준을 벗어나는 사용으로 인해 예상치 못한 동작이 발생할 수 있습니다.

- 대신 표준 응답 코드를 사용하거나, 응답 본문에 상세한 정보를 포함하는 것이 좋습니다. 예를 들어, 400 Bad Request를 사용하고 응답 본문에 구체적인 오류 정보를 포함할 수 있습니다.

- 만약 특별한 의미를 전달하고 싶다면, 응답 헤더나 응답 본문을 활용하는 것이 표준을 준수하는 방법입니다.

</details>

# 3. HTTP Method

<details>
<summary>HTTP Method에 대해 설명해 주세요.</summary>

- HTTP Method는 클라이언트가 서버에 요청할 때 수행하고자 하는 작업의 종류를 나타내는 것입니다. 주요 메서드로는 GET, POST, PUT, DELETE, PATCH 등이 있습니다.

- GET은 서버로부터 리소스를 조회할 때 사용하며, 데이터를 URL 파라미터로 전송합니다. POST는 새로운 리소스를 생성할 때 사용하며, 데이터를 요청 본문에 포함합니다.

- PUT은 리소스를 완전히 교체할 때, PATCH는 리소스의 일부를 수정할 때 사용합니다. DELETE는 리소스를 삭제할 때 사용합니다.

- 각 메서드는 멱등성과 안전성이라는 특성을 가지며, 이는 RESTful API 설계의 중요한 원칙입니다.

</details>

<details>
<summary>HTTP Method의 멱등성에 대해 설명해 주세요.</summary>

- 멱등성(Idempotency)은 같은 요청을 여러 번 수행해도 결과가 동일한 특성을 의미합니다. 즉, 한 번 실행한 것과 여러 번 실행한 것이 같은 효과를 가져야 합니다.

- 멱등한 메서드로는 GET, PUT, DELETE가 있습니다. GET은 조회 작업이므로 여러 번 호출해도 동일한 결과를 반환합니다. PUT은 리소스를 완전히 교체하므로 여러 번 호출해도 최종 상태는 같습니다. DELETE도 리소스를 삭제하므로 여러 번 호출해도 삭제된 상태는 동일합니다.

- 멱등하지 않은 메서드로는 POST, PATCH가 있습니다. POST는 새로운 리소스를 생성하므로 여러 번 호출하면 여러 개의 리소스가 생성됩니다. PATCH는 부분 수정이므로 여러 번 호출하면 결과가 달라질 수 있습니다.

</details>

<details>
<summary>GET과 POST의 차이는 무엇인가요?</summary>

- GET과 POST는 HTTP의 가장 기본적인 두 메서드로, 여러 측면에서 차이가 있습니다.

- 용도 측면에서 GET은 데이터 조회용으로 사용되며, POST는 데이터 생성이나 수정용으로 사용됩니다. GET은 멱등하고 안전한 메서드이지만, POST는 멱등하지 않고 안전하지 않은 메서드입니다.

- 데이터 전송 방식에서 GET은 URL 파라미터로 데이터를 전송하므로 길이 제한이 있고 캐싱이 가능합니다. POST는 요청 본문에 데이터를 포함하므로 길이 제한이 없고 캐싱되지 않습니다.

- 보안 측면에서 GET은 URL에 데이터가 노출되므로 민감한 정보 전송에 부적합합니다. POST는 요청 본문에 데이터가 포함되므로 상대적으로 안전합니다.

- 브라우저 동작에서 GET은 뒤로가기나 새로고침이 안전하지만, POST는 중복 전송 문제가 발생할 수 있습니다.

</details>

<details>
<summary>POST와 PUT, PATCH의 차이는 무엇인가요?</summary>

- POST, PUT, PATCH는 모두 데이터를 수정하는 메서드이지만, 구체적인 용도와 동작 방식이 다릅니다.

- POST는 새로운 리소스를 생성할 때 사용합니다. 서버가 리소스의 ID를 결정하고, 여러 번 호출하면 여러 개의 리소스가 생성됩니다. 멱등하지 않은 메서드입니다.

- PUT은 리소스를 완전히 교체할 때 사용합니다. 클라이언트가 리소스의 전체 정보를 제공하며, 해당 리소스가 없으면 생성하고 있으면 완전히 교체합니다. 멱등한 메서드입니다.

- PATCH는 리소스의 일부만 수정할 때 사용합니다. 변경하고자 하는 필드만 전송하며, 부분 업데이트를 수행합니다. 멱등하지 않은 메서드입니다.

- 사용자 정보를 생성할 때는 POST를, 사용자 정보를 완전히 교체할 때는 PUT을, 사용자의 이름(req의 일부)만 변경할 때는 PATCH를 사용합니다.

</details>

<details>
<summary>HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?</summary>

- HTTP 1.1부터는 기술적으로 GET 요청에도 본문을 포함할 수 있지만, 여러 이유로 지양하는 것이 좋습니다.

- 첫 번째는 표준 준수입니다. HTTP 표준에서는 GET 요청의 본문은 의미가 없다고 명시하고 있으며, 서버나 프록시가 이를 무시할 수 있습니다.

- 두 번째는 캐싱 문제입니다. GET 요청은 캐싱이 가능한데, 본문이 포함된 GET 요청은 캐싱 시스템이 이를 제대로 처리하지 못할 수 있습니다.

- 세 번째는 보안 문제입니다. GET 요청의 본문은 로그에 기록되지 않을 수 있어서 디버깅이나 보안 감사가 어려워집니다.

- 네 번째는 호환성 문제입니다. 일부 프록시나 방화벽이 GET 요청의 본문을 제거하거나 차단할 수 있습니다.

- 따라서 데이터를 전송해야 한다면 POST나 다른 적절한 메서드를 사용하는 것이 좋습니다.

</details>

# 4. HTTPS

<details>
<summary>HTTPS에 대해 설명해 주세요.</summary>

- HTTPS(HyperText Transfer Protocol Secure)는 HTTP에 SSL/TLS 암호화를 추가한 보안 프로토콜입니다. HTTP는 평문으로 데이터를 전송하므로 중간에 데이터가 노출될 위험이 있지만, HTTPS는 암호화를 통해 데이터의 기밀성과 무결성을 보장합니다.

- HTTPS는 공개키 암호화와 대칭키 암호화를 모두 사용합니다. 초기 연결 설정 시에는 공개키 암호화를 사용하여 대칭키를 안전하게 교환하고, 이후 데이터 전송 시에는 대칭키 암호화를 사용하여 성능을 최적화합니다.

- HTTPS는 인증서를 통해 서버의 신원을 확인하고, 데이터 암호화를 통해 중간자 공격을 방지합니다. 또한 데이터 무결성을 보장하여 전송 중 데이터가 변조되지 않았음을 확인할 수 있습니다.

</details>

<details>
<summary>공개키와 대칭키에 대해 설명해 주세요.</summary>

- 공개키 암호화와 대칭키 암호화는 암호화 방식의 두 가지 주요 유형입니다.

- 대칭키 암호화는 암호화와 복호화에 동일한 키를 사용하는 방식입니다. AES, DES 등이 대표적인 알고리즘이며, 암호화와 복호화 속도가 빠르고 효율적입니다. 하지만 키를 안전하게 공유하는 것이 어렵습니다.

- 공개키 암호화는 암호화용 공개키와 복호화용 개인키를 사용하는 방식입니다. RSA, ECC 등이 대표적인 알고리즘이며, 키 공유 문제를 해결할 수 있습니다. 하지만 암호화와 복호화 속도가 느리고 계산 비용이 높습니다.

- 실제로는 두 방식을 조합하여 사용합니다. 공개키 암호화로 대칭키를 안전하게 교환한 후, 대칭키 암호화로 실제 데이터를 암호화합니다.

</details>

<details>
<summary>왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것일까요?</summary>

- HTTPS 핸드셰이크에서 인증서를 사용하는 이유는 서버의 신원을 확인하고 중간자 공격을 방지하기 위해서입니다.

- 공개키 암호화만으로는 공개키가 정말 서버의 것인지 확인할 수 없습니다. 악의적인 공격자가 자신의 공개키를 서버의 것처럼 위장하여 전송할 수 있기 때문입니다.

- 인증서는 신뢰할 수 있는 인증기관(CA)이 서버의 공개키에 디지털 서명을 한 것입니다. 클라이언트는 CA의 공개키를 미리 가지고 있어서 인증서의 유효성을 검증할 수 있습니다.

- 인증서 검증 과정을 통해 서버가 정말 해당 도메인의 소유자인지 확인하고, 공개키가 변조되지 않았음을 보장할 수 있습니다.

</details>

<details>
<summary>SSL과 TLS의 차이는 무엇인가요?</summary>

- SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 모두 보안 통신을 위한 프로토콜이지만, TLS가 SSL의 후속 버전입니다.

- SSL은 Netscape에서 개발한 초기 보안 프로토콜로, SSL 1.0, 2.0, 3.0 버전이 있습니다. 하지만 SSL 1.0과 2.0은 보안 취약점이 발견되어 사용이 중단되었고, SSL 3.0도 POODLE 공격 등으로 인해 현재는 사용하지 않습니다.

- TLS는 SSL의 문제점을 해결하기 위해 개발된 프로토콜로, TLS 1.0, 1.1, 1.2, 1.3 버전이 있습니다. TLS 1.0과 1.1도 보안 취약점이 발견되어 현재는 TLS 1.2 이상을 사용하는 것이 권장됩니다.

- 현재는 SSL이라는 용어가 여전히 사용되지만, 실제로는 TLS를 의미하는 경우가 많습니다. HTTPS도 실제로는 TLS를 사용합니다.

</details>

# 5. 웹소켓과 소켓 통신

<details>
<summary>웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.</summary>

- 웹소켓과 소켓 통신은 모두 네트워크 통신 방식이지만, 사용 목적과 동작 방식이 다릅니다.

- 소켓 통신은 저수준 네트워크 프로그래밍 인터페이스로, TCP/UDP를 직접 사용하여 통신합니다. 클라이언트와 서버가 연결을 설정한 후 양방향으로 데이터를 주고받을 수 있으며, 실시간 통신에 적합합니다.

- 웹소켓은 HTTP 기반의 고수준 프로토콜로, 웹 브라우저와 서버 간의 실시간 양방향 통신을 위해 설계되었습니다. HTTP 핸드셰이크를 통해 연결을 설정한 후 웹소켓 프로토콜로 전환하여 통신합니다.

- 주요 차이점으로는 웹소켓은 웹 환경에 특화되어 있고, 소켓은 범용적인 네트워크 통신에 사용됩니다. 또한 웹소켓은 HTTP 기반이므로 방화벽이나 프록시를 통과하기 쉽습니다.

</details>

<details>
<summary>소켓과 포트의 차이가 무엇인가요?</summary>

- 소켓과 포트는 네트워크 통신에서 서로 다른 역할을 하는 개념입니다.

- 포트는 네트워크 서비스의 주소 역할을 하는 16비트 숫자입니다. 0~65535 범위의 값을 가지며, 특정 서비스나 애플리케이션을 식별하는 데 사용됩니다. 예를 들어 HTTP는 80번, HTTPS는 443번 포트를 사용합니다.

- 소켓은 네트워크 통신의 종점(endpoint)으로, IP 주소와 포트 번호의 조합입니다. 소켓은 실제 통신을 위한 인터페이스를 제공하며, 데이터를 송수신하는 기능을 담당합니다.

- 간단히 말하면, 포트는 "어디로"를 나타내고, 소켓은 "어떻게"를 담당합니다. 소켓을 통해 특정 포트로 데이터를 전송하거나 수신할 수 있습니다.

</details>

<details>
<summary>여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?</summary>

- 소켓의 포트 번호는 상황에 따라 다를 수 있습니다.

- 서버 측에서는 일반적으로 동일한 포트 번호를 사용합니다. 예를 들어 웹 서버는 80번 포트에서 모든 클라이언트의 연결을 받습니다. 하지만 각 클라이언트와의 통신을 위해 새로운 소켓을 생성하지만, 이 소켓들은 모두 같은 포트 번호를 사용합니다.

- 클라이언트 측에서는 일반적으로 다른 포트 번호를 사용합니다. 클라이언트는 서버에 연결할 때 임시 포트(ephemeral port)를 할당받아 사용합니다. 이 포트 번호는 1024~65535 범위에서 동적으로 할당됩니다.

- 따라서 서버는 고정된 포트를 사용하고, 클라이언트는 동적으로 할당된 포트를 사용하여 통신합니다.

</details>

<details>
<summary>사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?</summary>

- 이론적으로는 그럴 수 있지만, 실제로는 여러 제한과 최적화 기법이 있습니다.

- 운영체제는 소켓 생성에 제한을 둡니다. 예를 들어 Linux에서는 파일 디스크립터 제한이 있어서 무한정 소켓을 생성할 수 없습니다. 또한 메모리와 CPU 자원도 제한적입니다.

- 서버는 소켓 풀링이나 스레드 풀링 같은 기법을 사용하여 소켓을 재사용합니다. 연결이 종료되면 소켓을 해제하고 새로운 연결에 재사용할 수 있습니다.

- 또한 비동기 I/O나 이벤트 기반 프로그래밍을 사용하여 적은 수의 소켓으로 많은 연결을 처리할 수 있습니다. 예를 들어 Node.js의 이벤트 루프나 Nginx의 비동기 처리 방식이 이에 해당합니다.

- 따라서 무수히 많은 요청이 와도 시스템의 제한 내에서 효율적으로 처리할 수 있습니다.

</details>

# 6. HTTP 버전

<details>
<summary>HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?</summary>

- HTTP/1.1과 HTTP/2는 웹 통신의 성능과 효율성을 개선하기 위해 발전된 프로토콜입니다.

- HTTP/1.1의 주요 특징으로는 Keep-Alive 연결, 파이프라이닝, 청크 전송 인코딩 등이 있습니다. 하지만 순차적 요청 처리로 인한 HOL(Head-of-Line) 블로킹 문제가 있습니다.

- HTTP/2의 주요 개선사항으로는 멀티플렉싱을 통한 동시 요청 처리, 헤더 압축(HPACK), 서버 푸시, 바이너리 프로토콜 등이 있습니다. 이를 통해 HOL 블로킹 문제를 해결하고 성능을 크게 향상시켰습니다.

- 특히 멀티플렉싱을 통해 하나의 연결에서 여러 요청을 동시에 처리할 수 있어서 연결 수를 줄이고 지연 시간을 단축할 수 있습니다.

</details>

<details>
<summary>HOL Blocking에 대해 설명해 주세요.</summary>

- HOL(Head-of-Line) 블로킹은 네트워크에서 발생하는 성능 문제로, 앞의 요청이 처리되지 않으면 뒤의 요청들이 대기하게 되는 현상입니다.

- HTTP/1.1에서 HOL 블로킹이 발생하는 이유는 순차적 요청 처리 때문입니다. 하나의 연결에서 여러 요청을 보내더라도, 서버는 요청을 순서대로 처리해야 합니다. 따라서 첫 번째 요청이 느리면 나머지 요청들이 모두 대기하게 됩니다.

- 예를 들어, 웹 페이지에 이미지 10개가 있고 첫 번째 이미지 로딩이 매우 느리다면, 나머지 9개 이미지도 모두 첫 번째 이미지가 완료될 때까지 기다려야 합니다.

- HTTP/2에서는 멀티플렉싱을 통해 이 문제를 해결했습니다. 하나의 연결에서 여러 요청을 동시에 처리할 수 있어서, 느린 요청이 다른 요청을 블로킹하지 않습니다.

</details>

<details>
<summary>HTTP/3.0의 주요 특징에 대해 설명해 주세요.</summary>

- HTTP/3는 HTTP의 최신 버전으로, QUIC 프로토콜을 기반으로 하여 더욱 향상된 성능과 보안을 제공합니다.

- 주요 특징으로는 QUIC 프로토콜 사용이 있습니다. HTTP/2까지는 TCP를 사용했지만, HTTP/3는 UDP 기반의 QUIC 프로토콜을 사용합니다. 이를 통해 연결 설정 시간을 단축하고 더 나은 성능을 제공합니다.

- 연결 마이그레이션 기능으로 네트워크가 변경되어도 연결을 유지할 수 있습니다. 예를 들어 WiFi에서 모바일 데이터로 전환되어도 연결이 끊어지지 않습니다.

- 향상된 멀티플렉싱으로 HTTP/2의 HOL 블로킹 문제를 더욱 개선했습니다. QUIC의 스트림은 독립적으로 처리되므로 하나의 스트림에서 문제가 발생해도 다른 스트림에 영향을 주지 않습니다.

- 내장된 암호화로 TLS 1.3을 기본으로 사용하여 보안을 강화했습니다.

</details>

# 7. TCP와 UDP

<details>
<summary>TCP와 UDP의 차이에 대해 설명해 주세요.</summary>

- TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)는 전송 계층의 대표적인 프로토콜로, 각각 다른 특성을 가집니다.

- TCP는 연결 지향적(Connection-oriented) 프로토콜로, 통신 전에 연결을 설정하고 통신 후에 연결을 해제합니다. 신뢰성을 보장하기 위해 순서 보장, 오류 검출 및 재전송, 흐름 제어, 혼잡 제어 등의 기능을 제공합니다.

- UDP는 비연결 지향적(Connectionless) 프로토콜로, 연결 설정 없이 데이터를 전송합니다. 신뢰성 기능이 없어서 빠른 전송이 가능하지만, 데이터 손실이나 순서 변경이 발생할 수 있습니다.

- 용도 측면에서 TCP는 파일 전송, 이메일, 웹 브라우징 등 신뢰성이 중요한 애플리케이션에 사용되고, UDP는 실시간 통신, 스트리밍, DNS 등 속도가 중요한 애플리케이션에 사용됩니다.

</details>

<details>
<summary>Checksum이 무엇인가요?</summary>

- Checksum은 데이터의 무결성을 검증하기 위한 방법으로, 데이터의 내용을 기반으로 계산된 작은 값입니다.

- Checksum 계산 과정은 다음과 같습니다. 먼저 데이터를 일정한 크기의 블록으로 나누고, 각 블록의 값을 더합니다. 그 결과를 특정 크기로 나누어 나머지를 구하고, 이를 Checksum으로 사용합니다.

- 데이터 전송 시 송신자는 데이터와 함께 Checksum을 계산하여 전송하고, 수신자는 받은 데이터로부터 Checksum을 다시 계산하여 전송된 Checksum과 비교합니다. 값이 다르면 데이터가 손상되었음을 알 수 있습니다.

- Checksum은 단순한 오류 검출 방법으로, 데이터 손상을 감지할 수는 있지만 오류를 수정할 수는 없습니다. 오류가 감지되면 데이터를 재전송해야 합니다.

</details>

<details>
<summary>TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?</summary>

- TCP와 UDP 모두 Checksum을 수행합니다. 하지만 구현 방식과 목적이 다릅니다.

- TCP에서는 헤더와 데이터 모두에 대해 Checksum을 계산합니다. 이를 통해 데이터 전송 중 발생할 수 있는 오류를 검출하고, 오류가 발견되면 해당 데이터를 재전송합니다.

- UDP에서도 Checksum을 계산하지만, 선택적(Optional)입니다. UDP 헤더의 Checksum 필드가 0이면 Checksum 검사를 하지 않습니다. 하지만 대부분의 구현에서는 Checksum을 사용합니다.

- UDP의 Checksum은 헤더와 데이터를 포함하여 계산되며, 오류가 감지되면 해당 패킷을 버립니다. 하지만 UDP는 재전송 기능이 없으므로 상위 계층에서 오류 처리를 해야 합니다.

- 두 프로토콜 모두 Checksum을 통해 데이터 무결성을 보장하려고 하지만, TCP는 재전송을 통한 복구가 가능하고 UDP는 불가능합니다.

</details>

<details>
<summary>그렇다면, Checksum을 통해 오류를 정정할 수 있나요?</summary>

- Checksum 자체로는 오류를 정정할 수 없습니다. Checksum은 오류를 검출하는 기능만 제공하고, 오류가 발견되면 해당 데이터를 재전송해야 합니다.

- Checksum은 데이터의 내용을 기반으로 계산된 값이므로, 어떤 비트가 변경되었는지 정확한 위치를 알 수 없습니다. 따라서 손상된 데이터를 원래대로 복구할 수 없습니다.

- 오류 정정이 필요하다면 더 복잡한 방법을 사용해야 합니다. 예를 들어 해밍 코드(Hamming Code)나 리드-솔로몬 코드(Reed-Solomon Code) 같은 오류 정정 코드를 사용할 수 있습니다.

- 하지만 이런 오류 정정 코드는 계산 비용이 높고 오버헤드가 크므로, 일반적인 네트워크 통신에서는 Checksum으로 오류를 검출하고 재전송하는 방식을 사용합니다.

</details>

<details>
<summary>TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.</summary>

- TCP는 여러 메커니즘을 통해 데이터 전송의 신뢰성을 보장합니다.

- 첫 번째는 순서 보장입니다. TCP는 각 바이트에 시퀀스 번호를 부여하여 데이터의 순서를 보장합니다. 수신자는 시퀀스 번호를 확인하여 데이터를 올바른 순서로 재조립합니다.

- 두 번째는 오류 검출 및 재전송입니다. Checksum을 통해 데이터 손상을 검출하고, 손상된 데이터는 재전송합니다. 또한 ACK(Acknowledgment)를 통해 데이터 수신을 확인하고, ACK가 오지 않으면 재전송합니다.

- 세 번째는 흐름 제어입니다. 수신자의 처리 능력을 고려하여 데이터 전송 속도를 조절합니다. 슬라이딩 윈도우 방식을 사용하여 효율적인 데이터 전송을 수행합니다.

- 네 번째는 혼잡 제어입니다. 네트워크의 혼잡 상황을 감지하여 전송 속도를 조절하여 네트워크 안정성을 유지합니다.

</details>

<details>
<summary>TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.</summary>

- TCP의 혼잡 제어는 네트워크의 혼잡 상황을 감지하고 전송 속도를 조절하여 네트워크 안정성을 유지하는 메커니즘입니다.

- 주요 혼잡 제어 알고리즘으로는 Slow Start, Congestion Avoidance, Fast Retransmit, Fast Recovery가 있습니다.

- Slow Start는 연결 초기에 혼잡 윈도우 크기를 점진적으로 증가시키는 방법입니다. 매 RTT(Round Trip Time)마다 윈도우 크기를 2배로 증가시킵니다.

- Congestion Avoidance는 혼잡 윈도우가 임계값에 도달한 후 선형적으로 증가시키는 방법입니다. 매 RTT마다 윈도우 크기를 1씩 증가시킵니다.

- Fast Retransmit은 중복 ACK를 받으면 타임아웃을 기다리지 않고 즉시 재전송하는 방법입니다. Fast Recovery는 Fast Retransmit 후 혼잡 윈도우를 절반으로 줄이고 Congestion Avoidance 단계로 진입하는 방법입니다.

- 이러한 메커니즘을 통해 TCP는 네트워크 혼잡을 감지하고 적절히 대응하여 안정적인 데이터 전송을 보장합니다.

</details>

<details>
<summary>왜 HTTP는 TCP를 사용하나요?</summary>

- HTTP가 TCP를 사용하는 이유는 웹 통신의 특성과 TCP의 장점 때문입니다.

- 첫 번째는 신뢰성입니다. 웹 페이지나 파일을 전송할 때 데이터 손실이나 순서 변경이 발생하면 안 됩니다. TCP의 신뢰성 보장 기능이 이를 해결합니다.

- 두 번째는 순서 보장입니다. 웹 페이지의 HTML, CSS, JavaScript 파일들이 올바른 순서로 로드되어야 합니다. TCP의 순서 보장 기능이 이를 지원합니다.

- 세 번째는 연결 지향적 특성입니다. HTTP는 요청-응답 패턴을 사용하는데, TCP의 연결 설정과 해제가 이를 자연스럽게 지원합니다.

- 네 번째는 흐름 제어입니다. 웹 서버의 처리 능력에 맞춰 데이터를 전송할 수 있어서 서버 과부하를 방지할 수 있습니다.

- 다만 HTTP/3에서는 UDP 기반의 QUIC을 사용하여 TCP의 한계를 극복하고 더 나은 성능을 제공합니다.

</details>

<details>
<summary>그렇다면, 왜 HTTP/3에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?</summary>

- HTTP/3에서 UDP를 사용하는 이유는 TCP의 한계를 극복하고 더 나은 성능을 제공하기 위해서입니다.

- TCP의 주요 문제점으로는 HOL 블로킹이 있습니다. TCP에서는 하나의 스트림에서 패킷 손실이 발생하면 다른 스트림도 영향을 받습니다. 하지만 UDP 기반의 QUIC에서는 각 스트림이 독립적으로 처리되어 이런 문제가 발생하지 않습니다.

- 또한 TCP는 연결 설정에 3-way handshake가 필요하지만, QUIC은 0-RTT 또는 1-RTT로 연결을 설정할 수 있어서 지연 시간을 크게 단축할 수 있습니다.

- UDP의 신뢰성 문제는 QUIC에서 해결됩니다. QUIC은 UDP 위에 신뢰성 보장 기능을 구현하여 TCP와 동일한 수준의 신뢰성을 제공합니다. 순서 보장, 오류 검출 및 재전송, 흐름 제어 등을 모두 지원합니다.

- 따라서 HTTP/3는 UDP의 속도 장점과 QUIC의 신뢰성 보장을 모두 활용하여 더 나은 성능을 제공합니다.

</details>

<details>
<summary>그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?</summary>

- 브라우저는 URL의 프로토콜 스키마를 통해 사용할 전송 프로토콜을 결정합니다.

- HTTP나 HTTPS URL을 사용하면 브라우저는 TCP를 사용합니다. HTTP는 기본적으로 TCP 80번 포트를, HTTPS는 TCP 443번 포트를 사용합니다.

- HTTP/3를 사용하려면 서버가 QUIC을 지원해야 하고, 브라우저도 QUIC을 지원해야 합니다. 서버가 QUIC을 지원하는 경우, 브라우저는 Alt-Svc 헤더나 DNS 레코드를 통해 QUIC 지원을 확인할 수 있습니다.

- 브라우저는 먼저 TCP로 연결을 시도하고, 서버가 QUIC을 지원한다는 정보를 받으면 QUIC 연결을 시도합니다. QUIC 연결이 성공하면 이후 통신은 QUIC을 사용하고, 실패하면 TCP를 계속 사용합니다.

- 사용자는 직접 프로토콜을 선택할 수 없고, 브라우저와 서버가 협의하여 최적의 프로토콜을 선택합니다.

</details>

<details>
<summary>본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?</summary>

- 새로운 통신 프로토콜을 설계할 때는 애플리케이션의 요구사항을 분석하여 적절한 전송 프로토콜을 선택해야 합니다.

- TCP를 선택해야 하는 경우는 신뢰성이 중요한 애플리케이션입니다. 파일 전송, 데이터베이스 동기화, 중요한 메시지 전송 등에서는 데이터 손실이나 순서 변경이 허용되지 않으므로 TCP를 사용합니다.

- UDP를 선택해야 하는 경우는 실시간성이 중요한 애플리케이션입니다. 음성 통화, 비디오 스트리밍, 게임, DNS 조회 등에서는 지연 시간이 더 중요하므로 UDP를 사용합니다.

- 또한 애플리케이션에서 직접 신뢰성을 구현할 수 있다면 UDP를 선택할 수 있습니다. 예를 들어 QUIC처럼 UDP 위에 신뢰성 보장 기능을 구현할 수 있습니다.

- 신뢰성이 우선이면 TCP를, 실시간성이 우선이면 UDP를 선택하되, 필요에 따라 상위 계층에서 추가 기능을 구현하는 것이 좋습니다.

</details>

# 8. DHCP

<details>
<summary>DHCP가 무엇인지 설명해 주세요.</summary>

- DHCP(Dynamic Host Configuration Protocol)는 네트워크에 연결된 장치들이 자동으로 IP 주소와 기타 네트워크 설정 정보를 받을 수 있도록 하는 프로토콜입니다.

- DHCP의 주요 기능으로는 IP 주소 자동 할당이 있습니다. 네트워크 관리자가 수동으로 각 장치에 IP 주소를 할당할 필요 없이, DHCP 서버가 자동으로 사용 가능한 IP 주소를 할당합니다.

- 또한 서브넷 마스크, 게이트웨이, DNS 서버 주소 등 네트워크 설정 정보도 함께 제공합니다. 이를 통해 장치가 네트워크에 연결되면 자동으로 인터넷에 접근할 수 있게 됩니다.

- DHCP는 네트워크 관리의 효율성을 크게 향상시키고, IP 주소 충돌을 방지하며, 장치의 이동성을 지원합니다.

</details>

<details>
<summary>DHCP는 몇 계층 프로토콜인가요?</summary>

- DHCP는 애플리케이션 계층(7계층) 프로토콜입니다.

- DHCP는 UDP를 전송 계층으로 사용하며, 클라이언트는 68번 포트를, 서버는 67번 포트를 사용합니다. UDP를 사용하는 이유는 DHCP 메시지가 작고 간단하며, 신뢰성보다는 속도가 중요하기 때문입니다.

- DHCP는 네트워크 계층의 IP 주소 할당과 관련된 기능을 제공하지만, 실제로는 애플리케이션 계층에서 동작합니다. 이는 DNS와 유사한 구조로, 네트워크 설정과 관련된 기능을 애플리케이션 계층에서 제공하는 것입니다.

- 따라서 DHCP는 OSI 7계층 모델에서 애플리케이션 계층에 해당하며, 네트워크 설정을 위한 고수준 프로토콜입니다.

</details>

<details>
<summary>DHCP는 어떻게 동작하나요?</summary>

- DHCP는 4단계 과정(DHCP 4-way handshake)을 통해 IP 주소를 할당합니다.

- 첫 번째 단계는 DHCP Discover입니다. 클라이언트가 네트워크에 연결되면 브로드캐스트로 DHCP 서버를 찾는 메시지를 전송합니다.

- 두 번째 단계는 DHCP Offer입니다. DHCP 서버가 Discover 메시지를 받으면 사용 가능한 IP 주소와 네트워크 설정 정보를 포함한 Offer 메시지를 브로드캐스트로 전송합니다.

- 세 번째 단계는 DHCP Request입니다. 클라이언트가 여러 서버로부터 Offer를 받으면 하나를 선택하고, 해당 서버에게 Request 메시지를 브로드캐스트로 전송합니다.

- 네 번째 단계는 DHCP ACK입니다. 선택된 DHCP 서버가 Request를 받으면 IP 주소 할당을 확정하고 ACK 메시지를 전송합니다. 이때 클라이언트는 할당받은 IP 주소를 사용할 수 있게 됩니다.

</details>

<details>
<summary>DHCP에서 UDP를 사용하는 이유가 무엇인가요?</summary>

- DHCP에서 UDP를 사용하는 이유는 여러 가지가 있습니다.

- 첫 번째는 연결 설정이 불필요하기 때문입니다. DHCP는 네트워크 설정을 위한 프로토콜이므로, 아직 IP 주소가 할당되지 않은 상태에서 동작해야 합니다. TCP는 연결 설정이 필요하지만, UDP는 연결 없이 바로 메시지를 전송할 수 있습니다.

- 두 번째는 메시지 크기가 작기 때문입니다. DHCP 메시지는 상대적으로 작고 간단하므로 UDP의 오버헤드로도 충분히 처리할 수 있습니다.

- 세 번째는 브로드캐스트 사용 때문입니다. DHCP는 브로드캐스트를 사용하여 네트워크 내의 모든 장치와 통신해야 하는데, UDP가 브로드캐스트에 더 적합합니다.

- 네 번째는 속도입니다. DHCP는 빠른 IP 주소 할당이 중요하므로, 신뢰성보다는 속도를 우선시하는 UDP가 적합합니다.

</details>

<details>
<summary>DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요?</summary>

- DHCP는 IP 주소 외에도 다양한 네트워크 설정 정보를 제공합니다.

- 서브넷 마스크는 네트워크의 크기를 나타내는 정보로, IP 주소와 함께 제공됩니다. 이를 통해 장치가 같은 네트워크에 있는 다른 장치들을 식별할 수 있습니다.

- 게이트웨이 주소는 다른 네트워크로의 출구 역할을 하는 라우터의 IP 주소입니다. 이를 통해 장치가 인터넷이나 다른 네트워크에 접근할 수 있습니다.

- DNS 서버 주소는 도메인 이름을 IP 주소로 변환하는 서버의 주소입니다. 이를 통해 장치가 웹사이트에 접근할 수 있습니다.

- 기타 정보로는 도메인 이름, WINS 서버 주소, IP 주소 임대 기간 등이 있습니다. 이러한 정보들을 통해 장치는 네트워크에 완전히 연결되고 인터넷을 사용할 수 있게 됩니다.

</details>

<details>
<summary>DHCP의 유효기간은 얼마나 긴가요?</summary>

- DHCP의 유효기간(임대 기간)은 네트워크 관리자가 설정할 수 있으며, 일반적으로 몇 시간에서 며칠 정도입니다.

- 기본적으로 DHCP 서버는 IP 주소를 임대(lease) 형태로 제공합니다. 클라이언트는 할당받은 IP 주소를 일정 기간 동안 사용할 수 있으며, 이 기간이 만료되면 IP 주소를 반납하거나 갱신해야 합니다.

- 일반적인 임대 기간은 24시간(1일)에서 168시간(7일) 정도입니다. 하지만 네트워크 환경에 따라 다를 수 있습니다. 예를 들어, 모바일 장치가 많은 네트워크에서는 짧은 임대 기간(1-2시간)을 사용하고, 데스크톱이 많은 네트워크에서는 긴 임대 기간(7일 이상)을 사용할 수 있습니다.

- 임대 기간이 만료되기 전에 클라이언트는 DHCP Request를 통해 임대를 갱신할 수 있습니다. 이를 통해 동일한 IP 주소를 계속 사용할 수 있습니다.

</details>

# 9. IP 주소

<details>
<summary>IP 주소는 무엇이며, 어떤 기능을 하고 있나요?</summary>

- IP 주소(Internet Protocol Address)는 네트워크에 연결된 각 장치를 고유하게 식별하는 숫자 주소입니다. 인터넷에서 데이터를 전송할 때 목적지와 출발지를 지정하는 역할을 합니다.

- IP 주소의 주요 기능으로는 장치 식별이 있습니다. 네트워크에 연결된 모든 장치는 고유한 IP 주소를 가져야 하며, 이를 통해 다른 장치와 통신할 수 있습니다.

- 또한 라우팅 기능을 제공합니다. 라우터는 IP 주소를 기반으로 데이터 패킷을 적절한 목적지로 전달합니다. IP 주소의 네트워크 부분을 통해 목적지 네트워크를 식별하고, 호스트 부분을 통해 해당 네트워크 내의 특정 장치를 식별합니다.

- IP 주소는 계층적 구조를 가지고 있어서 네트워크 관리와 라우팅을 효율적으로 수행할 수 있습니다.

</details>

<details>
<summary>IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요?</summary>

- IPv4 주소 고갈 문제를 해결하기 위한 여러 방법들이 있습니다.

- 첫 번째는 NAT(Network Address Translation)입니다. 사설 IP 주소를 사용하여 내부 네트워크를 구성하고, 공인 IP 주소 하나로 여러 장치가 인터넷에 접근할 수 있게 합니다. 이를 통해 공인 IP 주소의 사용량을 크게 줄일 수 있습니다.

- 두 번째는 CIDR(Classless Inter-Domain Routing)입니다. 기존의 클래스 기반 주소 할당 방식을 개선하여 IP 주소를 더 효율적으로 사용할 수 있게 합니다.

- 세 번째는 DHCP입니다. 동적으로 IP 주소를 할당하고 회수하여 사용하지 않는 IP 주소를 재활용할 수 있습니다.

- 네 번째는 IPv6 전환입니다. IPv6는 128비트 주소를 사용하여 거의 무한대의 주소를 제공하므로, 장기적으로는 IPv6로 전환하는 것이 근본적인 해결책입니다.

</details>

<details>
<summary>IPv4와 IPv6의 차이에 대해 설명해 주세요.</summary>

- IPv4와 IPv6는 IP 프로토콜의 서로 다른 버전으로, 여러 측면에서 차이가 있습니다.

- 주소 길이에서 IPv4는 32비트(4바이트)를 사용하여 약 43억 개의 주소를 제공하지만, IPv6는 128비트(16바이트)를 사용하여 거의 무한대의 주소를 제공합니다.

- 주소 표현 방식에서 IPv4는 점으로 구분된 10진수(예: 192.168.1.1)를 사용하지만, IPv6는 콜론으로 구분된 16진수(예: 2001:0db8:85a3:0000:0000:8a2e:0370:7334)를 사용합니다.

- 헤더 구조에서 IPv4는 가변 길이 헤더를 사용하지만, IPv6는 고정 길이 헤더를 사용하여 처리 효율성을 높였습니다.

- 보안 기능에서 IPv4는 IPSec이 선택사항이지만, IPv6는 IPSec이 기본으로 포함되어 있습니다.

- 자동 설정 기능에서 IPv6는 더 강력한 자동 설정 기능을 제공하여 네트워크 설정을 더 쉽게 할 수 있습니다.

</details>

<details>
<summary>수많은 사람들이 유동 IP를 사용하고 있지만, 수많은 공유기에서는 고정 주소를 제공하는 기능이 이미 존재합니다. 어떻게 가능한 걸까요?</summary>

- 공유기에서 고정 주소를 제공하는 기능은 여러 기술을 조합하여 구현됩니다.

- 첫 번째는 DHCP 예약 기능입니다. 공유기는 DHCP 서버 역할을 하며, 특정 MAC 주소에 대해 항상 동일한 IP 주소를 할당하도록 설정할 수 있습니다. 이를 통해 해당 장치는 항상 같은 IP 주소를 받게 됩니다.

- 두 번째는 NAT 테이블 관리입니다. 공유기는 내부 네트워크의 사설 IP 주소와 외부 네트워크의 공인 IP 주소 간의 매핑을 관리합니다. 고정 주소를 사용하는 장치에 대해서는 특별한 NAT 규칙을 적용할 수 있습니다.

- 세 번째는 포트 포워딩 기능입니다. 특정 포트로 들어오는 요청을 고정 주소를 사용하는 장치로 전달할 수 있습니다.

- 이러한 기능들을 통해 공유기는 유동 IP 환경에서도 특정 장치에 대해 고정 주소를 제공할 수 있습니다.

</details>

<details>
<summary>IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요?</summary>

- IPv4와 IPv6는 서로 다른 프로토콜이므로 직접 통신할 수 없습니다. 하지만 여러 방법을 통해 상호 운용성을 제공할 수 있습니다.

- 첫 번째는 듀얼 스택(Dual Stack)입니다. 장치가 IPv4와 IPv6를 모두 지원하도록 설정하여, 통신 상대에 따라 적절한 프로토콜을 선택하여 사용합니다.

- 두 번째는 터널링(Tunneling)입니다. IPv6 패킷을 IPv4 패킷 안에 캡슐화하여 IPv4 네트워크를 통해 전송하는 방법입니다. 6to4, Teredo 등이 대표적인 터널링 기술입니다.

- 세 번째는 번역(Translation)입니다. IPv4와 IPv6 간의 주소와 패킷을 변환하는 방법입니다. NAT64, SIIT 등이 대표적인 번역 기술입니다.

- 네 번째는 프록시입니다. IPv4와 IPv6 간의 통신을 중계하는 프록시 서버를 사용하는 방법입니다.

- 이러한 방법들을 통해 IPv4와 IPv6 환경이 공존하는 네트워크에서 통신이 가능합니다.

</details>

<details>
<summary>IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요?</summary>

- IP 자체로는 송신자와 수신자를 정확하게 전송하는 것을 보장하지 않습니다. IP는 "최선의 노력(Best Effort)" 서비스를 제공하는 비연결형 프로토콜입니다.

- IP의 한계로는 패킷 손실, 순서 변경, 중복 전송 등이 있습니다. 네트워크 혼잡이나 오류로 인해 패킷이 손실될 수 있고, 다른 경로를 통해 전송되어 순서가 바뀔 수 있습니다.

- 하지만 상위 계층 프로토콜이 이러한 문제를 해결합니다. TCP는 신뢰성을 보장하기 위해 순서 보장, 오류 검출 및 재전송, 흐름 제어 등의 기능을 제공합니다.

- 또한 라우팅 프로토콜과 라우터가 올바른 경로를 찾아 패킷을 전달하도록 도와줍니다. 하지만 완벽한 보장은 없고, 네트워크 상황에 따라 성능이 달라질 수 있습니다.

- 따라서 IP는 기본적인 전송 기능을 제공하고, 신뢰성이 필요한 경우 상위 계층에서 추가적인 보장 메커니즘을 구현해야 합니다.

</details>

<details>
<summary>IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?</summary>

- IPv4와 TCP의 Checksum은 서로 다른 범위와 목적을 가지고 있습니다.

- IPv4 Checksum은 IP 헤더만을 대상으로 합니다. IP 헤더의 무결성을 검증하여 라우팅 과정에서 헤더가 손상되지 않았는지 확인합니다. 데이터 부분은 검증하지 않습니다.

- TCP Checksum은 TCP 헤더와 데이터를 모두 대상으로 합니다. TCP 세그먼트 전체의 무결성을 검증하여 데이터 전송 과정에서 손상이 발생하지 않았는지 확인합니다.

- 검증 범위에서 IPv4는 헤더만 검증하므로 빠르지만, TCP는 헤더와 데이터를 모두 검증하므로 더 포괄적입니다.

- 목적에서 IPv4 Checksum은 라우팅 과정의 신뢰성을 보장하고, TCP Checksum은 데이터 전송의 신뢰성을 보장합니다.

- 따라서 두 Checksum은 서로 다른 계층에서 서로 다른 목적으로 사용되며, 함께 작동하여 전체적인 네트워크 통신의 신뢰성을 보장합니다.

</details>

<details>
<summary>TTL(Hop Limit)이란 무엇인가요?</summary>

- TTL(Time To Live)은 IP 패킷이 네트워크에서 살아있을 수 있는 최대 시간이나 홉(hop) 수를 나타내는 값입니다.

- TTL의 주요 목적은 패킷이 네트워크에서 무한히 순환하는 것을 방지하는 것입니다. 라우팅 오류나 네트워크 구성 문제로 인해 패킷이 목적지에 도달하지 못하고 계속 순환할 수 있는데, TTL이 이를 방지합니다.

- 동작 방식은 다음과 같습니다. 패킷이 라우터를 통과할 때마다 TTL 값이 1씩 감소하고, TTL이 0이 되면 해당 패킷은 버려집니다. 이때 ICMP Time Exceeded 메시지를 송신자에게 전송합니다.

- TTL 값은 운영체제나 애플리케이션에 따라 다르게 설정됩니다. 일반적으로 Windows는 128, Linux는 64, 네트워크 장비는 255 정도의 값을 사용합니다.

- TTL은 또한 네트워크 진단 도구인 traceroute에서도 사용됩니다. TTL 값을 점진적으로 증가시키면서 패킷을 전송하여 목적지까지의 경로를 추적할 수 있습니다.

</details>

<details>
<summary>IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.</summary>

- IP 주소와 MAC 주소는 서로 다른 계층에서 사용되는 주소로, 각각 다른 목적과 특성을 가집니다.

- IP 주소는 네트워크 계층(3계층)에서 사용되는 논리적 주소입니다. 네트워크 전체에서 고유하게 식별되는 주소로, 라우팅을 통해 목적지까지 패킷을 전달하는 데 사용됩니다. IP 주소는 변경 가능하며, 네트워크 관리자가 할당합니다.

- MAC 주소는 데이터 링크 계층(2계층)에서 사용되는 물리적 주소입니다. 네트워크 인터페이스 카드(NIC)에 하드웨어적으로 할당된 고유한 주소로, 같은 네트워크 내에서 직접 통신할 때 사용됩니다. MAC 주소는 변경할 수 없으며, 제조사가 할당합니다.

- 주소 길이에서 IP 주소는 IPv4의 경우 32비트, IPv6의 경우 128비트이지만, MAC 주소는 48비트입니다.

- 사용 범위에서 IP 주소는 전 세계적으로 고유하지만, MAC 주소는 같은 네트워크 내에서만 고유합니다.

- 통신 과정에서 IP 주소는 목적지까지의 경로를 찾는 데 사용되고, MAC 주소는 최종 목적지에 도달하기 위한 마지막 단계에서 사용됩니다.

</details>

# 10. OSI 7계층

<details>
<summary>OSI 7계층에 대해 설명해 주세요.</summary>

- OSI 7계층 모델은 네트워크 통신을 7개의 계층으로 나누어 설명하는 표준 모델입니다. 각 계층은 특정한 기능을 담당하며, 상위 계층은 하위 계층의 서비스를 사용합니다.

- 7계층(응용 계층): 사용자와 직접 상호작용하는 애플리케이션 계층입니다. HTTP, FTP, SMTP 등이 이 계층에 해당합니다.

- 6계층(표현 계층): 데이터의 형식 변환, 암호화, 압축 등을 담당합니다. JPEG, MPEG, ASCII 등이 이 계층에 해당합니다.

- 5계층(세션 계층): 통신 세션의 설정, 관리, 종료를 담당합니다. RPC, SQL 등이 이 계층에 해당합니다.

- 4계층(전송 계층): 종단 간 신뢰성 있는 데이터 전송을 담당합니다. TCP, UDP가 이 계층에 해당합니다.

- 3계층(네트워크 계층): 라우팅과 논리적 주소 지정을 담당합니다. IP, ICMP가 이 계층에 해당합니다.

- 2계층(데이터 링크 계층): 물리적 링크에서의 오류 검출 및 수정을 담당합니다. Ethernet, PPP가 이 계층에 해당합니다.

- 1계층(물리 계층): 실제 물리적 전송을 담당합니다. 케이블, 허브, 리피터 등이 이 계층에 해당합니다.

</details>

<details>
<summary>Transport Layer와 Network Layer의 차이에 대해 설명해 주세요.</summary>

- Transport Layer(전송 계층)와 Network Layer(네트워크 계층)는 서로 다른 계층에서 서로 다른 기능을 담당합니다.

- Network Layer는 라우팅과 논리적 주소 지정을 담당합니다. IP 주소를 사용하여 패킷을 목적지까지 전달하는 경로를 찾고, 패킷을 다음 홉으로 전달합니다. 라우터가 이 계층에서 동작합니다.

- Transport Layer는 종단 간 신뢰성 있는 데이터 전송을 담당합니다. 포트 번호를 사용하여 특정 애플리케이션을 식별하고, TCP나 UDP를 통해 데이터의 신뢰성을 보장합니다.

- 범위 측면에서 Network Layer는 네트워크 전체를 대상으로 하며, Transport Layer는 특정 호스트의 특정 애플리케이션을 대상으로 합니다.

- 기능 측면에서 Network Layer는 패킷 전달에 집중하고, Transport Layer는 데이터 전송의 품질에 집중합니다.

- 따라서 Network Layer는 "어디로"를 담당하고, Transport Layer는 "어떻게"를 담당한다고 할 수 있습니다.

</details>

<details>
<summary>L3 Switch와 Router의 차이에 대해 설명해 주세요.</summary>

- L3 Switch와 Router는 모두 네트워크 계층에서 동작하는 장비이지만, 구현 방식과 성능에서 차이가 있습니다.

- Router는 소프트웨어 기반으로 동작하는 범용 장비입니다. CPU를 사용하여 라우팅 테이블을 조회하고 패킷을 전달하므로, 처리 속도가 상대적으로 느립니다. 하지만 다양한 프로토콜을 지원하고 복잡한 라우팅 정책을 구현할 수 있습니다.

- L3 Switch는 하드웨어 기반으로 동작하는 특화된 장비입니다. ASIC(Application-Specific Integrated Circuit)을 사용하여 라우팅을 수행하므로, 처리 속도가 매우 빠릅니다. 하지만 지원하는 기능이 제한적일 수 있습니다.

- 용도 측면에서 Router는 WAN 연결이나 복잡한 라우팅이 필요한 환경에 적합하고, L3 Switch는 LAN 내에서 고속 라우팅이 필요한 환경에 적합합니다.

- 비용 측면에서 Router는 상대적으로 저렴하지만, L3 Switch는 고성능을 위해 더 비쌀 수 있습니다.

- 최근에는 경계가 모호해지고 있으며, 고성능 Router나 고기능 L3 Switch가 등장하고 있습니다.

</details>

<details>
<summary>각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.</summary>

- OSI 7계층 모델에서 각 계층은 데이터 단위에 대해 서로 다른 명칭을 사용합니다.

- 7계층(응용 계층): Data 또는 Message라고 부릅니다. 사용자 데이터 그 자체를 의미합니다.

- 6계층(표현 계층): Data 또는 Message라고 부릅니다. 암호화나 압축된 사용자 데이터를 의미합니다.

- 5계층(세션 계층): Data 또는 Message라고 부릅니다. 세션 정보가 추가된 데이터를 의미합니다.

- 4계층(전송 계층): Segment(TCP) 또는 Datagram(UDP)라고 부릅니다. 전송 계층 헤더가 추가된 데이터를 의미합니다.

- 3계층(네트워크 계층): Packet이라고 부릅니다. IP 헤더가 추가된 데이터를 의미합니다.

- 2계층(데이터 링크 계층): Frame이라고 부릅니다. Ethernet 헤더와 트레일러가 추가된 데이터를 의미합니다.

- 1계층(물리 계층): Bit라고 부릅니다. 실제 전송되는 비트 스트림을 의미합니다.

- 이러한 명칭은 각 계층에서 추가되는 헤더와 관련이 있으며, 데이터가 하위 계층으로 전달될 때마다 새로운 명칭을 가지게 됩니다.

</details>

<details>
<summary>각각의 Header의 Packing Order에 대해 설명해 주세요.</summary>

- 네트워크 패킷에서 헤더는 특정한 순서로 배치되며, 이는 네트워크 통신의 효율성과 호환성을 위해 중요합니다.

- 일반적인 헤더 순서는 다음과 같습니다. 가장 바깥쪽(물리 계층)에서 안쪽(응용 계층) 순으로 배치됩니다.

- Ethernet Header(2계층): 목적지 MAC 주소, 송신자 MAC 주소, EtherType 등이 포함됩니다.

- IP Header(3계층): 버전, 헤더 길이, 서비스 타입, 총 길이, 식별자, 플래그, TTL, 프로토콜, 체크섬, 송신자 IP, 수신자 IP 등이 포함됩니다.

- TCP/UDP Header(4계층): TCP의 경우 송신자 포트, 수신자 포트, 시퀀스 번호, ACK 번호, 헤더 길이, 플래그, 윈도우 크기, 체크섬, 긴급 포인터 등이 포함됩니다.

- Application Header(7계층): HTTP, FTP 등 애플리케이션별 헤더가 포함됩니다.

- 헤더 순서는 하위 계층에서 상위 계층 순으로 배치되며, 각 계층은 자신의 헤더를 추가하고 하위 계층으로 전달합니다.

- 수신 측에서는 역순으로 헤더를 제거하면서 상위 계층으로 데이터를 전달합니다.

</details>

<details>
<summary>ARP에 대해 설명해 주세요.</summary>

- ARP(Address Resolution Protocol)는 IP 주소를 MAC 주소로 변환하는 프로토콜입니다. 같은 네트워크 내에서 통신할 때 IP 주소만으로는 실제 데이터 전송이 불가능하므로, MAC 주소가 필요합니다.

- ARP의 동작 과정은 다음과 같습니다. 먼저 송신자가 목적지 IP 주소에 해당하는 MAC 주소를 찾기 위해 ARP Request를 브로드캐스트로 전송합니다.

- 해당 IP 주소를 가진 장치는 ARP Reply를 유니캐스트로 전송하여 자신의 MAC 주소를 알려줍니다. 다른 장치들은 이 요청을 무시합니다.

- 송신자는 받은 MAC 주소를 ARP 캐시에 저장하여 다음에 같은 IP 주소와 통신할 때 재사용합니다.

- ARP는 2계층 프로토콜이지만 3계층의 IP와 밀접한 관련이 있습니다. IP 주소를 MAC 주소로 변환하는 기능을 제공하여 네트워크 계층과 데이터 링크 계층을 연결합니다.

- ARP 캐시는 일정 시간 후에 만료되며, 이를 통해 네트워크 구성 변경에 대응할 수 있습니다.

</details>

# 11. 3-Way Handshake

<details>
<summary>3-Way Handshake에 대해 설명해 주세요.</summary>

- 3-Way Handshake는 TCP 연결을 설정하는 과정으로, 클라이언트와 서버 간의 신뢰성 있는 연결을 보장하기 위해 사용됩니다.

- 첫 번째 단계는 SYN(Synchronize)입니다. 클라이언트가 서버에게 연결 요청을 보내며, 이때 클라이언트의 초기 시퀀스 번호를 포함합니다.

- 두 번째 단계는 SYN-ACK입니다. 서버가 클라이언트의 요청을 받고, 서버의 초기 시퀀스 번호와 클라이언트의 시퀀스 번호에 대한 ACK를 함께 전송합니다.

- 세 번째 단계는 ACK입니다. 클라이언트가 서버의 응답을 받고, 서버의 시퀀스 번호에 대한 ACK를 전송합니다.

- 이 과정을 통해 양쪽 모두 상대방의 시퀀스 번호를 확인하고, 연결이 설정되었음을 보장할 수 있습니다.

- 3-Way Handshake는 TCP의 신뢰성 보장 메커니즘의 핵심이며, 모든 TCP 연결은 이 과정을 거쳐야 합니다.

</details>

<details>
<summary>ACK, SYN 같은 정보는 어떻게 전달하는 것일까요?</summary>

- ACK, SYN 같은 정보는 TCP 헤더의 플래그 필드를 통해 전달됩니다.

- TCP 헤더에는 여러 플래그 비트가 있으며, 각각 특정한 의미를 가집니다. SYN 플래그는 연결 요청을 나타내고, ACK 플래그는 확인 응답을 나타냅니다.

- 플래그는 비트 단위로 설정되므로, 여러 플래그를 동시에 설정할 수 있습니다. 예를 들어 SYN-ACK는 SYN 플래그와 ACK 플래그를 모두 1로 설정한 것입니다.

- TCP 헤더의 구조는 다음과 같습니다. 송신자 포트, 수신자 포트, 시퀀스 번호, ACK 번호, 헤더 길이, 플래그, 윈도우 크기, 체크섬, 긴급 포인터 등이 포함됩니다.

- 플래그 필드는 6비트로 구성되며, URG, ACK, PSH, RST, SYN, FIN 플래그를 포함합니다. 각 플래그는 1비트로 표현되며, 해당 기능이 활성화되면 1, 비활성화되면 0으로 설정됩니다.

- 이러한 방식으로 TCP는 연결 상태와 제어 정보를 효율적으로 전달할 수 있습니다.

</details>

<details>
<summary>2-Way Handshaking을 하지않는 이유에 대해 설명해 주세요.</summary>

- 2-Way Handshaking을 하지 않는 이유는 연결의 신뢰성을 보장하기 위해서입니다.

- 2-Way Handshaking의 문제점은 다음과 같습니다. 첫 번째로, 클라이언트가 서버의 응답을 받지 못했을 때 클라이언트는 연결이 설정되었는지 확신할 수 없습니다.

- 두 번째로, 네트워크 지연이나 패킷 손실로 인해 서버의 응답이 늦게 도착할 수 있습니다. 이 경우 클라이언트는 연결이 실패했다고 판단하고 재시도할 수 있습니다.

- 세 번째로, 서버의 상태를 확인할 수 없습니다. 서버가 실제로 연결 요청을 받았는지, 연결을 수락했는지 확인할 수 없습니다.

- 3-Way Handshaking은 이러한 문제를 해결합니다. 클라이언트가 서버의 응답을 받고, 서버가 클라이언트의 확인을 받음으로써 양쪽 모두 연결이 설정되었음을 보장할 수 있습니다.

- 따라서 TCP는 3-Way Handshaking을 사용하여 더 신뢰성 있는 연결을 보장합니다.

</details>

<details>
<summary>두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?</summary>

- 네, 두 호스트가 동시에 연결을 시도해도 연결이 가능합니다. TCP는 이러한 상황을 처리할 수 있는 메커니즘을 제공합니다.

- 동시 연결 시도 시 TCP는 다음과 같이 동작합니다. 각 호스트는 상대방에게 SYN을 보내고, 상대방의 SYN을 받으면 SYN-ACK를 보냅니다.

- 그 다음 각 호스트는 상대방의 SYN-ACK를 받고 ACK를 보냅니다. 이 과정을 통해 양쪽 모두 연결이 설정됩니다.

- 중요한 점은 각 호스트가 서로 다른 포트를 사용한다는 것입니다. 예를 들어 호스트 A는 포트 80으로, 호스트 B는 포트 8080으로 연결을 시도할 수 있습니다.

- 또한 TCP는 연결 상태를 관리하는 상태 머신을 사용하여, 동시 연결 시도도 올바르게 처리할 수 있습니다.

- 이러한 방식으로 TCP는 양방향 연결을 지원하며, 두 호스트가 동시에 연결을 시도해도 정상적으로 연결을 설정할 수 있습니다.

</details>

<details>
<summary>SYN Flooding에 대해 설명해 주세요.</summary>

- SYN Flooding은 TCP의 3-Way Handshake 과정을 악용한 DoS(Denial of Service) 공격입니다.

- 공격 방식은 다음과 같습니다. 공격자가 서버에게 대량의 SYN 요청을 보내지만, 마지막 ACK를 보내지 않습니다. 이로 인해 서버는 대기 상태에 있는 연결 요청으로 인해 리소스를 소모하게 됩니다.

- 서버는 SYN-ACK를 보낸 후 클라이언트의 ACK를 기다리는 상태가 되는데, 이 상태를 SYN_RECEIVED라고 합니다. 이 상태의 연결은 서버의 메모리와 리소스를 소모합니다.

- 공격자가 대량의 SYN 요청을 보내면 서버는 SYN_RECEIVED 상태의 연결로 인해 리소스가 고갈되어 정상적인 서비스를 제공할 수 없게 됩니다.

- SYN Flooding 방어 방법으로는 SYN 쿠키, 연결 제한, 방화벽 설정 등이 있습니다. SYN 쿠키는 서버가 클라이언트의 정보를 쿠키로 인코딩하여 상태를 유지하지 않는 방법입니다.

- 이러한 공격을 방어하기 위해 네트워크 관리자는 적절한 보안 조치를 취해야 합니다.

</details>

<details>
<summary>위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?</summary>

- 0-RTT(Zero Round Trip Time) 기법은 이전에 연결된 적이 있는 클라이언트와 서버 간에 빠른 연결 재설정을 가능하게 하는 기술입니다.

- 0-RTT의 동작 방식은 다음과 같습니다. 클라이언트가 이전에 서버와 연결한 적이 있다면, 서버는 클라이언트의 정보를 캐시에 저장합니다.

- 다음에 클라이언트가 연결을 시도할 때, 클라이언트는 이전 연결 정보를 포함한 특별한 메시지를 보냅니다. 서버는 이 정보를 확인하여 즉시 연결을 설정할 수 있습니다.

- TLS 1.3에서는 0-RTT를 지원하여, 이전에 연결된 적이 있는 클라이언트와 서버 간에 빠른 암호화 연결을 설정할 수 있습니다.

- 하지만 0-RTT는 보안상 위험이 있을 수 있습니다. 이전 연결 정보가 노출되면 공격자가 이를 악용할 수 있으므로, 적절한 보안 조치가 필요합니다.

- 따라서 0-RTT는 성능 향상을 위해 사용되지만, 보안을 고려하여 신중하게 구현해야 합니다.

</details>

# 12. 4-Way Handshake

<details>
<summary>4-Way Handshake에 대해 설명해 주세요.</summary>

- 4-Way Handshake는 TCP 연결을 종료하는 과정으로, 클라이언트와 서버 간의 안전한 연결 해제를 보장하기 위해 사용됩니다.

- 첫 번째 단계는 FIN(Finish)입니다. 연결을 종료하고자 하는 쪽(보통 클라이언트)이 상대방에게 FIN 플래그를 설정한 세그먼트를 전송합니다.

- 두 번째 단계는 ACK입니다. FIN을 받은 쪽은 해당 세그먼트에 대한 ACK를 전송하여 FIN을 받았음을 확인합니다.

- 세 번째 단계는 FIN입니다. ACK를 보낸 쪽도 자신의 데이터 전송이 완료되면 상대방에게 FIN 플래그를 설정한 세그먼트를 전송합니다.

- 네 번째 단계는 ACK입니다. 마지막으로 FIN을 받은 쪽은 해당 세그먼트에 대한 ACK를 전송하여 연결 종료를 완료합니다.

- 이 과정을 통해 양쪽 모두 연결이 종료되었음을 확인하고, 안전하게 연결을 해제할 수 있습니다.

</details>

<details>
<summary>패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?</summary>

- 패킷이 4-way handshake 목적인지 파악하는 방법은 TCP 헤더의 플래그 필드를 확인하는 것입니다.

- 4-way handshake에서 사용되는 플래그는 FIN과 ACK입니다. FIN 플래그는 연결 종료를 요청하는 플래그이고, ACK 플래그는 확인 응답을 나타내는 플래그입니다.

- 패킷의 플래그 조합을 확인하여 4-way handshake 단계를 파악할 수 있습니다. FIN만 설정된 패킷은 첫 번째 단계이고, FIN과 ACK가 모두 설정된 패킷은 세 번째 단계입니다.

- 또한 시퀀스 번호와 ACK 번호를 확인하여 연결 종료 과정의 순서를 파악할 수 있습니다.

- 네트워크 분석 도구나 패킷 캡처 도구를 사용하면 이러한 정보를 쉽게 확인할 수 있습니다.

</details>

<details>
<summary>빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?</summary>

- 4-way Handshake를 할 여유가 없는 경우에는 RST(Reset) 플래그를 사용하여 연결을 강제로 종료할 수 있습니다.

- RST 플래그는 TCP 연결을 즉시 종료하는 플래그로, 정상적인 연결 종료 과정을 거치지 않고 연결을 강제로 끊습니다.

- RST를 사용하는 경우는 다음과 같습니다. 네트워크 장애로 인해 정상적인 연결 종료가 불가능한 경우, 보안상의 이유로 즉시 연결을 끊어야 하는 경우, 애플리케이션 오류로 인해 연결을 강제로 종료해야 하는 경우 등입니다.

- RST를 사용하면 연결이 즉시 종료되지만, 데이터 손실이 발생할 수 있습니다. 따라서 가능한 한 정상적인 4-way Handshake를 사용하는 것이 좋습니다.

- RST는 TCP 헤더의 플래그 필드에 설정되며, 수신 측에서는 RST를 받으면 즉시 연결을 종료합니다.

</details>

<details>
<summary>4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?</summary>

- 4-Way Handshake 과정에서 한쪽 네트워크가 강제로 종료되면, 반대쪽은 여러 방법으로 이를 인식할 수 있습니다.

- 첫 번째는 타임아웃입니다. TCP는 각 단계에서 일정 시간 동안 응답을 기다리고, 응답이 오지 않으면 타임아웃으로 연결을 종료합니다.

- 두 번째는 Keep-Alive 메커니즘입니다. TCP는 주기적으로 Keep-Alive 패킷을 보내서 연결 상태를 확인하고, 응답이 없으면 연결이 끊어진 것으로 판단합니다.

- 세 번째는 애플리케이션 레벨에서의 감지입니다. 애플리케이션에서 데이터 전송을 시도했을 때 오류가 발생하면 연결이 끊어진 것으로 판단할 수 있습니다.

- 네 번째는 네트워크 레벨에서의 감지입니다. 라우터나 스위치에서 연결 상태를 모니터링하여 연결이 끊어진 것을 감지할 수 있습니다.

- 이러한 방법들을 통해 한쪽 네트워크가 강제로 종료되어도 반대쪽에서 이를 인식하고 적절히 대응할 수 있습니다.

</details>

<details>
<summary>왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것일까요?</summary>

- TCP 연결 종료 후 TIME_WAIT 상태로 대기하는 이유는 여러 가지가 있습니다.

- 첫 번째는 지연된 패킷 처리입니다. 네트워크 지연으로 인해 이전 연결의 패킷이 늦게 도착할 수 있는데, TIME_WAIT 상태에서는 이러한 패킷을 버릴 수 있습니다.

- 두 번째는 연결 상태 정리입니다. TIME_WAIT 상태에서는 연결과 관련된 모든 리소스를 정리하고, 새로운 연결을 위해 준비할 수 있습니다.

- 세 번째는 시퀀스 번호 충돌 방지입니다. 이전 연결의 시퀀스 번호와 새로운 연결의 시퀀스 번호가 충돌하는 것을 방지할 수 있습니다.

- TIME_WAIT 상태의 지속 시간은 일반적으로 2MSL(Maximum Segment Lifetime)입니다. MSL은 패킷이 네트워크에서 살아있을 수 있는 최대 시간으로, 일반적으로 30초에서 2분 정도입니다.

- 따라서 TIME_WAIT 상태는 TCP의 신뢰성과 안정성을 보장하기 위한 중요한 메커니즘입니다.

</details>

# 13. 웹 브라우저 동작 과정

<details>
<summary>www.github.com을 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.</summary>

- www.github.com 를 브라우저에 입력하고 엔터를 치면 다음과 같은 과정이 진행됩니다:

- 첫 번째로 DNS 쿼리가 발생합니다. 브라우저는 www.github.com 의 IP 주소를 찾기 위해 DNS 서버에 쿼리를 보냅니다. 이 과정에서 로컬 DNS 캐시, ISP DNS 서버, 루트 DNS 서버, TLD DNS 서버, 권한 DNS 서버를 순차적으로 조회합니다.

- 두 번째로 TCP 연결을 설정합니다. DNS 쿼리를 통해 얻은 IP 주소로 TCP 3-way handshake를 수행하여 연결을 설정합니다.

- 세 번째로 TLS/SSL 핸드셰이크를 수행합니다. HTTPS를 사용하는 경우 서버와 암호화 연결을 설정합니다.

- 네 번째로 HTTP 요청을 전송합니다. 브라우저는 서버에게 GET 요청을 보내어 웹 페이지를 요청합니다.

- 다섯 번째로 서버가 응답을 전송합니다. 서버는 요청받은 웹 페이지의 HTML, CSS, JavaScript 파일을 전송합니다.

- 여섯 번째로 브라우저가 응답을 처리합니다. 브라우저는 받은 HTML을 파싱하고, CSS와 JavaScript를 실행하여 웹 페이지를 렌더링합니다.

- 일곱 번째로 추가 리소스를 요청합니다. HTML에 포함된 이미지, CSS, JavaScript 파일 등을 추가로 요청합니다.

- 여덟 번째로 연결을 종료합니다. 모든 리소스 로딩이 완료되면 TCP 연결을 종료합니다.

- 참고 자료: https://www.nossi.dev/74d8965e-621d-4f38-8fcc-8493828ea223

</details>

<details>
<summary>DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요?</summary>

- DNS 쿼리를 통해 얻어진 IP 주소는 GitHub의 웹 서버를 가리키고 있습니다.

- GitHub는 여러 개의 서버를 운영하고 있으며, DNS 쿼리 결과는 이 중 하나의 서버 IP 주소를 반환합니다. 이는 로드 밸런싱을 통해 사용자 요청을 여러 서버에 분산하기 위함입니다.

- 얻어진 IP 주소는 GitHub의 프론트엔드 서버를 가리키며, 이 서버는 사용자의 요청을 받아 적절한 백엔드 서버로 전달합니다.

- GitHub는 CDN(Content Delivery Network)을 사용하여 전 세계 여러 지역에 서버를 배치하고 있으므로, DNS 쿼리 결과는 사용자의 위치에 따라 다른 IP 주소를 반환할 수 있습니다.

- 따라서 DNS 쿼리 결과는 GitHub의 웹 서버 중 하나를 가리키며, 이 서버를 통해 GitHub의 서비스를 이용할 수 있습니다.

</details>

<details>
<summary>Web Server와 Web Application Server의 차이에 대해 설명해 주세요.</summary>

- Web Server와 Web Application Server는 웹 애플리케이션의 서로 다른 계층에서 동작하는 서버입니다.

- Web Server는 정적 파일(HTML, CSS, JavaScript, 이미지 등)을 제공하는 서버입니다. Apache, Nginx 등이 대표적인 Web Server이며, 클라이언트의 요청에 대해 미리 만들어진 파일을 전송합니다.

- Web Application Server는 동적 콘텐츠를 생성하는 서버입니다. Tomcat, IIS 등이 대표적인 Web Application Server이며, 클라이언트의 요청에 따라 실시간으로 콘텐츠를 생성하여 전송합니다.

- 기능 측면에서 Web Server는 파일 전송에 특화되어 있고, Web Application Server는 비즈니스 로직 처리에 특화되어 있습니다.

- 성능 측면에서 Web Server는 정적 파일 전송에 최적화되어 있어 빠르지만, Web Application Server는 동적 처리로 인해 상대적으로 느릴 수 있습니다.

- 실제 웹 애플리케이션에서는 두 서버를 함께 사용하여, 정적 파일은 Web Server가, 동적 콘텐츠는 Web Application Server가 처리하도록 구성합니다.

</details>

<details>
<summary>URL, URI, URN은 어떤 차이가 있나요?</summary>

- URL, URI, URN은 웹 리소스를 식별하는 서로 다른 개념입니다.

- URI(Uniform Resource Identifier)는 리소스를 식별하는 일반적인 개념으로, URL과 URN을 포함하는 상위 개념입니다. URI는 리소스의 위치나 이름을 나타내는 문자열입니다.

- URL(Uniform Resource Locator)은 리소스의 위치를 나타내는 URI입니다. 예를 들어 https://www.github.com/user/repo는 GitHub의 특정 저장소 위치를 나타냅니다.

- URN(Uniform Resource Name)은 리소스의 이름을 나타내는 URI입니다. 예를 들어 urn:isbn:1234567890은 특정 ISBN 번호를 가진 책을 나타냅니다.

- 관계적으로 URI는 URL과 URN을 포함하는 개념이고, URL은 위치 기반, URN은 이름 기반으로 리소스를 식별합니다.

- 실제 웹에서는 URL이 가장 많이 사용되며, URN은 도서관이나 출판업계에서 주로 사용됩니다.

</details>

# 14. DNS

<details>
<summary>DNS에 대해 설명해 주세요.</summary>

</details>

<details>
<summary>DNS는 몇 계층 프로토콜인가요?</summary>

</details>

<details>
<summary>UDP와 TCP 중 어떤 것을 사용하나요?</summary>

</details>

<details>
<summary>DNS Recursive Query, Iterative Query가 무엇인가요?</summary>

</details>

<details>
<summary>DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?</summary>

</details>

<details>
<summary>캐싱된 DNS 쿼리가 잘못될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?</summary>

</details>

<details>
<summary>DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.</summary>

</details>

<details>
<summary>hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?</summary>

</details>

# 15. SOP와 CORS

<details>
<summary>SOP 정책에 대해 설명해 주세요.</summary>

</details>

<details>
<summary>CORS 정책이 무엇인가요?</summary>

</details>

<details>
<summary>Preflight에 대해 설명해 주세요.</summary>

</details>

# 16. Stateless와 Connectionless

<details>
<summary>Stateless와 Connectionless에 대해 설명해 주세요.</summary>

</details>

<details>
<summary>왜 HTTP는 Stateless 구조를 채택하고 있을까요?</summary>

</details>

<details>
<summary>Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?</summary>

</details>

<details>
<summary>TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?</summary>

</details>

# 17. 라우팅과 포워딩

<details>
<summary>라우터 내의 포워딩 과정에 대해 설명해 주세요.</summary>

</details>

<details>
<summary>라우팅과 포워딩의 차이는 무엇인가요?</summary>

</details>

<details>
<summary>라우팅 알고리즘에 대해 설명해 주세요.</summary>

</details>

<details>
<summary>포워딩 테이블의 구조에 대해 설명해 주세요.</summary>

</details>

# 18. 로드밸런서

<details>
<summary>로드밸런서가 무엇인가요?</summary>

</details>

<details>
<summary>L4 로드밸런서와 L7 로드밸런서의 차이에 대해 설명해 주세요.</summary>

</details>

<details>
<summary>로드밸런서 알고리즘에 대해 설명해 주세요.</summary>

</details>

<details>
<summary>로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능하다고 가정해 봅시다. 이 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하려면 어떻게 해야 할까요?</summary>

</details>

<details>
<summary>로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.</summary>

</details>

# 19. 서브넷 마스크와 게이트웨이

<details>
<summary>서브넷 마스크와 게이트웨이에 대해 설명해 주세요.</summary>

</details>

<details>
<summary>NAT에 대해 설명해 주세요.</summary>

</details>

<details>
<summary>서브넷 마스크의 표현 방식에 대해 설명해 주세요.</summary>

</details>

<details>
<summary>그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?</summary>

</details>

# 20. 멀티플렉싱과 디멀티플렉싱

<details>
<summary>멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.</summary>

</details>

<details>
<summary>디멀티플렉싱의 과정에 대해 설명해 주세요.</summary>

</details>

# 21. XSS

<details>
<summary>XSS에 대해서 설명해 주세요.</summary>

</details>

<details>
<summary>CSRF랑 XSS는 어떤 차이가 있나요?</summary>

</details>

<details>
<summary>XSS는 프론트엔드에서만 막을 수 있나요?</summary>

</details>